<!-- HAND-CRAFTED - DO NOT MODIFY VIA AGENTS -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MTG Sealed Simulator — Open Packs &amp; Build Your Deck Free | ScrollVault</title>
    <meta name="description" content="Free MTG sealed pool simulator. Open 6 virtual booster packs from any Magic set, sort by color/type/CMC, and build your 40-card sealed deck. Practice for prerelease and sealed events.">
    <meta name="robots" content="index, follow">
    <meta property="og:site_name" content="ScrollVault">
    <meta property="og:title" content="MTG Sealed Simulator — Open Packs &amp; Build Your Deck Free">
    <meta property="og:description" content="Free MTG sealed pool simulator. Open 6 virtual booster packs from any Magic set and build your 40-card sealed deck.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://scrollvault.net/tools/sealed/">
    <meta property="og:image" content="https://scrollvault.net/og-default.png">
    <meta property="og:image:alt" content="MTG Sealed Pool Simulator">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@scrollvault">
    <meta name="twitter:title" content="MTG Sealed Simulator — Open Packs &amp; Build Your Deck Free">
    <meta name="twitter:description" content="Free MTG sealed pool simulator. Open 6 packs, sort your pool, and build a 40-card deck.">
    <meta name="twitter:image" content="https://scrollvault.net/og-default.png">
    <link rel="canonical" href="https://scrollvault.net/tools/sealed/">
    <link rel="preload" href="/css/fonts/inter-latin.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="/css/fonts/space-grotesk-latin.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="icon" href="/favicon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-1CV3DS33WK"></script>
    <script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','G-1CV3DS33WK');</script>
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "MTG Sealed Pool Simulator",
        "description": "Free MTG sealed pool simulator. Open 6 virtual booster packs from any Magic set, sort by color/type/CMC, and build your 40-card sealed deck.",
        "url": "https://scrollvault.net/tools/sealed/",
        "applicationCategory": "GameApplication",
        "operatingSystem": "Any",
        "offers": { "@type": "Offer", "price": "0", "priceCurrency": "USD" },
        "publisher": { "@type": "Organization", "name": "ScrollVault", "url": "https://scrollvault.net", "logo": { "@type": "ImageObject", "url": "https://scrollvault.net/og-default.png" } }
    }
    </script>
    <script type="application/ld+json">
    {"@context":"https://schema.org","@type":"FAQPage","mainEntity":[{"@type":"Question","name":"How many packs do you open in MTG sealed?","acceptedAnswer":{"@type":"Answer","text":"In sealed format, each player opens 6 booster packs. This gives you approximately 84-90 cards to work with (depending on the set). You then build a minimum 40-card deck from your pool plus unlimited basic lands."}},{"@type":"Question","name":"How many cards in a sealed deck?","acceptedAnswer":{"@type":"Answer","text":"A sealed deck must contain at least 40 cards, including basic lands. The standard build is 22-23 spells from your pool plus 17-18 basic lands. Any cards not in your main deck become your sideboard."}},{"@type":"Question","name":"How to build a sealed deck in Magic?","acceptedAnswer":{"@type":"Answer","text":"First, sort your pool by color. Identify your two strongest colors based on removal, bombs (powerful rares), and creature quality. Select your best 22-23 cards in those colors, then add 17 lands split proportionally to your color requirements. Aim for a smooth mana curve peaking at 2-3 mana."}},{"@type":"Question","name":"What is sealed format in MTG?","acceptedAnswer":{"@type":"Answer","text":"Sealed is a Limited format where each player receives 6 unopened booster packs. You open all 6 packs and build a 40-card minimum deck from only those cards plus basic lands. It's commonly played at Prerelease events and on MTG Arena."}},{"@type":"Question","name":"How many lands in a sealed deck?","acceptedAnswer":{"@type":"Answer","text":"Most sealed decks run 17 lands, though aggressive decks may go down to 16 and slower decks up to 18. Split your lands proportionally to your colored mana symbols. For example, if you have twice as many blue symbols as white, play roughly 11 Islands and 6 Plains."}},{"@type":"Question","name":"Can I use this to practice for prerelease?","acceptedAnswer":{"@type":"Answer","text":"Absolutely! This simulator lets you practice sealed deck building with real card data from any set. Open 6 packs, sort your pool, and build your deck just like you would at a prerelease event. Practice identifying your best colors and building consistent 40-card decks."}}]}
    </script>
<style>
@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 400 700;
  font-display: swap;
  src: url('/css/fonts/inter-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
@font-face {
  font-family: 'Space Grotesk';
  font-style: normal;
  font-weight: 400 700;
  font-display: swap;
  src: url('/css/fonts/space-grotesk-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
/* ── Theme Variables ── */
:root {
    --bg-dark: #0f0f0f;
    --card-bg: #1a1a1a;
    --card-border: rgba(255,255,255,0.08);
    --card-hover-glow: rgba(139,92,246,0.25);
    --text-primary: #ffffff;
    --text-secondary: #a1a1aa;
    --text-muted: #71717a;
    --nav-bg: rgba(15,15,15,0.95);
    --nav-border: rgba(255,255,255,0.06);
    --gradient-purple: linear-gradient(135deg, #a855f7 0%, #6366f1 100%);
    --shadow-sm: 0 1px 2px rgba(0,0,0,0.3);
    --shadow-md: 0 4px 6px rgba(0,0,0,0.4);
    --shadow-lg: 0 10px 15px rgba(0,0,0,0.5);
    --color-W: #F9FAF4;
    --color-U: #0E68AB;
    --color-B: #150B00;
    --color-R: #D3202A;
    --color-G: #00733E;
}

* { margin: 0; padding: 0; box-sizing: border-box; }
html { scroll-behavior: smooth; }
body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; background: var(--bg-dark); color: var(--text-primary); line-height: 1.6; min-height: 100vh; }
h1,h2,h3,h4,h5,h6 { font-family: 'Space Grotesk', -apple-system, sans-serif; font-weight: 600; line-height: 1.3; }
a { color: inherit; text-decoration: none; transition: color 0.2s ease; }
a:hover { color: #a78bfa; }
.container { max-width: 1280px; margin: 0 auto; padding: 0 1rem; }

/* ── Nav ── */
.nav { position: fixed; top: 0; left: 0; right: 0; background: var(--nav-bg); border-bottom: 1px solid var(--nav-border); z-index: 1000; height: 64px; display: flex; align-items: center; }
.nav-content { display: flex; justify-content: space-between; align-items: center; width: 100%; }
.nav-logo { font-family: 'Space Grotesk', sans-serif; font-size: 1.5rem; font-weight: 700; background: var(--gradient-purple); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
.nav-links { display: flex; gap: 2rem; list-style: none; }
.nav-links a { font-size: 0.9rem; font-weight: 500; color: var(--text-secondary); }
.nav-links a:hover, .nav-links a.active { color: var(--text-primary); }
.mobile-menu-btn { display: none; background: none; border: none; color: var(--text-primary); font-size: 1.5rem; cursor: pointer; }
@media (max-width: 768px) {
    .nav-links { display: none; position: absolute; top: 64px; left: 0; right: 0; background: var(--nav-bg); border-bottom: 1px solid var(--nav-border); flex-direction: column; padding: 1rem; gap: 0; }
    .nav-links.active { display: flex; }
    .nav-links a { padding: 0.75rem 1rem; display: block; border-bottom: 1px solid var(--card-border); }
    .nav-links a:last-child { border-bottom: none; }
    .mobile-menu-btn { display: block; }
}

/* ── Footer ── */
footer { border-top: 1px solid var(--card-border); padding: 2rem 0; text-align: center; }
.footer-content { display: flex; flex-direction: column; align-items: center; gap: 1rem; }
.footer-logo { font-family: 'Space Grotesk', sans-serif; font-size: 1.25rem; font-weight: 700; background: var(--gradient-purple); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
.wubrg-dots { display: flex; gap: 0.5rem; }
.mana-dot { width: 12px; height: 12px; border-radius: 50%; }
.footer-text { color: var(--text-muted); font-size: 0.8rem; max-width: 500px; }
.footer-links { list-style: none; display: flex; gap: 1.5rem; flex-wrap: wrap; justify-content: center; }
.footer-links a { color: var(--text-muted); font-size: 0.8rem; }
.footer-links a:hover { color: #a78bfa; }

/* ── Main Layout ── */
main { margin-top: 64px; min-height: calc(100vh - 64px); padding: 2rem 0 3rem; }

/* ── Breadcrumb ── */
.breadcrumb { font-size: 0.85rem; color: var(--text-muted); margin-bottom: 1.5rem; }
.breadcrumb a { color: var(--text-secondary); }
.breadcrumb a:hover { color: #a78bfa; }
.breadcrumb span { margin: 0 0.4rem; }

/* ── Page Header ── */
.page-header { margin-bottom: 2rem; }
.page-header h1 { font-size: 2rem; margin-bottom: 0.5rem; background: var(--gradient-purple); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
.page-header p { color: var(--text-secondary); font-size: 1rem; max-width: 600px; }

/* ── Set Selection ── */
.set-selection { background: var(--card-bg); border: 1px solid var(--card-border); border-radius: 12px; padding: 2rem; margin-bottom: 2rem; }
.set-selection h2 { font-size: 1.25rem; margin-bottom: 1rem; }
.set-picker { display: flex; gap: 1rem; align-items: center; flex-wrap: wrap; }
.set-picker select { flex: 1; min-width: 200px; background: var(--bg-dark); border: 1px solid var(--card-border); color: var(--text-primary); padding: 0.75rem 1rem; border-radius: 8px; font-size: 0.95rem; font-family: 'Inter', sans-serif; cursor: pointer; appearance: none; -webkit-appearance: none; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23a1a1aa' d='M6 8L1 3h10z'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 12px center; padding-right: 2.5rem; }
.set-picker select:focus { outline: none; border-color: #a855f7; box-shadow: 0 0 0 2px rgba(168,85,247,0.2); }
.set-icon { width: 32px; height: 32px; filter: invert(1) brightness(0.8); flex-shrink: 0; }
.btn-primary { background: var(--gradient-purple); color: #fff; border: none; padding: 0.75rem 2rem; border-radius: 8px; font-size: 0.95rem; font-weight: 600; font-family: 'Space Grotesk', sans-serif; cursor: pointer; transition: transform 0.15s, box-shadow 0.15s; white-space: nowrap; }
.btn-primary:hover { transform: translateY(-1px); box-shadow: 0 4px 15px rgba(168,85,247,0.4); }
.btn-primary:active { transform: translateY(0); }
.btn-primary:disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }
.btn-secondary { background: transparent; color: var(--text-secondary); border: 1px solid var(--card-border); padding: 0.5rem 1.25rem; border-radius: 8px; font-size: 0.85rem; font-weight: 500; font-family: 'Inter', sans-serif; cursor: pointer; transition: all 0.15s; }
.btn-secondary:hover { border-color: #a855f7; color: var(--text-primary); }
.btn-secondary.active { background: rgba(168,85,247,0.15); border-color: #a855f7; color: #a78bfa; }

/* ── Loading ── */
.loading-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 2000; justify-content: center; align-items: center; flex-direction: column; gap: 1.5rem; }
.loading-overlay.visible { display: flex; }
.spinner { width: 48px; height: 48px; border: 3px solid var(--card-border); border-top-color: #a855f7; border-radius: 50%; animation: spin 0.8s linear infinite; }
@keyframes spin { to { transform: rotate(360deg); } }
.loading-text { color: var(--text-secondary); font-size: 0.95rem; }
.loading-progress { color: var(--text-muted); font-size: 0.8rem; }

/* ── Pool View ── */
.pool-section { display: none; }
.pool-section.visible { display: block; }
.pool-controls { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; margin-bottom: 1.5rem; }
.pool-controls h2 { font-size: 1.25rem; }
.sort-buttons { display: flex; gap: 0.5rem; flex-wrap: wrap; }
.pool-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 0.75rem; margin-bottom: 2rem; }

/* ── Card ── */
.card-slot { position: relative; border-radius: 10px; overflow: hidden; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; aspect-ratio: 488/680; background: var(--card-bg); }
.card-slot img { width: 100%; height: 100%; object-fit: cover; display: block; border-radius: 10px; transition: opacity 0.15s; }
.card-slot:hover { transform: translateY(-4px) scale(1.02); box-shadow: 0 8px 25px rgba(168,85,247,0.3); z-index: 10; }
.card-slot.in-deck { box-shadow: 0 0 0 3px #a855f7, 0 4px 15px rgba(168,85,247,0.4); }
.card-slot.in-deck::after { content: '\2713'; position: absolute; top: 6px; right: 8px; background: #a855f7; color: #fff; width: 22px; height: 22px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.75rem; font-weight: 700; }
.card-slot.dimmed { opacity: 0.35; }
.card-slot.dimmed:hover { opacity: 0.7; }
.card-placeholder { width: 100%; height: 100%; background: var(--card-bg); border-radius: 10px; display: flex; align-items: center; justify-content: center; color: var(--text-muted); font-size: 0.75rem; text-align: center; padding: 0.5rem; }

/* ── Deck Builder ── */
.builder-section { display: none; background: var(--card-bg); border: 1px solid var(--card-border); border-radius: 12px; padding: 1.5rem; margin-top: 2rem; }
.builder-section.visible { display: block; }
.builder-header { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; margin-bottom: 1.5rem; }
.builder-header h2 { font-size: 1.25rem; }
.deck-counter { font-size: 1rem; font-weight: 600; color: var(--text-secondary); }
.deck-counter .count { color: #a78bfa; font-size: 1.15rem; }
.deck-counter.complete .count { color: #34d399; }

/* ── Basic Lands ── */
.lands-helper { background: var(--bg-dark); border: 1px solid var(--card-border); border-radius: 10px; padding: 1rem 1.25rem; margin-bottom: 1.5rem; }
.lands-helper h3 { font-size: 0.95rem; margin-bottom: 0.75rem; color: var(--text-secondary); }
.lands-row { display: flex; gap: 1rem; flex-wrap: wrap; }
.land-control { display: flex; align-items: center; gap: 0.5rem; }
.land-label { font-size: 0.85rem; color: var(--text-secondary); min-width: 56px; display: flex; align-items: center; gap: 0.35rem; }
.land-dot { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; }
.land-btn { width: 28px; height: 28px; border-radius: 6px; border: 1px solid var(--card-border); background: var(--card-bg); color: var(--text-primary); font-size: 1rem; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s; }
.land-btn:hover { border-color: #a855f7; background: rgba(168,85,247,0.15); }
.land-count { font-size: 0.9rem; font-weight: 600; min-width: 18px; text-align: center; color: var(--text-primary); }

/* ── CMC Curve ── */
.curve-chart { background: var(--bg-dark); border: 1px solid var(--card-border); border-radius: 10px; padding: 1rem 1.25rem; margin-bottom: 1.5rem; }
.curve-chart h3 { font-size: 0.95rem; margin-bottom: 0.75rem; color: var(--text-secondary); }
.curve-bars { display: flex; align-items: flex-end; gap: 4px; height: 80px; }
.curve-bar-wrapper { flex: 1; display: flex; flex-direction: column; align-items: center; height: 100%; justify-content: flex-end; }
.curve-bar { width: 100%; min-height: 2px; background: var(--gradient-purple); border-radius: 3px 3px 0 0; transition: height 0.3s ease; }
.curve-label { font-size: 0.65rem; color: var(--text-muted); margin-top: 4px; }
.curve-count { font-size: 0.65rem; color: var(--text-secondary); margin-bottom: 2px; }

/* ── Deck Grid ── */
.deck-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(130px, 1fr)); gap: 0.6rem; }
.deck-grid .card-slot { }
.deck-grid .card-slot.in-deck { box-shadow: none; }
.deck-grid .card-slot.in-deck::after { display: none; }

/* ── Action Bar ── */
.action-bar { display: flex; gap: 0.75rem; flex-wrap: wrap; margin-bottom: 1.5rem; }

/* ── Toast ── */
.toast { position: fixed; bottom: 2rem; left: 50%; transform: translateX(-50%) translateY(100px); background: #333; color: white; padding: 0.75rem 1.5rem; border-radius: 8px; font-size: 0.9rem; z-index: 3000; transition: transform 0.3s ease, opacity 0.3s ease; opacity: 0; pointer-events: none; }
.toast.visible { transform: translateX(-50%) translateY(0); opacity: 1; }

/* ── Pool Stats Bar ── */
.pool-stats { display: flex; gap: 1rem; flex-wrap: wrap; margin-bottom: 1rem; padding: 0.75rem 1rem; background: var(--card-bg); border: 1px solid var(--card-border); border-radius: 10px; font-size: 0.85rem; color: var(--text-secondary); align-items: center; }
.pool-stats .stat-label { color: var(--text-muted); font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.03em; }
.pool-stats .stat-value { font-weight: 600; color: var(--text-primary); }
.pool-stats .color-bars { display: flex; gap: 2px; align-items: center; }
.pool-stats .color-bar { height: 12px; border-radius: 2px; min-width: 3px; }
.pool-stats .bombs-list { color: #e8b931; font-size: 0.8rem; }

/* ── Pack Opening Ceremony ── */
.pack-opening { display: none; margin-bottom: 2rem; }
.pack-opening.visible { display: block; }
.po-title { font-size: 1.5rem; margin-bottom: 0.25rem; background: var(--gradient-purple); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
.po-subtitle { color: var(--text-secondary); font-size: 0.95rem; margin-bottom: 1.5rem; }
.packs-row { display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap; margin-bottom: 1.5rem; }
.pack-wrapper { width: 120px; height: 168px; background: linear-gradient(145deg, #2a1f3d, #1a1025); border: 2px solid rgba(168,85,247,0.3); border-radius: 10px; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 0.5rem; transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s; position: relative; }
.pack-wrapper:hover { transform: translateY(-4px); box-shadow: 0 8px 25px rgba(168,85,247,0.4); border-color: #a855f7; }
.pack-wrapper .pack-icon { width: 36px; height: 36px; filter: invert(1) brightness(0.8); }
.pack-wrapper .pack-num { font-size: 0.85rem; font-weight: 600; color: var(--text-secondary); font-family: 'Space Grotesk', sans-serif; }
.pack-wrapper.opened { opacity: 0.4; pointer-events: none; border-color: rgba(52,211,153,0.4); }
.pack-wrapper.opened::after { content: '\2713'; position: absolute; top: 8px; right: 10px; background: #34d399; color: #fff; width: 20px; height: 20px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.7rem; font-weight: 700; }
.pack-reveal { display: grid; grid-template-columns: repeat(auto-fill, minmax(130px, 1fr)); gap: 8px; min-height: 200px; margin-bottom: 1.5rem; }
.pack-reveal .card-slot { animation: revealCard 0.3s ease both; }
@keyframes revealCard { from { opacity: 0; transform: scale(0.8); } to { opacity: 1; transform: scale(1); } }
.pack-reveal .card-slot.is-mythic { animation: revealCard 0.3s ease both; box-shadow: 0 0 0 2px #f97316, 0 0 12px rgba(249,115,22,0.5); }
.pack-reveal .card-slot.is-rare { animation: revealCard 0.3s ease both; box-shadow: 0 0 0 2px #eab308, 0 0 10px rgba(234,179,8,0.4); }
.po-continue { margin: 1rem auto 0; display: block; animation: fadeIn 0.4s ease; }
@keyframes fadeIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }
@media (max-width: 768px) {
    .packs-row { gap: 0.75rem; }
    .pack-wrapper { width: 100px; height: 140px; }
    .pack-reveal { grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); }
}

/* ── Color Filters ── */
.color-filters { display: flex; gap: 0.35rem; flex-wrap: wrap; align-items: center; }
.color-filter { width: auto; min-width: 32px; height: 32px; border-radius: 16px; border: 2px solid transparent; background: var(--card-bg); color: var(--text-secondary); font-size: 0.75rem; font-weight: 600; font-family: 'Inter', sans-serif; cursor: pointer; transition: all 0.15s; padding: 0 0.5rem; display: flex; align-items: center; justify-content: center; }
.color-filter.cf-mana { width: 32px; padding: 0; border-radius: 50%; }
.color-filter:hover { border-color: rgba(168,85,247,0.5); }
.color-filter.active { border-color: #a855f7; box-shadow: 0 0 8px rgba(168,85,247,0.4); }

/* ── Tooltip ── */
.card-tooltip { position: fixed; z-index: 2000; background: #222; border: 1px solid rgba(255,255,255,0.15); border-radius: 8px; padding: 0.75rem; max-width: 280px; pointer-events: none; opacity: 0; transition: opacity 0.15s ease; font-size: 0.8rem; box-shadow: 0 8px 32px rgba(0,0,0,0.6); }
.card-tooltip.visible { opacity: 1; }
.card-tooltip .tt-name { font-family: 'Space Grotesk', sans-serif; font-weight: 600; font-size: 0.9rem; margin-bottom: 0.25rem; }
.card-tooltip .tt-cost { color: var(--text-secondary); font-size: 0.8rem; margin-bottom: 0.25rem; }
.card-tooltip .tt-type { color: var(--text-muted); font-size: 0.75rem; margin-bottom: 0.5rem; border-bottom: 1px solid var(--card-border); padding-bottom: 0.4rem; }
.card-tooltip .tt-oracle { color: var(--text-secondary); font-size: 0.75rem; line-height: 1.5; }
.card-tooltip .tt-pt { color: var(--text-primary); font-weight: 600; font-size: 0.8rem; margin-top: 0.4rem; text-align: right; }
.card-tooltip .tt-rating { color: #a855f7; font-size: 0.7rem; margin-top: 0.25rem; }
@media (hover: none) and (pointer: coarse) { .card-tooltip { display: none !important; } }

/* ── Rarity Glow ── */
.rarity-mythic { box-shadow: 0 0 0 2px #f97316, 0 0 12px rgba(249,115,22,0.5); }
.rarity-rare { box-shadow: 0 0 0 2px #eab308, 0 0 10px rgba(234,179,8,0.4); }
.rarity-uncommon { box-shadow: 0 0 0 1px #94a3b8, 0 0 8px rgba(148,163,184,0.25); }
.card-slot.in-deck.rarity-mythic { box-shadow: 0 0 0 3px #a855f7, 0 0 0 5px #f97316, 0 4px 15px rgba(168,85,247,0.4); }
.card-slot.in-deck.rarity-rare { box-shadow: 0 0 0 3px #a855f7, 0 0 0 5px #eab308, 0 4px 15px rgba(168,85,247,0.4); }
.card-slot.in-deck.rarity-uncommon { box-shadow: 0 0 0 3px #a855f7, 0 0 0 5px #94a3b8, 0 4px 15px rgba(168,85,247,0.4); }

/* ── FAQ Section ── */
.faq-section { margin-top: 3rem; padding-top: 2rem; border-top: 1px solid var(--card-border); }
.faq-section h2 { font-size: 1.5rem; margin-bottom: 1.5rem; background: var(--gradient-purple); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
.faq-list { display: flex; flex-direction: column; gap: 0.75rem; max-width: 800px; }
.faq-item { background: var(--card-bg); border: 1px solid var(--card-border); border-radius: 10px; overflow: hidden; }
.faq-item summary { padding: 1rem 1.25rem; font-weight: 600; font-size: 0.95rem; cursor: pointer; list-style: none; display: flex; justify-content: space-between; align-items: center; }
.faq-item summary::-webkit-details-marker { display: none; }
.faq-item summary::after { content: '+'; font-size: 1.25rem; color: var(--text-muted); flex-shrink: 0; margin-left: 1rem; transition: transform 0.2s; }
.faq-item[open] summary::after { content: '\2212'; }
.faq-answer { padding: 0 1.25rem 1rem; color: var(--text-secondary); font-size: 0.9rem; line-height: 1.7; }
.faq-answer p { margin-bottom: 0.5rem; }
.faq-answer a { color: #a78bfa; text-decoration: underline; }

/* ── Responsive ── */
@media (max-width: 768px) {
    .page-header h1 { font-size: 1.5rem; }
    .set-selection { padding: 1.25rem; }
    .set-picker { flex-direction: column; align-items: stretch; }
    .set-picker select { min-width: unset; }
    .pool-grid { grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 0.5rem; }
    .deck-grid { grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); }
    .pool-controls { flex-direction: column; align-items: flex-start; }
    .lands-row { gap: 0.5rem; }
    .land-control { flex: 1 1 45%; min-width: 140px; }
    .builder-section { padding: 1rem; }
}
@media (max-width: 480px) {
    .pool-grid { grid-template-columns: repeat(3, 1fr); }
    .deck-grid { grid-template-columns: repeat(3, 1fr); }
}
</style>
</head>
<body>
<nav class="nav">
    <div class="container nav-content">
        <a href="/" class="nav-logo">ScrollVault</a>
        <button class="mobile-menu-btn" onclick="document.getElementById('navLinks').classList.toggle('active')">&#9776;</button>
        <ul class="nav-links" id="navLinks">
            <li><a href="/">Home</a></li>
            <li><a href="/news/">News</a></li>
            <li><a href="/guides/">Guides</a></li>
            <li><a href="/decks/">Top Decks</a></li>
            <li><a href="/draft/">Draft</a></li>
            <li><a href="/tools/" class="active">Tools</a></li>
            <li><a href="/about.html">About</a></li>
            <li><a href="/contact.html">Contact</a></li>
        </ul>
    </div>
</nav>

<div class="loading-overlay" id="loadingOverlay">
    <div class="spinner"></div>
    <div class="loading-text" id="loadingText">Fetching cards from Scryfall...</div>
    <div class="loading-progress" id="loadingProgress"></div>
</div>

<main>
    <div class="container">
        <div class="breadcrumb">
            <a href="/">Home</a><span>/</span>
            <a href="/tools/">Tools</a><span>/</span>
            Sealed Pool Simulator
        </div>

        <div class="page-header">
            <h1>MTG Sealed Pool Simulator</h1>
            <p>Open 6 virtual booster packs from any Magic: The Gathering set, then build your 40-card sealed deck. Practice for prerelease and sealed events.</p>
        </div>

        <!-- Screen 1: Set Selection -->
        <div class="set-selection" id="setSelection">
            <h2>Choose a Set</h2>
            <div class="set-picker">
                <img class="set-icon" id="setIcon" src="" alt="" style="display:none;">
                <select id="setSelect" aria-label="Select an MTG set">
                    <option value="">Loading sets...</option>
                </select>
                <button class="btn-primary" id="openPacksBtn" disabled>Open 6 Packs</button>
            </div>
        </div>

        <!-- Screen 1.5: Pack Opening Ceremony -->
        <div class="pack-opening" id="packOpening">
            <h2 class="po-title">Your Sealed Pool</h2>
            <p class="po-subtitle">Click each pack to open it</p>
            <div class="packs-row" id="packsRow"></div>
            <div class="pack-reveal" id="packReveal"></div>
            <button class="btn-primary po-continue" id="continueBtn" style="display:none;" onclick="continueToDeckBuilding()">Continue to Deck Building &rarr;</button>
        </div>

        <!-- Screen 2: Pool View -->
        <div class="pool-section" id="poolSection">
            <div class="pool-controls">
                <h2>Your Pool <span style="color:var(--text-muted);font-weight:400;font-size:0.9rem;" id="poolCount">(90 cards)</span></h2>
                <div class="sort-buttons">
                    <button class="btn-secondary active" data-sort="color" onclick="sortPool('color')">Color</button>
                    <button class="btn-secondary" data-sort="type" onclick="sortPool('type')">Type</button>
                    <button class="btn-secondary" data-sort="cmc" onclick="sortPool('cmc')">CMC</button>
                    <button class="btn-secondary" data-sort="rarity" onclick="sortPool('rarity')">Rarity</button>
                </div>
                <div class="color-filters" id="colorFilters">
                    <button class="color-filter active" data-color="all" onclick="filterPool('all')">All</button>
                    <button class="color-filter cf-mana" data-color="W" onclick="filterPool('W')" style="background:var(--color-W);color:#333;">W</button>
                    <button class="color-filter cf-mana" data-color="U" onclick="filterPool('U')" style="background:var(--color-U);color:#fff;">U</button>
                    <button class="color-filter cf-mana" data-color="B" onclick="filterPool('B')" style="background:var(--color-B);color:#fff;border:1px solid rgba(255,255,255,0.3);">B</button>
                    <button class="color-filter cf-mana" data-color="R" onclick="filterPool('R')" style="background:var(--color-R);color:#fff;">R</button>
                    <button class="color-filter cf-mana" data-color="G" onclick="filterPool('G')" style="background:var(--color-G);color:#fff;">G</button>
                    <button class="color-filter" data-color="M" onclick="filterPool('M')">Multi</button>
                    <button class="color-filter" data-color="C" onclick="filterPool('C')">C</button>
                </div>
            </div>
            <div class="pool-stats" id="poolStats" style="display:none;"></div>
            <div class="action-bar">
                <button class="btn-secondary" onclick="autoBuildDeck()">Auto-Build Deck</button>
                <button class="btn-secondary" onclick="optimizeWithWasm()" id="wasmOptBtn" style="display:none;">Optimize with AI</button>
                <button class="btn-secondary" onclick="exportToArena()">Export to Arena</button>
                <button class="btn-secondary" onclick="resetDeck()">Clear Deck</button>
                <button class="btn-secondary" onclick="newPool()">New Pool</button>
            </div>
            <div id="wasmOptResult" style="display:none;margin-bottom:1rem;padding:0.75rem 1rem;background:var(--card-bg);border:1px solid var(--card-border);border-radius:8px;font-size:0.85rem;color:var(--text-secondary);"></div>
            <div class="pool-grid" id="poolGrid"></div>
        </div>

        <!-- Screen 3: Deck Builder -->
        <div class="builder-section" id="builderSection">
            <div class="builder-header">
                <h2>Your Deck</h2>
                <div class="deck-counter" id="deckCounter">
                    <span class="count" id="deckCount">0</span> / 40 cards
                </div>
            </div>

            <!-- Basic Lands Helper -->
            <div class="lands-helper">
                <h3>Add Basic Lands</h3>
                <div class="lands-row">
                    <div class="land-control">
                        <span class="land-label"><span class="land-dot" style="background:#F9FAF4;"></span> Plains</span>
                        <button class="land-btn" onclick="changeLand('Plains',-1)">-</button>
                        <span class="land-count" id="landPlains">0</span>
                        <button class="land-btn" onclick="changeLand('Plains',1)">+</button>
                    </div>
                    <div class="land-control">
                        <span class="land-label"><span class="land-dot" style="background:#0E68AB;"></span> Island</span>
                        <button class="land-btn" onclick="changeLand('Island',-1)">-</button>
                        <span class="land-count" id="landIsland">0</span>
                        <button class="land-btn" onclick="changeLand('Island',1)">+</button>
                    </div>
                    <div class="land-control">
                        <span class="land-label"><span class="land-dot" style="background:#150B00;border:1px solid rgba(255,255,255,0.3);"></span> Swamp</span>
                        <button class="land-btn" onclick="changeLand('Swamp',-1)">-</button>
                        <span class="land-count" id="landSwamp">0</span>
                        <button class="land-btn" onclick="changeLand('Swamp',1)">+</button>
                    </div>
                    <div class="land-control">
                        <span class="land-label"><span class="land-dot" style="background:#D3202A;"></span> Mountain</span>
                        <button class="land-btn" onclick="changeLand('Mountain',-1)">-</button>
                        <span class="land-count" id="landMountain">0</span>
                        <button class="land-btn" onclick="changeLand('Mountain',1)">+</button>
                    </div>
                    <div class="land-control">
                        <span class="land-label"><span class="land-dot" style="background:#00733E;"></span> Forest</span>
                        <button class="land-btn" onclick="changeLand('Forest',-1)">-</button>
                        <span class="land-count" id="landForest">0</span>
                        <button class="land-btn" onclick="changeLand('Forest',1)">+</button>
                    </div>
                </div>
            </div>

            <!-- CMC Curve -->
            <div class="curve-chart">
                <h3>Mana Curve</h3>
                <div class="curve-bars" id="curveBars">
                    <div class="curve-bar-wrapper"><span class="curve-count">0</span><div class="curve-bar" style="height:2px;"></div><span class="curve-label">0</span></div>
                    <div class="curve-bar-wrapper"><span class="curve-count">0</span><div class="curve-bar" style="height:2px;"></div><span class="curve-label">1</span></div>
                    <div class="curve-bar-wrapper"><span class="curve-count">0</span><div class="curve-bar" style="height:2px;"></div><span class="curve-label">2</span></div>
                    <div class="curve-bar-wrapper"><span class="curve-count">0</span><div class="curve-bar" style="height:2px;"></div><span class="curve-label">3</span></div>
                    <div class="curve-bar-wrapper"><span class="curve-count">0</span><div class="curve-bar" style="height:2px;"></div><span class="curve-label">4</span></div>
                    <div class="curve-bar-wrapper"><span class="curve-count">0</span><div class="curve-bar" style="height:2px;"></div><span class="curve-label">5</span></div>
                    <div class="curve-bar-wrapper"><span class="curve-count">0</span><div class="curve-bar" style="height:2px;"></div><span class="curve-label">6</span></div>
                    <div class="curve-bar-wrapper"><span class="curve-count">0</span><div class="curve-bar" style="height:2px;"></div><span class="curve-label">7+</span></div>
                </div>
            </div>

            <div class="deck-grid" id="deckGrid"></div>
        </div>
        <!-- FAQ Section -->
        <div class="faq-section" id="faqSection">
            <h2>MTG Sealed Format FAQ</h2>
            <div class="faq-list">
                <details class="faq-item">
                    <summary>How many packs do you open in MTG sealed?</summary>
                    <div class="faq-answer">
                        <p>In sealed format, each player opens 6 booster packs. This gives you approximately 84-90 cards to work with (depending on the set and pack size). You then build a minimum 40-card deck from your pool plus unlimited basic lands. Any remaining cards form your sideboard.</p>
                    </div>
                </details>
                <details class="faq-item">
                    <summary>How many cards in a sealed deck?</summary>
                    <div class="faq-answer">
                        <p>A sealed deck must contain at least 40 cards, including basic lands. The standard build is 22-23 spells from your pool plus 17-18 basic lands. You can play more than 40 cards, but 40 is strongly recommended for consistency. Any cards not in your main deck become your sideboard, which you can swap cards from between games.</p>
                    </div>
                </details>
                <details class="faq-item">
                    <summary>How to build a sealed deck in Magic?</summary>
                    <div class="faq-answer">
                        <p>First, sort your pool by color. Identify your two strongest colors based on removal spells, bombs (powerful rares/mythics), and creature quality. Select your best 22-23 cards in those colors, then add 17 lands split proportionally to your color requirements. Aim for a smooth mana curve peaking at 2-3 mana with 14-17 creatures. Use our <a href="/tools/manabase/">Mana Base Calculator</a> to optimize your land split.</p>
                    </div>
                </details>
                <details class="faq-item">
                    <summary>What is sealed format in MTG?</summary>
                    <div class="faq-answer">
                        <p>Sealed is a Limited format where each player receives 6 unopened booster packs. You open all 6 packs and build a 40-card minimum deck from only those cards plus basic lands. Unlike draft, there's no card passing between players. Sealed is commonly played at Prerelease events, Grand Prix Day 1, and on MTG Arena. It tests both deck-building skill and adaptability to your card pool.</p>
                    </div>
                </details>
                <details class="faq-item">
                    <summary>How many lands in a sealed deck?</summary>
                    <div class="faq-answer">
                        <p>Most sealed decks run 17 lands, though aggressive low-curve decks may go down to 16 and slower control decks up to 18. Split your lands proportionally to your colored mana symbols. For example, if you have twice as many blue symbols as white, play roughly 11 Islands and 6 Plains. Any non-basic lands from your pool that fix your mana should be included if they produce your colors.</p>
                    </div>
                </details>
                <details class="faq-item">
                    <summary>Can I use this to practice for prerelease?</summary>
                    <div class="faq-answer">
                        <p>Absolutely! This simulator lets you practice sealed deck building with real card data. Select the prerelease set, open 6 packs, and build your deck just like you would at the event. Practice identifying your best two colors, building a consistent mana curve, and making tough cuts. You can also try the <a href="/draft/">Draft Simulator</a> for booster draft practice.</p>
                    </div>
                </details>
            </div>
        </div>
    </div>
</main>

<!-- Tooltip (desktop only) -->
<div class="card-tooltip" id="cardTooltip">
    <div class="tt-name"></div>
    <div class="tt-cost"></div>
    <div class="tt-type"></div>
    <div class="tt-oracle"></div>
    <div class="tt-pt"></div>
    <div class="tt-rating"></div>
</div>

<div class="toast" id="toast"></div>

<footer>
    <div class="container">
        <div class="footer-content">
            <div class="footer-logo">ScrollVault</div>
            <div class="wubrg-dots">
                <span class="mana-dot" style="background: #F9FAF4"></span>
                <span class="mana-dot" style="background: #0E68AB"></span>
                <span class="mana-dot" style="background: #150B00; border: 1px solid rgba(255,255,255,0.2)"></span>
                <span class="mana-dot" style="background: #D3202A"></span>
                <span class="mana-dot" style="background: #00733E"></span>
            </div>
            <p class="footer-text">&copy; 2026 scrollvault.net. Magic: The Gathering is a trademark of Wizards of the Coast. Card images &copy; Wizards of the Coast via Scryfall.</p>
            <ul class="footer-links">
                <li><a href="/privacy.html">Privacy Policy</a></li>
                <li><a href="/terms.html">Terms of Service</a></li>
                <li><a href="/contact.html">Contact</a></li>
                <li><a href="/about/authors.html">Authors</a></li>
                <li><a href="/about/editorial-policy.html">Editorial Policy</a></li>
            </ul>
        </div>
    </div>
</footer>

<script>
/* =========================================================
   Sealed Pool Simulator — ScrollVault
   Pre-cached data from /draft/data/ with Scryfall fallback
   ========================================================= */

// ── Touch Detection ──
const isTouchDevice = window.matchMedia('(hover: none) and (pointer: coarse)').matches;

// ── Scryfall rate-limit helper (fallback only) ──
const SCRYFALL_DELAY = 100;
let lastScryfallCall = 0;
async function scryfallFetch(url) {
    const now = Date.now();
    const wait = Math.max(0, SCRYFALL_DELAY - (now - lastScryfallCall));
    if (wait > 0) await new Promise(r => setTimeout(r, wait));
    lastScryfallCall = Date.now();
    const res = await fetch(url);
    if (!res.ok) throw new Error('Scryfall error: ' + res.status);
    return res.json();
}

// ── Toast ──
function showToast(msg) {
    const t = document.getElementById('toast');
    t.textContent = msg;
    t.classList.add('visible');
    setTimeout(() => t.classList.remove('visible'), 2500);
}

// ── Color helpers ──
const COLOR_ORDER = ['W', 'U', 'B', 'R', 'G'];
const COLOR_NAMES = { W: 'White', U: 'Blue', B: 'Black', R: 'Red', G: 'Green' };
const COLOR_HEX = { W: '#F9FAF4', U: '#0E68AB', B: '#3d3020', R: '#D3202A', G: '#00733E' };
const RARITY_ORDER = { mythic: 0, rare: 1, uncommon: 2, common: 3 };
const LAND_NAMES = { W: 'Plains', U: 'Island', B: 'Swamp', R: 'Mountain', G: 'Forest' };
const MANA_COLORS = ['W', 'U', 'B', 'R', 'G'];

function getColorGroup(card) {
    const colors = card.colors || [];
    if (isLand(card)) return 'Land';
    if (colors.length > 1) return 'Multi';
    if (colors.length === 1) return colors[0];
    return 'C';
}

function colorSortKey(card) {
    const group = getColorGroup(card);
    const order = { W: 0, U: 1, B: 2, R: 3, G: 4, Multi: 5, C: 6, Land: 7 };
    return (order[group] !== undefined ? order[group] : 8) * 10000 + (card.cmc || 0) * 100 + card.name.charCodeAt(0);
}

function typeSortKey(card) {
    const tl = (card.type_line || '').toLowerCase();
    let rank = 9;
    if (tl.includes('creature')) rank = 0;
    else if (tl.includes('planeswalker')) rank = 1;
    else if (tl.includes('instant')) rank = 2;
    else if (tl.includes('sorcery')) rank = 3;
    else if (tl.includes('enchantment')) rank = 4;
    else if (tl.includes('artifact')) rank = 5;
    else if (tl.includes('land')) rank = 8;
    return rank * 10000 + (card.cmc || 0) * 100 + card.name.charCodeAt(0);
}

function cmcSortKey(card) {
    return (card.cmc || 0) * 10000 + colorSortKey(card);
}

function raritySortKey(card) {
    return (RARITY_ORDER[card.rarity] !== undefined ? RARITY_ORDER[card.rarity] : 4) * 100000 + colorSortKey(card);
}

function isLand(card) {
    return (card.type_line || '').toLowerCase().includes('land');
}

function getImageUri(card) {
    // Pre-cached data uses image_small; Scryfall uses image_uris.normal
    if (card.image_small) return card.image_small;
    if (card.image_uris && card.image_uris.normal) return card.image_uris.normal;
    if (card.card_faces && card.card_faces[0] && card.card_faces[0].image_uris)
        return card.card_faces[0].image_uris.normal;
    return '';
}

function getCardColors(card) {
    if (card.colors && card.colors.length) return card.colors;
    if (card.card_faces) {
        const merged = new Set();
        card.card_faces.forEach(f => (f.colors || []).forEach(c => merged.add(c)));
        if (merged.size) return [...merged];
    }
    return card.color_identity || [];
}

function randomPick(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
}

// ── State ──
let cachedSetsIndex = null;  // Pre-cached sets from /draft/data/sets.json
let pool = [];
let deckSet = new Set();
let basicLands = { Plains: 0, Island: 0, Swamp: 0, Mountain: 0, Forest: 0 };
let currentSort = 'color';
let usingCachedData = false;
let activeFilters = new Set(['all']);
let generatedPacks = []; // 6 arrays of ~14 cards each
let packsOpened = 0;

// ── DOM refs ──
const setSelect = document.getElementById('setSelect');
const setIcon = document.getElementById('setIcon');
const openPacksBtn = document.getElementById('openPacksBtn');
const loadingOverlay = document.getElementById('loadingOverlay');
const loadingText = document.getElementById('loadingText');
const loadingProgress = document.getElementById('loadingProgress');
const poolSection = document.getElementById('poolSection');
const poolGrid = document.getElementById('poolGrid');
const poolCount = document.getElementById('poolCount');
const builderSection = document.getElementById('builderSection');
const deckGrid = document.getElementById('deckGrid');
const deckCountEl = document.getElementById('deckCount');
const deckCounter = document.getElementById('deckCounter');
const setSelection = document.getElementById('setSelection');
const poolStatsEl = document.getElementById('poolStats');
const packOpening = document.getElementById('packOpening');
const packsRow = document.getElementById('packsRow');
const packReveal = document.getElementById('packReveal');
const continueBtn = document.getElementById('continueBtn');

// ── Init: Load sets (pre-cached first, then Scryfall for extras) ──
(async function init() {
    try {
        // Load pre-cached sets first (instant)
        let cachedSets = [];
        try {
            const resp = await fetch('/draft/data/sets.json');
            cachedSetsIndex = await resp.json();
            cachedSets = cachedSetsIndex.map(s => ({
                code: s.set_code,
                name: s.set_name,
                released_at: s.released_at,
                icon_svg_uri: s.icon_uri,
                cached: true
            }));
        } catch (e) {
            console.warn('Could not load pre-cached sets:', e);
        }

        // Also load Scryfall sets for broader coverage
        let scryfallSets = [];
        try {
            const json = await scryfallFetch('https://api.scryfall.com/sets');
            const validTypes = new Set(['core', 'expansion', 'draft_innovation', 'masters']);
            scryfallSets = json.data
                .filter(s => validTypes.has(s.set_type) && !s.digital && s.card_count > 0)
                .map(s => ({
                    code: s.code,
                    name: s.name,
                    released_at: s.released_at,
                    icon_svg_uri: s.icon_svg_uri || '',
                    cached: false
                }));
        } catch (e) {
            console.warn('Could not load Scryfall sets:', e);
        }

        // Merge: pre-cached sets are marked with ⚡, sorted newest first
        const cachedCodes = new Set(cachedSets.map(s => s.code));
        const allSets = [...cachedSets];
        scryfallSets.forEach(s => {
            if (!cachedCodes.has(s.code)) allSets.push(s);
        });
        allSets.sort((a, b) => new Date(b.released_at) - new Date(a.released_at));

        setSelect.innerHTML = '<option value="">-- Select a set --</option>';
        allSets.forEach(s => {
            const opt = document.createElement('option');
            opt.value = s.code;
            const tag = s.cached ? ' \u26A1' : '';
            opt.textContent = s.name + ' (' + s.code.toUpperCase() + ', ' + (s.released_at || '').slice(0, 4) + ')' + tag;
            opt.dataset.icon = s.icon_svg_uri || '';
            opt.dataset.cached = s.cached ? '1' : '0';
            setSelect.appendChild(opt);
        });
    } catch (e) {
        setSelect.innerHTML = '<option value="">Failed to load sets. Refresh to retry.</option>';
        console.error('Failed to load sets:', e);
    }
})();

setSelect.addEventListener('change', function () {
    const opt = setSelect.options[setSelect.selectedIndex];
    const iconUrl = opt ? opt.dataset.icon : '';
    if (iconUrl) {
        setIcon.src = iconUrl;
        setIcon.style.display = 'block';
    } else {
        setIcon.style.display = 'none';
    }
    openPacksBtn.disabled = !setSelect.value;
});

openPacksBtn.addEventListener('click', () => openPacks());

async function openPacks() {
    const code = setSelect.value;
    if (!code) return;
    const opt = setSelect.options[setSelect.selectedIndex];
    const isCached = opt && opt.dataset.cached === '1';

    openPacksBtn.disabled = true;

    try {
        let cards;
        if (isCached) {
            // Use pre-cached data (instant!)
            showLoading('Loading set data...');
            const resp = await fetch('/draft/data/' + code + '.json');
            const setData = await resp.json();
            // setData.cards has { common: [], uncommon: [], rare: [], mythic: [] }
            cards = { common: setData.cards.common, uncommon: setData.cards.uncommon, rare: setData.cards.rare, mythic: setData.cards.mythic };
            usingCachedData = true;
        } else {
            // Fallback to Scryfall
            showLoading('Fetching cards from Scryfall...');
            const rawCards = await fetchScryfallCards(code);
            if (!rawCards || rawCards.length === 0) throw new Error('No cards found');
            const BASICS = new Set(['plains','island','swamp','mountain','forest','snow-covered plains','snow-covered island','snow-covered swamp','snow-covered mountain','snow-covered forest','wastes']);
            const nonBasic = rawCards.filter(c => !BASICS.has(c.name.toLowerCase()));
            cards = {
                common: nonBasic.filter(c => c.rarity === 'common'),
                uncommon: nonBasic.filter(c => c.rarity === 'uncommon'),
                rare: nonBasic.filter(c => c.rarity === 'rare'),
                mythic: nonBasic.filter(c => c.rarity === 'mythic')
            };
            usingCachedData = false;
        }

        if (cards.common.length < 10 || cards.uncommon.length < 3 || cards.rare.length < 1)
            throw new Error('Not enough cards of each rarity to build boosters.');

        // Generate 6 boosters
        pool = [];
        generatedPacks = [];
        packsOpened = 0;
        const usedRares = new Set();
        for (let i = 0; i < 6; i++) {
            const booster = generateBooster(cards, usedRares);
            generatedPacks.push(booster);
            pool.push(...booster);
        }

        // Normalize colors
        pool.forEach(c => { c.colors = c.colors || getCardColors(c); });

        // Reset deck
        deckSet.clear();
        basicLands = { Plains: 0, Island: 0, Swamp: 0, Mountain: 0, Forest: 0 };
        updateLandDisplay();

        hideLoading();

        // Show pack opening ceremony
        packOpening.classList.add('visible');
        continueBtn.style.display = 'none';
        renderPackWrappers();
        packOpening.scrollIntoView({ behavior: 'smooth', block: 'start' });
    } catch (e) {
        hideLoading();
        openPacksBtn.disabled = false;
        alert('Error: ' + e.message);
        console.error(e);
    }
}

async function fetchScryfallCards(code) {
    let allCards = [];
    let url = 'https://api.scryfall.com/cards/search?q=set:' + encodeURIComponent(code) + '+is:booster&order=set';
    let page = 1;
    while (url) {
        updateLoading('Fetching cards from Scryfall...', 'Page ' + page + '...');
        const json = await scryfallFetch(url);
        allCards = allCards.concat(json.data);
        if (json.has_more && json.next_page) { url = json.next_page; page++; }
        else url = null;
    }
    return allCards.map(c => ({
        name: c.name, rarity: c.rarity, cmc: c.cmc || 0,
        colors: getCardColors(c), type_line: c.type_line || '',
        mana_cost: c.mana_cost || '', rating: 0,
        oracle_text: c.oracle_text || (c.card_faces ? c.card_faces[0].oracle_text : '') || '',
        power: c.power || null,
        toughness: c.toughness || null,
        loyalty: c.loyalty || null,
        image_uris: c.image_uris ? { normal: c.image_uris.normal } : null,
        card_faces: c.card_faces ? c.card_faces.map(f => ({
            colors: f.colors || [],
            image_uris: f.image_uris ? { normal: f.image_uris.normal } : null
        })) : null
    }));
}

function generateBooster(cards, usedRares) {
    const booster = [];
    // 1 Rare/Mythic
    let rm = null;
    const isMythic = cards.mythic.length > 0 && Math.random() < 0.125;
    const rmPool = isMythic ? cards.mythic : cards.rare;
    let attempts = 0;
    while (!rm && attempts < 50) {
        const candidate = randomPick(rmPool);
        const key = candidate.collector_number || candidate.name;
        if (!usedRares.has(key)) { rm = { ...candidate }; usedRares.add(key); }
        attempts++;
    }
    if (!rm) rm = { ...randomPick(rmPool) };
    booster.push(rm);

    // 3 Uncommons
    const usedUC = new Set();
    for (let i = 0; i < 3; i++) {
        let card, att = 0;
        do { card = randomPick(cards.uncommon); att++; } while (usedUC.has(card.name) && att < 20);
        usedUC.add(card.name);
        booster.push({ ...card });
    }

    // 10 Commons
    const usedC = new Set();
    for (let i = 0; i < 10; i++) {
        let card, att = 0;
        do { card = randomPick(cards.common); att++; } while (usedC.has(card.name) && att < 30);
        usedC.add(card.name);
        booster.push({ ...card });
    }

    return booster;
}

// ── Pool Stats ──
function renderPoolStats() {
    if (pool.length === 0) { poolStatsEl.style.display = 'none'; return; }
    poolStatsEl.style.display = 'flex';

    // Color distribution
    const colorCounts = { W: 0, U: 0, B: 0, R: 0, G: 0, Multi: 0, C: 0 };
    const rarityCounts = { mythic: 0, rare: 0, uncommon: 0, common: 0 };
    const bombs = [];

    pool.forEach(card => {
        if (isLand(card)) return;
        const group = getColorGroup(card);
        if (colorCounts[group] !== undefined) colorCounts[group]++;
        rarityCounts[card.rarity] = (rarityCounts[card.rarity] || 0) + 1;
        if (card.rarity === 'mythic' || card.rarity === 'rare') bombs.push(card.name);
    });

    const maxColor = Math.max(...MANA_COLORS.map(c => colorCounts[c]), 1);

    let html = '<div><span class="stat-label">Colors</span> <div class="color-bars" style="display:inline-flex;gap:2px;vertical-align:middle;">';
    MANA_COLORS.forEach(c => {
        const w = Math.max(4, (colorCounts[c] / maxColor) * 40);
        html += `<span class="color-bar" style="background:${COLOR_HEX[c]};width:${w}px;" title="${COLOR_NAMES[c]}: ${colorCounts[c]}"></span>`;
    });
    html += '</div></div>';

    if (colorCounts.Multi > 0) html += `<div><span class="stat-label">Multi</span> <span class="stat-value">${colorCounts.Multi}</span></div>`;

    html += `<div><span class="stat-label">Mythic</span> <span class="stat-value">${rarityCounts.mythic}</span></div>`;
    html += `<div><span class="stat-label">Rare</span> <span class="stat-value">${rarityCounts.rare}</span></div>`;
    html += `<div><span class="stat-label">Uncommon</span> <span class="stat-value">${rarityCounts.uncommon}</span></div>`;

    if (bombs.length > 0) {
        html += `<div style="flex-basis:100%;"><span class="stat-label">Bombs</span> <span class="bombs-list">${bombs.join(', ')}</span></div>`;
    }

    poolStatsEl.innerHTML = html;
}

// ── Auto-Build Deck ──
function autoBuildDeck() {
    if (pool.length === 0) return;

    // Score each color
    const colorScores = { W: 0, U: 0, B: 0, R: 0, G: 0 };
    pool.forEach((card, idx) => {
        if (isLand(card)) return;
        const colors = card.colors || [];
        const score = cardPower(card);
        colors.forEach(c => { if (colorScores[c] !== undefined) colorScores[c] += score; });
    });

    // Pick top 2 colors
    const sorted = MANA_COLORS.slice().sort((a, b) => colorScores[b] - colorScores[a]);
    const primaryColors = new Set([sorted[0], sorted[1]]);

    // Select cards: on-color non-lands, sorted by power
    const candidates = [];
    pool.forEach((card, idx) => {
        if (isLand(card)) return;
        const colors = card.colors || [];
        const isOnColor = colors.length === 0 || colors.some(c => primaryColors.has(c));
        if (isOnColor) candidates.push({ idx, card, score: cardPower(card) });
    });
    candidates.sort((a, b) => b.score - a.score);

    // Take best 23 cards
    deckSet.clear();
    const selected = candidates.slice(0, 23);
    selected.forEach(c => deckSet.add(c.idx));

    // Auto-suggest lands (17 total)
    const pips = { W: 0, U: 0, B: 0, R: 0, G: 0 };
    selected.forEach(({ card }) => {
        const cost = card.mana_cost || '';
        (cost.match(/\{W\}/g) || []).forEach(() => pips.W++);
        (cost.match(/\{U\}/g) || []).forEach(() => pips.U++);
        (cost.match(/\{B\}/g) || []).forEach(() => pips.B++);
        (cost.match(/\{R\}/g) || []).forEach(() => pips.R++);
        (cost.match(/\{G\}/g) || []).forEach(() => pips.G++);
    });

    const totalPips = Object.values(pips).reduce((a, b) => a + b, 0) || 1;
    basicLands = { Plains: 0, Island: 0, Swamp: 0, Mountain: 0, Forest: 0 };
    const landMap = { W: 'Plains', U: 'Island', B: 'Swamp', R: 'Mountain', G: 'Forest' };
    let assigned = 0;
    MANA_COLORS.forEach(c => {
        if (pips[c] > 0) {
            basicLands[landMap[c]] = Math.round((pips[c] / totalPips) * 17);
            assigned += basicLands[landMap[c]];
        }
    });
    // Adjust to exactly 17
    const activeColors = MANA_COLORS.filter(c => pips[c] > 0).sort((a, b) => pips[b] - pips[a]);
    while (assigned < 17 && activeColors.length > 0) {
        basicLands[landMap[activeColors[0]]]++; assigned++;
    }
    while (assigned > 17 && activeColors.length > 0) {
        const smallest = activeColors[activeColors.length - 1];
        if (basicLands[landMap[smallest]] > 0) { basicLands[landMap[smallest]]--; assigned--; }
        else break;
    }

    updateLandDisplay();
    renderPool();
    renderDeck();
    updateDeckCounter();
    updateCurve();
    showToast('Auto-built ' + deckSet.size + ' spells + 17 lands in ' + sorted[0] + '/' + sorted[1]);
}

function cardPower(card) {
    // Use rating if available (pre-cached data), else estimate from rarity
    if (card.rating && card.rating > 0) return card.rating;
    const rarityScore = { mythic: 4.5, rare: 4.0, uncommon: 3.0, common: 2.0 };
    let score = rarityScore[card.rarity] || 2.0;
    const tl = (card.type_line || '').toLowerCase();
    if (tl.includes('creature')) score += 0.3;
    const oracle = (card.oracle_text || '').toLowerCase();
    if (oracle.includes('destroy') || oracle.includes('exile') || oracle.includes('damage')) score += 0.3;
    if (oracle.includes('flying') || oracle.includes('menace') || oracle.includes('trample')) score += 0.2;
    return score;
}

// ── Export to Arena ──
function exportToArena() {
    if (deckSet.size === 0) { showToast('Add cards to your deck first'); return; }

    let text = 'Deck\n';
    // Group and count deck cards
    const counts = {};
    deckSet.forEach(idx => {
        const name = pool[idx].name;
        counts[name] = (counts[name] || 0) + 1;
    });
    Object.keys(counts).sort().forEach(name => { text += counts[name] + ' ' + name + '\n'; });

    // Add lands
    Object.entries(basicLands).forEach(([type, count]) => {
        if (count > 0) text += count + ' ' + type + '\n';
    });

    // Sideboard (everything not in deck)
    const sideCounts = {};
    pool.forEach((card, idx) => {
        if (!deckSet.has(idx)) {
            sideCounts[card.name] = (sideCounts[card.name] || 0) + 1;
        }
    });
    if (Object.keys(sideCounts).length > 0) {
        text += '\nSideboard\n';
        Object.keys(sideCounts).sort().forEach(name => { text += sideCounts[name] + ' ' + name + '\n'; });
    }

    navigator.clipboard.writeText(text).then(() => {
        showToast('Deck copied to clipboard (Arena format)');
    }).catch(() => {
        const ta = document.createElement('textarea');
        ta.value = text; document.body.appendChild(ta); ta.select();
        document.execCommand('copy'); document.body.removeChild(ta);
        showToast('Deck copied to clipboard (Arena format)');
    });
}

// ── Sorting ──
function sortPool(sortBy) {
    currentSort = sortBy;
    document.querySelectorAll('.sort-buttons .btn-secondary').forEach(b => {
        b.classList.toggle('active', b.dataset.sort === sortBy);
    });
    renderPool();
}

function getSortedIndices() {
    const indices = pool.map((_, i) => i);
    const sortFn = {
        color: (a, b) => colorSortKey(pool[a]) - colorSortKey(pool[b]),
        type: (a, b) => typeSortKey(pool[a]) - typeSortKey(pool[b]),
        cmc: (a, b) => cmcSortKey(pool[a]) - cmcSortKey(pool[b]),
        rarity: (a, b) => raritySortKey(pool[a]) - raritySortKey(pool[b])
    };
    indices.sort(sortFn[currentSort] || sortFn.color);
    return indices;
}

// ── Color Filtering ──
function filterPool(color) {
    if (color === 'all') {
        activeFilters = new Set(['all']);
    } else {
        activeFilters.delete('all');
        if (activeFilters.has(color)) activeFilters.delete(color);
        else activeFilters.add(color);
        if (activeFilters.size === 0) activeFilters = new Set(['all']);
    }
    document.querySelectorAll('#colorFilters .color-filter').forEach(btn => {
        btn.classList.toggle('active', activeFilters.has(btn.dataset.color));
    });
    renderPool();
}

function cardMatchesFilter(card) {
    if (activeFilters.has('all')) return true;
    const colors = card.colors || [];
    const cardIsLand = isLand(card);
    if (activeFilters.has('C') && colors.length === 0 && !cardIsLand) return true;
    if (activeFilters.has('M') && colors.length > 1) return true;
    for (const c of colors) {
        if (activeFilters.has(c)) return true;
    }
    return false;
}

// ── Rendering ──
function renderPool() {
    const sorted = getSortedIndices();
    poolGrid.innerHTML = '';
    poolCount.textContent = '(' + pool.length + ' cards)';
    sorted.forEach(idx => {
        const card = pool[idx];
        const slot = createCardSlot(card, idx);
        if (deckSet.has(idx)) slot.classList.add('in-deck');
        if (!cardMatchesFilter(card)) slot.style.display = 'none';
        poolGrid.appendChild(slot);
    });
}

function createCardSlot(card, idx) {
    const slot = document.createElement('div');
    slot.className = 'card-slot';
    slot.dataset.idx = idx;
    const imgUrl = getImageUri(card);
    if (imgUrl) {
        const img = document.createElement('img');
        img.src = imgUrl; img.alt = card.name; img.loading = 'lazy';
        img.onerror = function () {
            this.style.display = 'none';
            const ph = document.createElement('div');
            ph.className = 'card-placeholder'; ph.textContent = card.name;
            slot.appendChild(ph);
        };
        slot.appendChild(img);
    } else {
        const ph = document.createElement('div');
        ph.className = 'card-placeholder'; ph.textContent = card.name;
        slot.appendChild(ph);
    }
    slot.classList.add('rarity-' + (card.rarity || 'common'));
    slot.addEventListener('click', () => toggleCard(idx));
    if (!isTouchDevice) {
        slot.addEventListener('mouseenter', (e) => showTooltip(card, e));
        slot.addEventListener('mousemove', (e) => moveTooltip(e));
        slot.addEventListener('mouseleave', hideTooltip);
    }
    slot.title = card.name + ' (' + card.rarity + ')';
    return slot;
}

function toggleCard(idx) {
    if (deckSet.has(idx)) deckSet.delete(idx);
    else deckSet.add(idx);
    renderPool();
    renderDeck();
    updateDeckCounter();
    updateCurve();
}

function renderDeck() {
    deckGrid.innerHTML = '';
    const deckIndices = [...deckSet].sort((a, b) => {
        const cmcDiff = (pool[a].cmc || 0) - (pool[b].cmc || 0);
        if (cmcDiff !== 0) return cmcDiff;
        return colorSortKey(pool[a]) - colorSortKey(pool[b]);
    });
    deckIndices.forEach(idx => {
        const slot = createCardSlot(pool[idx], idx);
        slot.classList.add('in-deck');
        deckGrid.appendChild(slot);
    });
}

function updateDeckCounter() {
    const totalLands = Object.values(basicLands).reduce((s, v) => s + v, 0);
    const total = deckSet.size + totalLands;
    deckCountEl.textContent = total;
    deckCounter.classList.toggle('complete', total === 40);
}

// ── Basic Lands ──
function changeLand(type, delta) {
    basicLands[type] = Math.max(0, (basicLands[type] || 0) + delta);
    updateLandDisplay();
    updateDeckCounter();
    updateCurve();
}

function updateLandDisplay() {
    Object.keys(basicLands).forEach(type => {
        const el = document.getElementById('land' + type);
        if (el) el.textContent = basicLands[type];
    });
}

// ── Mana Curve ──
function updateCurve() {
    const buckets = new Array(8).fill(0);
    deckSet.forEach(idx => {
        const card = pool[idx];
        if (isLand(card)) return;
        const cmc = Math.min(Math.floor(card.cmc || 0), 7);
        buckets[cmc]++;
    });
    const max = Math.max(...buckets, 1);
    const wrappers = document.getElementById('curveBars').children;
    for (let i = 0; i < 8; i++) {
        const wrapper = wrappers[i];
        if (!wrapper) continue;
        const bar = wrapper.querySelector('.curve-bar');
        const countEl = wrapper.querySelector('.curve-count');
        const pct = (buckets[i] / max) * 100;
        bar.style.height = Math.max(2, pct * 0.7) + 'px';
        countEl.textContent = buckets[i] || '';
    }
}

// ── Reset / New Pool ──
function resetDeck() {
    deckSet.clear();
    basicLands = { Plains: 0, Island: 0, Swamp: 0, Mountain: 0, Forest: 0 };
    updateLandDisplay();
    renderPool(); renderDeck(); updateDeckCounter(); updateCurve();
}

function newPool() {
    poolSection.classList.remove('visible');
    builderSection.classList.remove('visible');
    packOpening.classList.remove('visible');
    poolStatsEl.style.display = 'none';
    poolGrid.innerHTML = ''; deckGrid.innerHTML = '';
    pool = []; deckSet.clear();
    generatedPacks = []; packsOpened = 0;
    activeFilters = new Set(['all']);
    document.querySelectorAll('#colorFilters .color-filter').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.color === 'all');
    });
    basicLands = { Plains: 0, Island: 0, Swamp: 0, Mountain: 0, Forest: 0 };
    updateLandDisplay();
    openPacksBtn.disabled = false;
    setSelection.scrollIntoView({ behavior: 'smooth', block: 'start' });
}

// ── Pack Opening Ceremony ──
function renderPackWrappers() {
    packsRow.innerHTML = '';
    const iconUrl = setIcon.src || '';
    for (let i = 0; i < 6; i++) {
        const wrapper = document.createElement('div');
        wrapper.className = 'pack-wrapper';
        wrapper.innerHTML = (iconUrl ? '<img class="pack-icon" src="' + iconUrl + '" alt="" onerror="this.style.display=\'none\'">' : '') +
            '<span class="pack-num">Pack ' + (i + 1) + '</span>';
        wrapper.addEventListener('click', () => openSinglePack(i));
        packsRow.appendChild(wrapper);
    }
}

function openSinglePack(packIdx) {
    const wrappers = packsRow.querySelectorAll('.pack-wrapper');
    if (wrappers[packIdx].classList.contains('opened')) return;
    wrappers[packIdx].classList.add('opened');

    // Clear reveal area and show this pack's cards
    packReveal.innerHTML = '';
    const packCards = generatedPacks[packIdx];
    packCards.forEach((card, i) => {
        const slot = document.createElement('div');
        slot.className = 'card-slot';
        slot.style.animationDelay = (i * 30) + 'ms';
        if (card.rarity === 'mythic') slot.classList.add('is-mythic');
        else if (card.rarity === 'rare') slot.classList.add('is-rare');
        const imgUrl = getImageUri(card);
        if (imgUrl) {
            const img = document.createElement('img');
            img.src = imgUrl; img.alt = card.name; img.loading = 'lazy';
            img.onerror = function() {
                this.style.display = 'none';
                const ph = document.createElement('div');
                ph.className = 'card-placeholder'; ph.textContent = card.name;
                slot.appendChild(ph);
            };
            slot.appendChild(img);
        } else {
            const ph = document.createElement('div');
            ph.className = 'card-placeholder'; ph.textContent = card.name;
            slot.appendChild(ph);
        }
        if (!isTouchDevice) {
            slot.addEventListener('mouseenter', (e) => showTooltip(card, e));
            slot.addEventListener('mousemove', (e) => moveTooltip(e));
            slot.addEventListener('mouseleave', hideTooltip);
        }
        packReveal.appendChild(slot);
    });

    packsOpened++;
    if (packsOpened >= 6) {
        continueBtn.style.display = '';
    }
}

function continueToDeckBuilding() {
    packOpening.classList.remove('visible');
    poolSection.classList.add('visible');
    builderSection.classList.add('visible');
    currentSort = 'color';
    activeFilters = new Set(['all']);
    document.querySelectorAll('#colorFilters .color-filter').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.color === 'all');
    });
    document.querySelectorAll('.sort-buttons .btn-secondary').forEach(b => {
        b.classList.toggle('active', b.dataset.sort === 'color');
    });
    renderPool();
    renderPoolStats();
    renderDeck();
    updateDeckCounter();
    updateCurve();
    poolSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
}

// ── Loading helpers ──
function showLoading(text) {
    loadingText.textContent = text || 'Loading...';
    loadingProgress.textContent = '';
    loadingOverlay.classList.add('visible');
}
function updateLoading(text, progress) {
    if (text) loadingText.textContent = text;
    if (progress) loadingProgress.textContent = progress;
}
function hideLoading() { loadingOverlay.classList.remove('visible'); }

// ── Tooltip ──
function showTooltip(card, e) {
    const tip = document.getElementById('cardTooltip');
    tip.querySelector('.tt-name').textContent = card.name;
    tip.querySelector('.tt-cost').textContent = card.mana_cost || '';
    tip.querySelector('.tt-type').textContent = card.type_line || '';
    tip.querySelector('.tt-oracle').textContent = card.oracle_text || '';
    let ptText = '';
    if (card.power !== null && card.power !== undefined && card.toughness !== null && card.toughness !== undefined) {
        ptText = card.power + '/' + card.toughness;
    } else if (card.loyalty !== null && card.loyalty !== undefined) {
        ptText = 'Loyalty: ' + card.loyalty;
    }
    tip.querySelector('.tt-pt').textContent = ptText;
    let ratingText = (card.rating ? 'Rating: ' + card.rating.toFixed(1) + ' \u2022 ' : '') + (card.rarity || '');
    if (card.gih_wr) ratingText += ' \u2022 ' + card.gih_wr + '% GIH WR';
    tip.querySelector('.tt-rating').textContent = ratingText;
    tip.classList.add('visible');
    moveTooltip(e);
}

function moveTooltip(e) {
    const tip = document.getElementById('cardTooltip');
    const pad = 15;
    let x = e.clientX + pad;
    let y = e.clientY + pad;
    const rect = tip.getBoundingClientRect();
    if (x + 280 > window.innerWidth) x = e.clientX - 280 - pad;
    if (y + rect.height > window.innerHeight) y = e.clientY - rect.height - pad;
    tip.style.left = x + 'px';
    tip.style.top = y + 'px';
}

function hideTooltip() {
    document.getElementById('cardTooltip').classList.remove('visible');
}

// ══════════════════════════════════════════
// WASM Sealed Optimizer
// ══════════════════════════════════════════
var wasmSealedWorker = null;
var wasmSealedReady = false;

(function initSealedWorker() {
    try {
        wasmSealedWorker = new Worker('/tools/sealed/sealed-worker.js', { type: 'module' });
        wasmSealedWorker.onmessage = function(e) {
            var data = e.data;
            if (data.type === 'ready') {
                wasmSealedReady = true;
                var btn = document.getElementById('wasmOptBtn');
                if (btn) btn.style.display = '';
                console.log('[Sealed] WASM worker ready');
            } else if (data.type === 'complete') {
                applySealedBuild(data.build);
            } else if (data.type === 'error') {
                console.warn('[Sealed WASM]', data.message);
                showToast('Optimization failed: ' + data.message);
            }
        };
        wasmSealedWorker.onerror = function(err) {
            console.warn('[Sealed] WASM worker failed:', err.message);
            wasmSealedWorker = null;
        };
    } catch (err) {
        console.warn('[Sealed] Cannot create WASM worker:', err.message);
    }
})();

function toDraftCard(card) {
    return {
        name: card.name || '',
        mana_cost: card.mana_cost || '',
        cmc: card.cmc || 0,
        type_line: card.type_line || '',
        colors: card.colors || [],
        rarity: (card.rarity || 'common').toLowerCase(),
        rating: card.rating || 0,
        gih_wr: card.gih_wr || null,
        power: card.power || null,
        toughness: card.toughness || null,
        keywords: card.keywords || []
    };
}

function optimizeWithWasm() {
    if (!wasmSealedWorker || !wasmSealedReady) {
        showToast('WASM not available — use Auto-Build instead');
        autoBuildDeck();
        return;
    }
    if (pool.length === 0) return;

    var draftCards = pool.map(toDraftCard);
    wasmSealedWorker.postMessage({ type: 'optimize', pool: draftCards });
    showToast('Optimizing sealed pool...');
}

function applySealedBuild(build) {
    if (!build || !build.maindeck) {
        showToast('Optimization returned no result');
        return;
    }

    // Map maindeck card names back to pool indices
    deckSet.clear();
    var usedIndices = new Set();
    build.maindeck.forEach(function(deckCard) {
        for (var i = 0; i < pool.length; i++) {
            if (!usedIndices.has(i) && pool[i].name === deckCard.name) {
                deckSet.add(i);
                usedIndices.add(i);
                break;
            }
        }
    });

    // Apply land distribution
    basicLands = { Plains: 0, Island: 0, Swamp: 0, Mountain: 0, Forest: 0 };
    if (build.lands) {
        basicLands.Plains = build.lands.plains || 0;
        basicLands.Island = build.lands.island || 0;
        basicLands.Swamp = build.lands.swamp || 0;
        basicLands.Mountain = build.lands.mountain || 0;
        basicLands.Forest = build.lands.forest || 0;
    }

    updateLandDisplay();
    renderPool();
    renderDeck();
    updateDeckCounter();
    updateCurve();

    // Show result info
    var colorNames = { W: 'White', U: 'Blue', B: 'Black', R: 'Red', G: 'Green' };
    var colors = (build.colors || []).map(function(c) { return colorNames[c] || c; });
    var totalLands = Object.values(basicLands).reduce(function(a, b) { return a + b; }, 0);
    var info = 'AI Optimized: ' + deckSet.size + ' spells + ' + totalLands + ' lands';
    if (colors.length > 0) info += ' (' + colors.join('/') + ')';
    if (build.score) info += ' — Quality score: ' + build.score.toFixed(1);
    if (build.creature_count) info += ' — ' + build.creature_count + ' creatures, ' + build.spell_count + ' non-creatures';

    var resultEl = document.getElementById('wasmOptResult');
    if (resultEl) {
        resultEl.textContent = info;
        resultEl.style.display = 'block';
    }
    showToast('AI optimization complete');
}
</script>
</body>
</html>
