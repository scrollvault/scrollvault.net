<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MTG Mana Base Calculator — How Many Lands? | Frank Karsten Math</title>
    <meta name="description" content="Free MTG mana base calculator powered by Frank Karsten's math. Find exactly how many lands and colored sources your deck needs. Works for Standard, Modern, Pioneer, Commander &amp; Limited. Import your decklist for instant results.">
    <meta name="robots" content="index, follow">
    <meta property="og:site_name" content="ScrollVault">
    <meta property="og:locale" content="en_US">
    <meta property="og:title" content="MTG Mana Base Calculator — How Many Lands Do You Need?">
    <meta property="og:description" content="Free mana base calculator for Magic: The Gathering. Uses Frank Karsten's proven hypergeometric math to compute exact land counts and colored sources for every format.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://scrollvault.net/tools/manabase/">
    <meta property="og:image" content="https://scrollvault.net/og-default.png">
    <meta property="og:image:alt" content="MTG Mana Base Calculator — How Many Lands Do You Need?">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@scrollvault">
    <meta name="twitter:title" content="MTG Mana Base Calculator — Frank Karsten's Land Math">
    <meta name="twitter:description" content="Free mana base calculator for MTG. Karsten's hypergeometric math for exact land counts in Standard, Modern, Pioneer, and Commander.">
    <meta name="twitter:image" content="https://scrollvault.net/og-default.png">
    <meta name="twitter:image:alt" content="MTG Mana Base Calculator — How Many Lands Do You Need?">
    <link rel="canonical" href="https://scrollvault.net/tools/manabase/">
    <link rel="preload" href="/css/fonts/inter-latin.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="/css/fonts/space-grotesk-latin.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="icon" href="/favicon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="stylesheet" href="/tools/manabase/import.css">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-1CV3DS33WK"></script>
    <script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','G-1CV3DS33WK');</script>
<style>
@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 400 700;
  font-display: swap;
  src: url('/css/fonts/inter-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
@font-face {
  font-family: 'Space Grotesk';
  font-style: normal;
  font-weight: 400 700;
  font-display: swap;
  src: url('/css/fonts/space-grotesk-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
/* ── Theme Variables ── */
:root {
    --bg-dark: #0f0f0f;
    --card-bg: #1a1a1a;
    --card-border: rgba(255,255,255,0.08);
    --card-hover-glow: rgba(139,92,246,0.25);
    --text-primary: #ffffff;
    --text-secondary: #a1a1aa;
    --text-muted: #71717a;
    --nav-bg: rgba(15,15,15,0.95);
    --nav-border: rgba(255,255,255,0.06);
    --gradient-purple: linear-gradient(135deg, #a855f7 0%, #6366f1 100%);
    --shadow-sm: 0 1px 2px rgba(0,0,0,0.3);
    --shadow-md: 0 4px 6px rgba(0,0,0,0.4);
    --shadow-lg: 0 10px 15px rgba(0,0,0,0.5);
    --color-W: #F9FAF4;
    --color-U: #0E68AB;
    --color-B: #150B00;
    --color-R: #D3202A;
    --color-G: #00733E;
}

* { margin: 0; padding: 0; box-sizing: border-box; }
html { /* scroll-behavior: smooth removed — causes Chrome scroll fighting on long pages */ }
body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; background: var(--bg-dark); color: var(--text-primary); line-height: 1.6; min-height: 100vh; }
h1,h2,h3,h4,h5,h6 { font-family: 'Space Grotesk', -apple-system, sans-serif; font-weight: 600; line-height: 1.3; }
a { color: inherit; text-decoration: none; transition: color 0.2s ease; }
a:hover { color: #a78bfa; }
.container { max-width: 1280px; margin: 0 auto; padding: 0 1rem; }

/* ── Nav ── */
.nav { position: fixed; top: 0; left: 0; right: 0; background: var(--nav-bg); border-bottom: 1px solid var(--nav-border); z-index: 1000; height: 64px; display: flex; align-items: center; }
.nav-content { display: flex; justify-content: space-between; align-items: center; width: 100%; }
.nav-logo { font-family: 'Space Grotesk', sans-serif; font-size: 1.5rem; font-weight: 700; background: var(--gradient-purple); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
.nav-links { display: flex; gap: 2rem; list-style: none; }
.nav-links a { font-size: 0.9rem; font-weight: 500; color: var(--text-secondary); }
.nav-links a:hover, .nav-links a.active { color: var(--text-primary); }
.mobile-menu-btn { display: none; background: none; border: none; color: var(--text-primary); font-size: 1.5rem; cursor: pointer; }
@media (max-width: 768px) {
    .nav-links { display: none; position: absolute; top: 64px; left: 0; right: 0; background: var(--nav-bg); border-bottom: 1px solid var(--nav-border); flex-direction: column; padding: 1rem; gap: 0; }
    .nav-links.active { display: flex; }
    .nav-links a { padding: 0.75rem 1rem; display: block; border-bottom: 1px solid var(--card-border); }
    .nav-links a:last-child { border-bottom: none; }
    .mobile-menu-btn { display: block; }
}

/* ── Footer ── */
footer { border-top: 1px solid var(--card-border); padding: 2rem 0; margin-top: 4rem; }
.footer-content { display: flex; flex-direction: column; align-items: center; gap: 1rem; text-align: center; }
.footer-logo { font-family: 'Space Grotesk', sans-serif; font-size: 1.25rem; font-weight: 700; background: var(--gradient-purple); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
.footer-text { color: var(--text-muted); font-size: 0.875rem; }
.footer-links { display: flex; gap: 1.5rem; list-style: none; }
.footer-links a { color: var(--text-secondary); font-size: 0.875rem; }
.footer-links a:hover { color: var(--text-primary); }
.wubrg-dots { display: flex; gap: 0.5rem; justify-content: center; margin-top: 0.25rem; }
.mana-dot { width: 10px; height: 10px; border-radius: 50%; }

/* ── Main ── */
main { margin-top: 64px; min-height: calc(100vh - 64px); padding-bottom: 2rem; }

/* ── Breadcrumb ── */
.breadcrumb { padding: 1.25rem 0 0; font-size: 0.85rem; color: var(--text-muted); }
.breadcrumb a { color: var(--text-secondary); }
.breadcrumb a:hover { color: #a78bfa; }
.breadcrumb span { margin: 0 0.4rem; }

/* ── Hero ── */
.hero-section { padding: 2rem 0 2.5rem; text-align: center; }
.hero-section h1 { font-size: 2.5rem; margin-bottom: 0.5rem; background: var(--gradient-purple); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
.hero-section .subtitle { color: var(--text-secondary); font-size: 1.05rem; max-width: 640px; margin: 0 auto; }

/* ── Calculator Layout ── */
.calc-layout { display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; isolation: isolate; }
@media (max-width: 960px) {
    .calc-layout { grid-template-columns: 1fr; }
}

/* ── Panels ── */
.panel { background: var(--card-bg); border: 1px solid var(--card-border); border-radius: 12px; padding: 1.5rem; }
#resultsPanel { contain: layout paint; will-change: transform; }
.panel h2 { font-size: 1.15rem; margin-bottom: 1.25rem; display: flex; align-items: center; gap: 0.5rem; }
.panel h2 .icon { font-size: 1.1rem; }
.panel h3 { font-size: 0.95rem; margin-bottom: 0.75rem; color: var(--text-secondary); }

/* ── Format Selector ── */
.format-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(110px, 1fr)); gap: 0.5rem; margin-bottom: 1.5rem; }
.format-btn { padding: 0.5rem 0.75rem; background: rgba(255,255,255,0.04); border: 1px solid var(--card-border); border-radius: 8px; font-size: 0.8rem; font-weight: 500; color: var(--text-secondary); cursor: pointer; font-family: inherit; transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease; text-align: center; }
.format-btn:hover { border-color: rgba(139,92,246,0.4); color: var(--text-primary); }
.format-btn.active { background: rgba(168,85,247,0.15); border-color: rgba(168,85,247,0.5); color: var(--text-primary); }
.format-btn .fmt-detail { display: block; font-size: 0.65rem; color: var(--text-muted); margin-top: 2px; }
.format-btn.active .fmt-detail { color: var(--text-secondary); }

/* ── Color Toggles ── */
.color-toggles { display: flex; gap: 0.75rem; margin-bottom: 1.5rem; justify-content: center; }
.color-toggle { width: 48px; height: 48px; border-radius: 50%; border: 3px solid transparent; cursor: pointer; font-weight: 700; font-size: 1rem; font-family: 'Space Grotesk', sans-serif; transition: opacity 0.2s ease, border-color 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease; display: flex; align-items: center; justify-content: center; opacity: 0.4; position: relative; }
.color-toggle:hover { opacity: 0.7; transform: scale(1.08); }
.color-toggle.active { opacity: 1; border-color: rgba(168,85,247,0.7); transform: scale(1.1); box-shadow: 0 0 16px rgba(168,85,247,0.3); }
.color-toggle[data-color="W"] { background: var(--color-W); color: #333; }
.color-toggle[data-color="U"] { background: var(--color-U); color: #fff; }
.color-toggle[data-color="B"] { background: var(--color-B); color: #aaa; border: 3px solid rgba(255,255,255,0.15); }
.color-toggle[data-color="B"].active { border-color: rgba(168,85,247,0.7); }
.color-toggle[data-color="R"] { background: var(--color-R); color: #fff; }
.color-toggle[data-color="G"] { background: var(--color-G); color: #fff; }

/* ── Pip Inputs ── */
.pip-section { margin-bottom: 1.5rem; }
.pip-row { display: flex; align-items: center; gap: 0.75rem; padding: 0.6rem 0; border-bottom: 1px solid rgba(255,255,255,0.04); }
.pip-row:last-child { border-bottom: none; }
.pip-color-dot { width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.7rem; font-weight: 700; flex-shrink: 0; }
.pip-label { flex: 1; font-size: 0.85rem; color: var(--text-secondary); }
.pip-controls { display: flex; align-items: center; gap: 0; }
.pip-btn { width: 32px; height: 32px; background: rgba(255,255,255,0.06); border: 1px solid var(--card-border); color: var(--text-primary); font-size: 1rem; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: background 0.15s ease, border-color 0.15s ease; font-family: inherit; }
.pip-btn:hover { background: rgba(168,85,247,0.2); border-color: rgba(168,85,247,0.4); }
.pip-btn:first-child { border-radius: 6px 0 0 6px; }
.pip-btn:last-child { border-radius: 0 6px 6px 0; }
.pip-value { width: 40px; height: 32px; background: rgba(255,255,255,0.03); border: 1px solid var(--card-border); border-left: none; border-right: none; color: var(--text-primary); font-size: 0.9rem; font-weight: 600; text-align: center; font-family: inherit; }
.pip-value:focus { outline: none; background: rgba(168,85,247,0.1); }

/* ── Deck Size / Total Lands ── */
.size-inputs { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem; }
.size-group label { display: block; font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.35rem; }
.size-group input { width: 100%; padding: 0.5rem 0.75rem; background: rgba(255,255,255,0.04); border: 1px solid var(--card-border); border-radius: 8px; color: var(--text-primary); font-size: 1rem; font-weight: 600; font-family: inherit; text-align: center; }
.size-group input:focus { outline: none; border-color: rgba(168,85,247,0.5); background: rgba(168,85,247,0.08); }

/* ── Mana Curve ── */
.curve-section { margin-bottom: 1.5rem; }
.curve-inputs { display: grid; grid-template-columns: repeat(8, 1fr); gap: 0.4rem; }
.curve-col { text-align: center; }
.curve-col label { display: block; font-size: 0.7rem; color: var(--text-muted); margin-bottom: 0.3rem; font-weight: 500; }
.curve-col input { width: 100%; padding: 0.4rem; background: rgba(255,255,255,0.04); border: 1px solid var(--card-border); border-radius: 6px; color: var(--text-primary); font-size: 0.85rem; font-weight: 600; text-align: center; font-family: inherit; }
.curve-col input:focus { outline: none; border-color: rgba(168,85,247,0.5); background: rgba(168,85,247,0.08); }
.curve-total { margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-muted); text-align: center; }
.curve-total strong { color: var(--text-primary); }

/* ── Calculate Button ── */
.calc-btn { display: block; width: 100%; padding: 0.85rem; background: var(--gradient-purple); border: none; border-radius: 10px; font-size: 1rem; font-weight: 600; color: white; cursor: pointer; font-family: 'Space Grotesk', sans-serif; transition: opacity 0.2s ease, transform 0.2s ease; margin-top: 0.5rem; }
.calc-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 24px rgba(139,92,246,0.4); }
.calc-btn:active { transform: translateY(0); }

/* ── Results Panel ── */
.results-empty { text-align: center; padding: 3rem 1rem; color: var(--text-muted); }
.results-empty .empty-icon { font-size: 3rem; margin-bottom: 1rem; opacity: 0.3; }
.results-empty p { font-size: 0.9rem; }

/* ── Land Count Cards ── */
.land-counts { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 0.75rem; margin-bottom: 1.75rem; }
.land-card { background: rgba(255,255,255,0.03); border: 1px solid var(--card-border); border-radius: 10px; padding: 1rem; text-align: center; transition: border-color 0.2s ease, box-shadow 0.2s ease; position: relative; overflow: clip; }
.land-card::before { content: ''; position: absolute; top: 0; left: 0; right: 0; height: 3px; }
.land-card[data-color="W"]::before { background: var(--color-W); }
.land-card[data-color="U"]::before { background: var(--color-U); }
.land-card[data-color="B"]::before { background: linear-gradient(90deg, #555, #333); }
.land-card[data-color="R"]::before { background: var(--color-R); }
.land-card[data-color="G"]::before { background: var(--color-G); }
.land-card[data-color="C"]::before { background: var(--gradient-purple); }
.land-card .land-count { font-family: 'Space Grotesk', sans-serif; font-size: 2rem; font-weight: 700; }
.land-card[data-color="W"] .land-count { color: var(--color-W); }
.land-card[data-color="U"] .land-count { color: var(--color-U); }
.land-card[data-color="B"] .land-count { color: #888; }
.land-card[data-color="R"] .land-count { color: var(--color-R); }
.land-card[data-color="G"] .land-count { color: var(--color-G); }
.land-card[data-color="C"] .land-count { color: #a78bfa; }
.land-card .land-label { font-size: 0.75rem; color: var(--text-muted); margin-top: 0.2rem; }
.land-card .land-pct { font-size: 0.7rem; color: var(--text-secondary); margin-top: 0.15rem; }

/* ── Bar Chart ── */
.chart-section { margin-bottom: 1.75rem; }
.bar-chart { display: flex; align-items: flex-end; gap: 8px; height: 140px; padding: 0 0.5rem; }
.bar-col { flex: 1; display: flex; flex-direction: column; align-items: center; gap: 4px; min-width: 0; }
.bar-fill { width: 100%; border-radius: 4px 4px 0 0; transition: height 0.4s ease; min-height: 0; }
.bar-fill[data-color="W"] { background: var(--color-W); opacity: 0.85; }
.bar-fill[data-color="U"] { background: var(--color-U); }
.bar-fill[data-color="B"] { background: #555; }
.bar-fill[data-color="R"] { background: var(--color-R); }
.bar-fill[data-color="G"] { background: var(--color-G); }
.bar-fill[data-color="C"] { background: linear-gradient(180deg, #a855f7, #6366f1); }
.bar-label { font-size: 0.7rem; color: var(--text-muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100%; }
.bar-count { font-size: 0.7rem; color: var(--text-secondary); font-weight: 600; }

/* ── Probability Table ── */
.prob-section { margin-bottom: 1.75rem; }
.prob-table-wrapper { overflow-x: auto; }
.prob-table { width: 100%; border-collapse: collapse; font-size: 0.78rem; }
.prob-table th { padding: 0.5rem 0.6rem; text-align: center; font-weight: 600; color: var(--text-secondary); border-bottom: 2px solid var(--card-border); white-space: nowrap; background: rgba(255,255,255,0.02); }
.prob-table td { padding: 0.45rem 0.6rem; text-align: center; border-bottom: 1px solid rgba(255,255,255,0.04); color: var(--text-secondary); font-variant-numeric: tabular-nums; }
.prob-table tr:hover td { background: rgba(168,85,247,0.05); }
.prob-table .turn-col { font-weight: 600; color: var(--text-primary); text-align: left; }
.prob-good { color: #4ade80; }
.prob-ok { color: #facc15; }
.prob-bad { color: #f87171; }

/* ── Suggested Mana Base ── */
.suggested-section { margin-bottom: 1.75rem; }
.suggest-card { background: rgba(255,255,255,0.03); border: 1px solid var(--card-border); border-radius: 8px; padding: 0.85rem 1rem; margin-bottom: 0.5rem; }
.suggest-card h4 { font-size: 0.85rem; margin-bottom: 0.35rem; color: var(--text-primary); }
.suggest-card p { font-size: 0.78rem; color: var(--text-secondary); line-height: 1.5; }
.suggest-card .suggest-lands { display: flex; flex-wrap: wrap; gap: 0.35rem; margin-top: 0.4rem; }
.suggest-land { display: inline-flex; align-items: center; gap: 0.3rem; background: rgba(168,85,247,0.1); border: 1px solid rgba(168,85,247,0.2); border-radius: 5px; padding: 0.2rem 0.5rem; font-size: 0.72rem; color: var(--text-secondary); }
.suggest-land .sl-count { font-weight: 700; color: var(--text-primary); }

/* ── Info Box ── */
.info-box { background: rgba(168,85,247,0.08); border: 1px solid rgba(168,85,247,0.2); border-radius: 10px; padding: 1.25rem; margin-top: 1.5rem; content-visibility: auto; contain-intrinsic-size: auto 200px; }
.info-box h3 { font-size: 0.95rem; margin-bottom: 0.5rem; color: #a78bfa; display: flex; align-items: center; gap: 0.4rem; }
.info-box p { font-size: 0.82rem; color: var(--text-secondary); line-height: 1.65; }
.info-box a { color: #a78bfa; text-decoration: underline; }
.info-box a:hover { color: #c4b5fd; }

/* ── FAQ Section ── */
.faq-section { margin-top: 2rem; content-visibility: auto; contain-intrinsic-size: auto 500px; }
.faq-section h2 { font-size: 1.4rem; margin-bottom: 1rem; color: var(--text-primary); }
.faq-section details { background: var(--card-bg); border: 1px solid var(--card-border); border-radius: 10px; margin-bottom: 0.75rem; overflow: clip; }
.faq-section summary { padding: 1rem 1.25rem; font-weight: 600; font-size: 0.95rem; cursor: pointer; color: var(--text-primary); list-style: none; display: flex; justify-content: space-between; align-items: center; }
.faq-section summary::-webkit-details-marker { display: none; }
.faq-section summary::after { content: '+'; font-size: 1.2rem; color: var(--text-muted); flex-shrink: 0; margin-left: 1rem; }
.faq-section details[open] summary::after { content: '\2212'; }
.faq-section details[open] summary { border-bottom: 1px solid var(--card-border); }
.faq-section details p { padding: 1rem 1.25rem; font-size: 0.88rem; color: var(--text-secondary); line-height: 1.7; }

/* ── Responsive ── */
@media (max-width: 640px) {
    .hero-section h1 { font-size: 1.75rem; }
    .color-toggles { gap: 0.5rem; }
    .color-toggle { width: 40px; height: 40px; font-size: 0.85rem; }
    .curve-inputs { grid-template-columns: repeat(4, 1fr); }
    .land-counts { grid-template-columns: repeat(2, 1fr); }
    .format-grid { grid-template-columns: repeat(3, 1fr); }
    .size-inputs { grid-template-columns: 1fr; }
}

/* ── Sim Engine Badge ── */
.sim-engine-badge { display: inline-block; font-size: 0.7rem; font-weight: 700; padding: 1px 6px; border-radius: 3px; vertical-align: middle; letter-spacing: 0.5px; }
.sim-engine-wasm { background: #2e7d32; color: #e8f5e9; }
.sim-engine-js { background: #555; color: #ddd; }

/* ── Ramp Analysis Banner ── */
.ramp-banner { display: flex; align-items: center; gap: 0.5rem; padding: 0.4rem 0.85rem; border-radius: 8px; font-size: 0.78rem; font-weight: 500; margin-bottom: 0.75rem; background: rgba(139,92,246,0.08); border: 1px solid rgba(139,92,246,0.2); color: #c4b5fd; flex-wrap: wrap; }
.ramp-banner strong { color: #e9d5ff; }
.ramp-adjust { color: var(--text-muted); font-size: 0.72rem; }
.land-count-hint { display: flex; align-items: center; gap: 0.5rem; padding: 0.35rem 0.85rem; border-radius: 8px; font-size: 0.75rem; margin-bottom: 0.75rem; background: rgba(59,130,246,0.08); border: 1px solid rgba(59,130,246,0.2); color: #93c5fd; flex-wrap: wrap; }
.land-count-hint strong { color: #bfdbfe; }
.land-count-hint .hint-detail { color: var(--text-muted); font-size: 0.7rem; }

/* ── Smart Land Optimizer ── */
.tempo-badge { display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.4rem 0.85rem; border-radius: 8px; font-size: 0.78rem; font-weight: 500; margin-bottom: 1rem; }
.optimizer-heading { font-size: 0.9rem; color: var(--text-secondary); margin: 1rem 0 0.5rem; }
.optimizer-land-row { display: flex; align-items: center; gap: 0.5rem; padding: 0.35rem 0.5rem; border-bottom: 1px solid rgba(255,255,255,0.04); font-size: 0.78rem; flex-wrap: wrap; }
.optimizer-land-row:last-child { border-bottom: none; }
.optimizer-land-qty { font-weight: 700; color: var(--text-primary); min-width: 1.5em; text-align: right; font-family: 'Space Grotesk', sans-serif; font-size: 0.9rem; }
.optimizer-land-name { font-weight: 500; color: var(--text-primary); flex-shrink: 0; }
.optimizer-land-tag { font-size: 0.65rem; font-weight: 600; padding: 1px 6px; border: 1px solid; border-radius: 4px; white-space: nowrap; flex-shrink: 0; }
.optimizer-land-reason { font-size: 0.68rem; color: var(--text-muted); margin-left: auto; text-align: right; }
.source-summary { margin-top: 1rem; }
.source-row { display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.35rem; }
.source-label { font-size: 0.78rem; font-weight: 600; min-width: 3.5em; }
.source-bar-track { flex: 1; height: 8px; background: rgba(255,255,255,0.06); border-radius: 4px; overflow: hidden; }
.source-bar-fill { height: 100%; border-radius: 4px; transition: width 0.3s ease; }
.source-count { font-size: 0.75rem; font-weight: 600; min-width: 3.5em; text-align: right; }
.source-met { color: #4ade80; }
.source-short { color: #f87171; }
.life-estimate { margin-top: 0.75rem; font-size: 0.78rem; color: var(--text-muted); padding: 0.5rem 0.75rem; background: rgba(248,113,113,0.08); border: 1px solid rgba(248,113,113,0.15); border-radius: 6px; }
@media (max-width: 640px) {
    .optimizer-land-reason { margin-left: 0; width: 100%; padding-left: 2em; }
}
/* ── Card Image Preview ── */
.card-preview { position: fixed; z-index: 9999; pointer-events: none; opacity: 0; transition: opacity 0.15s ease; filter: drop-shadow(0 8px 24px rgba(0,0,0,0.7)); }
.card-preview.visible { opacity: 1; }
.card-preview img { display: block; width: 240px; border-radius: 10px; }
.card-name-link { cursor: pointer; text-decoration: underline; text-decoration-color: rgba(255,255,255,0.15); text-underline-offset: 2px; transition: text-decoration-color 0.15s; }
.card-name-link:hover { text-decoration-color: rgba(167,139,250,0.6); color: #c4b5fd; }
@media (max-width: 768px) { .card-preview img { width: 200px; } }
    </style>
</head>
<body>
    <div class="card-preview" id="cardPreview"><img alt="" /></div>
    <nav class="nav">
        <div class="container nav-content">
            <a href="/" class="nav-logo">ScrollVault</a>
            <button class="mobile-menu-btn" onclick="document.getElementById('navLinks').classList.toggle('active')">&#9776;</button>
            <ul class="nav-links" id="navLinks">
                <li><a href="/">Home</a></li>
                <li><a href="/news/">News</a></li>
                <li><a href="/guides/">Guides</a></li>
                <li><a href="/decks/">Top Decks</a></li>
                <li><a href="/draft/">Draft</a></li>
                <li><a href="/tools/" class="active">Tools</a></li>
                <li><a href="/about.html">About</a></li>
                <li><a href="/contact.html">Contact</a></li>
            </ul>
        </div>
    </nav>

    <main>
        <div class="container">
            <div class="breadcrumb">
                <a href="/">Home</a><span>/</span>
                <a href="/tools/">Tools</a><span>/</span>
                Mana Base Calculator
            </div>

            <div class="hero-section">
                <h1>MTG Mana Base Calculator</h1>
                <p class="subtitle">How many lands should you run? Use Frank Karsten's mana math to calculate exact colored source counts for any MTG format. Import your decklist or enter your mana curve to build the perfect mana base.</p>
            </div>

            <div class="calc-layout">
                <!-- ═══ LEFT: Input Panel ═══ -->
                <div class="panel" id="inputPanel">
                    <h2><span class="icon">&#9881;</span> Deck Configuration</h2>

                    <!-- Tab Toggle -->
                    <div class="input-tabs">
                        <button class="input-tab active" data-tab="manual" onclick="switchTab('manual')">Manual</button>
                        <button class="input-tab" data-tab="import" onclick="switchTab('import')">Import Decklist</button>
                    </div>

                    <!-- Import Panel (hidden by default) -->
                    <div id="importPanel">
                        <p class="import-desc">Paste your decklist below. Supports MTGA, Moxfield, and standard "4 Card Name" format.</p>
                        <textarea class="import-textarea" id="decklistInput" placeholder="4 Lightning Bolt
4 Monastery Swiftspear
4 Goblin Guide
4 Eidolon of the Great Revel
4 Searing Blaze
20 Mountain
..."></textarea>
                        <div class="import-status" id="importStatus"></div>
                        <button class="calc-btn" style="margin-top:0.75rem;" onclick="importDecklist()">Parse &amp; Calculate</button>
                    </div>

                    <!-- Manual Panel -->
                    <div id="manualPanel" class="active">

                    <!-- Format Selector -->
                    <h3>Format</h3>
                    <div class="format-grid" id="formatGrid">
                        <button class="format-btn active" data-format="standard" data-deck="60" data-lands="24">
                            Standard
                            <span class="fmt-detail">60 / 24 lands</span>
                        </button>
                        <button class="format-btn" data-format="modern" data-deck="60" data-lands="23">
                            Modern
                            <span class="fmt-detail">60 / 23 lands</span>
                        </button>
                        <button class="format-btn" data-format="pioneer" data-deck="60" data-lands="24">
                            Pioneer
                            <span class="fmt-detail">60 / 24 lands</span>
                        </button>
                        <button class="format-btn" data-format="legacy" data-deck="60" data-lands="22">
                            Legacy
                            <span class="fmt-detail">60 / 22 lands</span>
                        </button>
                        <button class="format-btn" data-format="limited" data-deck="40" data-lands="17">
                            Limited
                            <span class="fmt-detail">40 / 17 lands</span>
                        </button>
                        <button class="format-btn" data-format="commander" data-deck="100" data-lands="37">
                            Commander
                            <span class="fmt-detail">100 / 37 lands</span>
                        </button>
                        <button class="format-btn" data-format="custom">
                            Custom
                            <span class="fmt-detail">Set your own</span>
                        </button>
                    </div>

                    <!-- Deck Size / Land Count -->
                    <div class="size-inputs">
                        <div class="size-group">
                            <label for="deckSize">Deck Size</label>
                            <input type="number" id="deckSize" value="60" min="20" max="250">
                        </div>
                        <div class="size-group">
                            <label for="totalLands">Total Lands</label>
                            <input type="number" id="totalLands" value="24" min="0" max="120">
                        </div>
                    </div>

                    <!-- Color Toggles -->
                    <h3>Colors</h3>
                    <div class="color-toggles" id="colorToggles">
                        <button class="color-toggle active" data-color="W" title="White">W</button>
                        <button class="color-toggle active" data-color="U" title="Blue">U</button>
                        <button class="color-toggle" data-color="B" title="Black">B</button>
                        <button class="color-toggle" data-color="R" title="Red">R</button>
                        <button class="color-toggle" data-color="G" title="Green">G</button>
                    </div>

                    <!-- Pip Inputs -->
                    <h3>Colored Mana Pips</h3>
                    <div class="pip-section" id="pipSection">
                        <!-- Populated by JS -->
                    </div>

                    <!-- Mana Curve -->
                    <div class="curve-section">
                        <h3>Mana Curve (Number of Spells)</h3>
                        <div class="curve-inputs" id="curveInputs">
                            <div class="curve-col">
                                <label>0 MV</label>
                                <input type="number" min="0" max="60" value="0" data-mv="0">
                            </div>
                            <div class="curve-col">
                                <label>1 MV</label>
                                <input type="number" min="0" max="60" value="8" data-mv="1">
                            </div>
                            <div class="curve-col">
                                <label>2 MV</label>
                                <input type="number" min="0" max="60" value="10" data-mv="2">
                            </div>
                            <div class="curve-col">
                                <label>3 MV</label>
                                <input type="number" min="0" max="60" value="8" data-mv="3">
                            </div>
                            <div class="curve-col">
                                <label>4 MV</label>
                                <input type="number" min="0" max="60" value="6" data-mv="4">
                            </div>
                            <div class="curve-col">
                                <label>5 MV</label>
                                <input type="number" min="0" max="60" value="3" data-mv="5">
                            </div>
                            <div class="curve-col">
                                <label>6 MV</label>
                                <input type="number" min="0" max="60" value="1" data-mv="6">
                            </div>
                            <div class="curve-col">
                                <label>7+</label>
                                <input type="number" min="0" max="60" value="0" data-mv="7">
                            </div>
                        </div>
                        <div class="curve-total" id="curveTotal">Spells: <strong>36</strong> / Lands: <strong>24</strong> / Total: <strong>60</strong></div>
                    </div>

                    <button class="calc-btn" id="calcBtn" onclick="calculate()">Calculate Mana Base</button>

                    </div><!-- /manualPanel -->
                </div>

                <!-- ═══ RIGHT: Results Panel ═══ -->
                <div class="panel" id="resultsPanel">
                    <h2><span class="icon">&#9733;</span> Results</h2>

                    <div id="resultsContent">
                        <div class="results-empty">
                            <div class="empty-icon">&#127183;</div>
                            <p>Select your colors and configure your deck, then click <strong>Calculate Mana Base</strong> to see results.</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Info Box -->
            <div class="info-box">
                <h3>&#128218; How This Mana Calculator Works</h3>
                <p>
                    This MTG mana calculator implements <strong>Frank Karsten's mana math</strong>, the gold standard for manabase calculations.
                    Originally published in his ChannelFireball article
                    <a href="https://strategy.channelfireball.com/all-strategy/mtg/channelmagic-articles/how-many-colored-mana-sources-do-you-need-to-consistently-cast-your-spells-a-guilds-of-ravnica-update/" target="_blank" rel="noopener">"How Many Colored Mana Sources Do You Need to Consistently Cast Your Spells?"</a>,
                    Karsten's research uses <strong>hypergeometric probability</strong> to determine exactly how many mana sources of each color you need
                    to consistently cast your spells on curve.
                </p>
                <p style="margin-top: 0.5rem;">
                    For each colored mana symbol in your deck's casting costs, the calculator computes the optimal number of lands that produce that color.
                    It targets approximately a <strong>90% probability</strong> of having the right colors by the turn you need them.
                    Works for Standard, Modern, Pioneer, Legacy, and Commander mana bases &mdash; including 99-card singleton decks.
                    For a deeper look at manabase theory, read our <a href="/guides/mana-bases.html">complete mana base guide</a>.
                    Also see our <a href="/guides/dual-lands.html">dual land cycles reference</a> for every land cycle by format, and our <a href="/guides/commander-deck-building.html">Commander deck building guide</a> for EDH-specific mana base advice.
                </p>
            </div>

            <!-- FAQ Section (visible content for SEO + users) -->
            <section class="faq-section">
                <h2>Frequently Asked Questions</h2>

                <details open>
                    <summary>How many lands should I put in my MTG deck?</summary>
                    <p>For a 60-card deck (Standard, Modern, Pioneer), 23&ndash;26 lands is typical depending on your mana curve. Aggro decks run 22&ndash;23 lands, midrange runs 24&ndash;25, and control runs 25&ndash;26. For Commander (99 cards + commander), 35&ndash;38 lands is the standard range. Use a manabase calculator based on Frank Karsten&rsquo;s math for precise counts tailored to your specific deck.</p>
                </details>

                <details>
                    <summary>How many lands for a 60-card deck?</summary>
                    <p>Most competitive 60-card decks play between 22 and 26 lands. The exact number depends on your average mana value (mana curve). Low-curve aggro decks like Mono-Red or Burn can get away with 20&ndash;22 lands, especially if they run cheap cantrips. Midrange decks typically want 24 lands, while control and ramp strategies often play 25&ndash;27. Enter your mana curve into the calculator above for a personalized recommendation.</p>
                </details>

                <details>
                    <summary>How many lands for Commander / EDH?</summary>
                    <p>Commander decks (99 cards + commander) typically run 35&ndash;38 lands. The ratio is slightly different from 60-card formats because of the larger deck size and singleton restriction. Decks with a low mana curve and lots of mana rocks can go as low as 33, while 4+ color decks or landfall strategies may want 38&ndash;40. Don&rsquo;t forget to count mana-producing artifacts like Sol Ring and signets when planning your mana base.</p>
                </details>

                <details>
                    <summary>What is Frank Karsten's mana math?</summary>
                    <p>Frank Karsten&rsquo;s mana math is the gold standard for calculating MTG mana bases. Using hypergeometric probability, Karsten determined exactly how many colored sources you need to cast your spells on curve with approximately 90% consistency. For example, a card costing 1WW in a 60-card deck needs about 18 white sources. His research, published on ChannelFireball, is the foundation used by competitive players and this calculator.</p>
                </details>

                <details>
                    <summary>How many colored sources do I need?</summary>
                    <p>The number of colored sources depends on how many pips of that color appear in your casting costs and what turn you need them. Karsten&rsquo;s guidelines for a 60-card deck: a single colored pip on turn 1 needs ~14 sources, a single pip on turn 3 needs ~12, and double pips (like 1WW) need ~18 sources. This calculator does the math automatically &mdash; just input your colored mana symbols and it computes the sources needed per color.</p>
                </details>

                <details>
                    <summary>What is the 40% rule for lands?</summary>
                    <p>The &ldquo;40% rule&rdquo; is a rough guideline that suggests about 40% of your deck should be lands. For a 60-card deck that&rsquo;s 24 lands, and for a 40-card Limited deck that&rsquo;s 16&ndash;17 lands. While this rule of thumb works as a starting point, the actual number should depend on your mana curve. Aggressive decks with lots of 1&ndash;2 drops can go below 40%, while control decks may want to stay at or above it.</p>
                </details>

                <details>
                    <summary>How do dual lands affect my mana base?</summary>
                    <p>Dual lands (lands that produce two or more colors) are crucial for multicolor decks because each one counts as a source for every color it produces. A Hallowed Fountain counts as both a white source and a blue source, reducing the total lands you need. Premium duals like shock lands and fetch lands are the most efficient because they enter untapped or have basic land types. This calculator&rsquo;s land suggestions section recommends specific dual land cycles based on your format and colors. See our complete <a href="/tools/lands/">dual lands reference guide</a> for every cycle by format.</p>
                </details>

                <details>
                    <summary>How many lands for a 3-color Commander deck?</summary>
                    <p>A three-color Commander deck typically runs 36&ndash;38 lands, but the real challenge is the color distribution. Each color needs at least 14&ndash;16 sources to reliably cast single-pip spells by turn 3. With three colors, you need heavy investment in multicolor lands: fetch lands, shock lands, triomes, and check lands that produce two of your three colors. Budget options include pain lands, filter lands, and the battlebond lands. Use this calculator with the Commander preset to see exactly how many sources of each color your 3-color deck requires.</p>
                </details>

                <details>
                    <summary>What is the mana curve and why does it matter for lands?</summary>
                    <p>The mana curve is the distribution of mana values (casting costs) across your nonland cards. It directly determines how many lands you need: a deck full of 1&ndash;2 drops can function on 22 lands, while a deck with lots of 4&ndash;6 drops needs 25+. The ideal curve depends on your strategy &mdash; aggro decks want a low curve peaking at 1&ndash;2, midrange peaks at 2&ndash;3, and control wants a flatter distribution with powerful top-end. Enter your curve into this mana base calculator to see exactly how your land count should scale.</p>
                </details>

                <details>
                    <summary>How do I calculate mana for Limited / Draft decks?</summary>
                    <p>For 40-card Limited decks (Draft and Sealed), the standard is 17 lands. The color split depends on your deck&rsquo;s pip distribution. A mostly-red deck splashing white might run 10 Mountains and 7 Plains, while an even two-color deck wants about 9/8 or 8/9. Use the Limited format preset in this calculator, enter your colored pips from your drafted cards, and it computes the optimal basic land split. Remember that in Limited, you rarely have dual lands, so your mana base is mostly basics.</p>
                </details>

                <details>
                    <summary>How does this mana calculator differ from other MTG land calculators?</summary>
                    <p>Most MTG land calculators only tell you how many total lands to run. This calculator goes further by implementing Frank Karsten&rsquo;s <strong>hypergeometric probability model</strong> &mdash; the same math used by Pro Tour players. It calculates the exact number of <em>colored sources</em> per color, shows your probability of casting each spell on curve, and recommends specific dual land cycles for your format. It also includes a decklist import feature that auto-detects your mana pips via Scryfall, so you can paste a deck and get instant results.</p>
                </details>

                <details>
                    <summary>Should I count mana rocks as colored sources?</summary>
                    <p>Mana rocks like Sol Ring, Arcane Signet, and Signets contribute to your mana production but are not technically &ldquo;lands.&rdquo; In Commander, mana rocks are essential &mdash; most decks run 8&ndash;12 ramp pieces. A rock that produces your color counts as roughly 0.5&ndash;0.75 of a colored source because it can be removed and doesn&rsquo;t affect your opening hand land count. The safe approach: build your land base as if rocks don&rsquo;t exist, then add rocks on top as acceleration. This calculator focuses on lands specifically, since they&rsquo;re the foundation.</p>
                </details>
            </section>

            <!-- Related Tools -->
            <div class="info-box" style="margin-top:1.5rem;">
                <h3>&#128736; Related Mana Base Tools</h3>
                <p>
                    <strong><a href="/tools/lands/">Dual Lands Reference Guide</a></strong> &mdash; Browse every dual land cycle in Magic, filtered by color, speed, and format legality. See which lands are legal in Standard, Pioneer, Modern, and Commander.<br>
                    <strong><a href="/tools/commander-bracket/">Commander Bracket Calculator</a></strong> &mdash; Analyze your Commander deck&rsquo;s power level. Detects fast mana, tutors, combo pieces, and estimates your bracket rating.<br>
                    <strong><a href="/guides/commander-deck-building.html">Commander Deck Building Guide</a></strong> &mdash; Complete guide to building EDH decks, including mana base theory, color ratios, and ramp packages.<br>
                    <strong><a href="/tools/hypergeometric/">Hypergeometric Calculator</a></strong> &mdash; Raw probability calculator for any MTG scenario. Compute draw odds for any card or combination.<br>
                    <strong><a href="/draft/">Draft Simulator</a></strong> &mdash; Practice drafting against 7 AI opponents with real set cards. Build your deck and export to Arena.<br>
                    <strong><a href="/tools/sealed/">Sealed Pool Simulator</a></strong> &mdash; Open 6 virtual booster packs and build a 40-card sealed deck. Practice for prerelease events.
                </p>
            </div>
        </div>
    </main>

    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-logo">ScrollVault</div>
                <div class="wubrg-dots">
                    <span class="mana-dot" style="background: #F9FAF4"></span>
                    <span class="mana-dot" style="background: #0E68AB"></span>
                    <span class="mana-dot" style="background: #150B00; border: 1px solid rgba(255,255,255,0.2)"></span>
                    <span class="mana-dot" style="background: #D3202A"></span>
                    <span class="mana-dot" style="background: #00733E"></span>
                </div>
                <p class="footer-text">&copy; 2026 scrollvault.net. Magic: The Gathering is a trademark of Wizards of the Coast. Card images &copy; Wizards of the Coast via Scryfall.</p>
                <ul class="footer-links">
                    <li><a href="/privacy.html">Privacy Policy</a></li>
                    <li><a href="/terms.html">Terms of Service</a></li>
                    <li><a href="/contact.html">Contact</a></li>
                    <li><a href="/about/authors.html">Authors</a></li>
                    <li><a href="/about/editorial-policy.html">Editorial Policy</a></li>
                </ul>
            </div>
        </div>
    </footer>

<script>
/* ══════════════════════════════════════════
   Mana Base Calculator - ScrollVault
   ══════════════════════════════════════════ */

// ── State ──
const COLORS = ['W', 'U', 'B', 'R', 'G'];
const COLOR_NAMES = { W: 'White', U: 'Blue', B: 'Black', R: 'Red', G: 'Green' };
const COLOR_HEX = { W: '#F9FAF4', U: '#0E68AB', B: '#555', R: '#D3202A', G: '#00733E' };
const COLOR_TEXT = { W: '#333', U: '#fff', B: '#ccc', R: '#fff', G: '#fff' };
var COLOR_TO_BASIC_TYPE = { W:'Plains', U:'Island', B:'Swamp', R:'Mountain', G:'Forest' };
var BASIC_TYPE_TO_COLOR = { 'Plains':'W', 'Island':'U', 'Swamp':'B', 'Mountain':'R', 'Forest':'G' };

let state = {
    format: 'standard',
    deckSize: 60,
    totalLands: 24,
    activeColors: new Set(['W', 'U']),
    pips: { W: 12, U: 12, B: 0, R: 0, G: 0 },
    curve: [0, 8, 10, 8, 6, 3, 1, 0],
    mode: 'manual',       // 'manual' | 'imported'
    cards: null,           // [{name, qty, mv, pips, isLand, producesColors}]
    simResults: null       // from worker
};

// Simulation worker
var simWorker = null;
var simWorkerFailed = false;
var simEngine = 'js'; // 'wasm' or 'js'

// ── Comprehensive Dual Land Database ──
// Each cycle: name, short description, tier (1=premium, 2=good, 3=budget), cards per color pair
const LAND_CYCLES = {
    // --- STANDARD-LEGAL ---
    shockLands: { name: 'Shock Lands', desc: 'Pay 2 life or ETB tapped. Fetchable (has basic land types).', tier: 1,
        meta: { etb:'choice', conditionType:null, lifeCost:2, coloredUseCost:0, fetchable:true, isFetch:false, mdfc:false },
        cards: {
        WU:'Hallowed Fountain', WB:'Godless Shrine', WR:'Sacred Foundry', WG:'Temple Garden',
        UB:'Watery Grave', UR:'Steam Vents', UG:'Breeding Pool', BR:'Blood Crypt', BG:'Overgrown Tomb', RG:'Stomping Ground' }},
    surveilLands: { name: 'Surveil Lands', desc: 'ETB tapped. Surveil 1. Fetchable (has basic land types).', tier: 1,
        meta: { etb:'tapped', conditionType:null, lifeCost:0, coloredUseCost:0, fetchable:true, isFetch:false, mdfc:false },
        cards: {
        WU:'Meticulous Archive', WB:'Shadowy Backstreet', WR:'Elegant Parlor', WG:'Lush Portico',
        UB:'Undercity Sewers', UR:'Thundering Falls', UG:'Hedge Maze', BR:'Raucous Theater', BG:'Underground Mortuary', RG:'Commercial District' }},
    fastLandsEnemy: { name: 'Fast Lands (Enemy)', desc: 'ETB untapped if you control 2 or fewer lands.', tier: 1,
        meta: { etb:'conditional', conditionType:'fast', lifeCost:0, coloredUseCost:0, fetchable:false, isFetch:false, mdfc:false },
        cards: {
        WB:'Concealed Courtyard', UR:'Spirebluff Canal', BG:'Blooming Marsh', WR:'Inspiring Vantage', UG:'Botanical Sanctum' }},
    vergeLands: { name: 'Verge Lands', desc: 'ETB untapped. Second color requires matching basic land type.', tier: 1,
        meta: { etb:'untapped', conditionType:null, lifeCost:0, coloredUseCost:0, fetchable:false, isFetch:false, mdfc:false },
        cards: {
        WU:'Floodfarm Verge', UB:'Gloomlake Verge', BR:'Blazemire Verge', RG:'Thornspire Verge', WG:'Hushwood Verge',
        WB:'Bleachbone Verge', UR:'Riverpyre Verge', BG:'Wastewood Verge', WR:'Sunbillow Verge', UG:'Willowrush Verge' }},
    hauntLands: { name: 'Haunt Lands', desc: 'ETB tapped unless a player has 13 or less life.', tier: 2,
        meta: { etb:'conditional', conditionType:'haunt', lifeCost:0, coloredUseCost:0, fetchable:false, isFetch:false, mdfc:false },
        cards: {
        WU:'Abandoned Campground', UB:'Murky Sewer', BR:'Razortrap Gorge', RG:'Bleeding Woods', WG:'Etched Cornfield',
        WB:'Neglected Manor', UR:'Peculiar Lighthouse', BG:'Strangled Cemetery', WR:'Raucous Carnival', UG:'Lakeside Shack' }},
    restlessLands: { name: 'Restless Creature Lands', desc: 'ETB tapped. Can animate into a creature.', tier: 2,
        meta: { etb:'tapped', conditionType:null, lifeCost:0, coloredUseCost:0, fetchable:false, isFetch:false, mdfc:false },
        cards: {
        WU:'Restless Anchorage', WB:'Restless Fortress', WR:'Restless Bivouac', WG:'Restless Prairie',
        UB:'Restless Reef', UR:'Restless Spire', UG:'Restless Vinestalk', BR:'Restless Vents', BG:'Restless Cottage', RG:'Restless Ridgeline' }},
    scryTemples: { name: 'Scry Temples', desc: 'ETB tapped. Scry 1.', tier: 3,
        meta: { etb:'tapped', conditionType:null, lifeCost:0, coloredUseCost:0, fetchable:false, isFetch:false, mdfc:false },
        cards: {
        WU:'Temple of Enlightenment', WB:'Temple of Silence', WR:'Temple of Triumph', WG:'Temple of Plenty',
        UB:'Temple of Deceit', UR:'Temple of Epiphany', UG:'Temple of Mystery', BR:'Temple of Malice', BG:'Temple of Malady', RG:'Temple of Abandon' }},
    gainLands: { name: 'Gain Lands', desc: 'ETB tapped. Gain 1 life.', tier: 3,
        meta: { etb:'tapped', conditionType:null, lifeCost:0, coloredUseCost:0, fetchable:false, isFetch:false, mdfc:false },
        cards: {
        WU:'Tranquil Cove', WB:'Scoured Barrens', WR:'Wind-Scarred Crag', WG:'Blossoming Sands',
        UB:'Dismal Backwater', UR:'Swiftwater Cliffs', UG:'Thornwood Falls', BR:'Bloodfell Caves', BG:'Jungle Hollow', RG:'Rugged Highlands' }},
    guildgates: { name: 'Guildgates', desc: 'ETB tapped. Gate subtype.', tier: 3,
        meta: { etb:'tapped', conditionType:null, lifeCost:0, coloredUseCost:0, fetchable:false, isFetch:false, mdfc:false },
        cards: {
        WU:'Azorius Guildgate', WB:'Orzhov Guildgate', WR:'Boros Guildgate', WG:'Selesnya Guildgate',
        UB:'Dimir Guildgate', UR:'Izzet Guildgate', UG:'Simic Guildgate', BR:'Rakdos Guildgate', BG:'Golgari Guildgate', RG:'Gruul Guildgate' }},

    // --- PIONEER-ONLY (not in current Standard) ---
    checkLands: { name: 'Check Lands', desc: 'ETB untapped if you control a matching basic land type.', tier: 1,
        meta: { etb:'conditional', conditionType:'check', lifeCost:0, coloredUseCost:0, fetchable:false, isFetch:false, mdfc:false },
        cards: {
        WU:'Glacial Fortress', WB:'Isolated Chapel', WR:'Clifftop Retreat', WG:'Sunpetal Grove',
        UB:'Drowned Catacomb', UR:'Sulfur Falls', UG:'Hinterland Harbor', BR:'Dragonskull Summit', BG:'Woodland Cemetery', RG:'Rootbound Crag' }},
    pathwayLands: { name: 'Pathway Lands', desc: 'MDFC. Choose a side (untapped, one color once played).', tier: 2,
        meta: { etb:'untapped', conditionType:null, lifeCost:0, coloredUseCost:0, fetchable:false, isFetch:false, mdfc:true },
        cards: {
        WU:'Hengegate Pathway', WB:'Brightclimb Pathway', WR:'Needleverge Pathway', WG:'Branchloft Pathway',
        UB:'Clearwater Pathway', UR:'Riverglide Pathway', UG:'Barkchannel Pathway', BR:'Blightstep Pathway', BG:'Darkbore Pathway', RG:'Cragcrown Pathway' }},
    slowLands: { name: 'Slow Lands', desc: 'ETB untapped if you control 2+ other lands.', tier: 1,
        meta: { etb:'conditional', conditionType:'slow', lifeCost:0, coloredUseCost:0, fetchable:false, isFetch:false, mdfc:false },
        cards: {
        WU:'Deserted Beach', WB:'Shattered Sanctum', WR:'Sundown Pass', WG:'Overgrown Farmland',
        UB:'Shipwreck Marsh', UR:'Stormcarved Coast', UG:'Dreamroot Cascade', BR:'Haunted Ridge', BG:'Deathcap Glade', RG:'Rockfall Vale' }},
    painLands: { name: 'Pain Lands', desc: 'ETB untapped. 1 damage for colored mana, free colorless.', tier: 1,
        meta: { etb:'untapped', conditionType:null, lifeCost:0, coloredUseCost:1, fetchable:false, isFetch:false, mdfc:false },
        cards: {
        WU:'Adarkar Wastes', WB:'Caves of Koilos', WR:'Battlefield Forge', WG:'Brushland',
        UB:'Underground River', UR:'Shivan Reef', UG:'Yavimaya Coast', BR:'Sulfurous Springs', BG:'Llanowar Wastes', RG:'Karplusan Forest' }},
    revealLands: { name: 'Reveal Lands', desc: 'ETB untapped if you reveal a matching basic from hand.', tier: 2,
        meta: { etb:'conditional', conditionType:'reveal', lifeCost:0, coloredUseCost:0, fetchable:false, isFetch:false, mdfc:false },
        cards: {
        WU:'Port Town', WB:'Shineshadow Snarl', WR:'Furycalm Snarl', WG:'Fortified Village',
        UB:'Choked Estuary', UR:'Frostboil Snarl', UG:'Vineglimmer Snarl', BR:'Foreboding Ruins', BG:'Necroblossom Snarl', RG:'Game Trail' }},

    // --- MODERN-ONLY ---
    fetchLands: { name: 'Fetch Lands', desc: 'Pay 1 life, sac: search for a land with basic land type.', tier: 1,
        meta: { etb:'untapped', conditionType:null, lifeCost:1, coloredUseCost:0, fetchable:false, isFetch:true, mdfc:false },
        cards: {
        WU:'Flooded Strand', WB:'Marsh Flats', WR:'Arid Mesa', WG:'Windswept Heath',
        UB:'Polluted Delta', UR:'Scalding Tarn', UG:'Misty Rainforest', BR:'Bloodstained Mire', BG:'Verdant Catacombs', RG:'Wooded Foothills' }},
    fastLands: { name: 'Fast Lands', desc: 'ETB untapped if you control 2 or fewer lands.', tier: 1,
        meta: { etb:'conditional', conditionType:'fast', lifeCost:0, coloredUseCost:0, fetchable:false, isFetch:false, mdfc:false },
        cards: {
        WU:'Seachrome Coast', WB:'Concealed Courtyard', WR:'Inspiring Vantage', WG:'Razorverge Thicket',
        UB:'Darkslick Shores', UR:'Spirebluff Canal', UG:'Botanical Sanctum', BR:'Blackcleave Cliffs', BG:'Blooming Marsh', RG:'Copperline Gorge' }},
    horizonLands: { name: 'Horizon Lands', desc: 'Tap for color (1 dmg). Sac + pay 1 life: draw a card.', tier: 1,
        meta: { etb:'untapped', conditionType:null, lifeCost:0, coloredUseCost:1, fetchable:false, isFetch:false, mdfc:false },
        cards: {
        WB:'Silent Clearing', WG:'Horizon Canopy', WR:'Sunbaked Canyon', UR:'Fiery Islet', UG:'Waterlogged Grove', BG:'Nurturing Peatland' }},
    filterLands: { name: 'Filter Lands', desc: 'Tap for colorless. Or pay {1} color to get 2 mana in combo.', tier: 2,
        meta: { etb:'untapped', conditionType:null, lifeCost:0, coloredUseCost:0, fetchable:false, isFetch:false, mdfc:false },
        cards: {
        WU:'Mystic Gate', WB:'Fetid Heath', WR:'Rugged Prairie', WG:'Wooded Bastion',
        UB:'Sunken Ruins', UR:'Cascade Bluffs', UG:'Flooded Grove', BR:'Graven Cairns', BG:'Twilight Mire', RG:'Fire-Lit Thicket' }},

    // --- LEGACY-ONLY ---
    originalDuals: { name: 'Original Dual Lands', desc: 'No drawback. Two basic land types. Reserved List.', tier: 1,
        meta: { etb:'untapped', conditionType:null, lifeCost:0, coloredUseCost:0, fetchable:true, isFetch:false, mdfc:false },
        cards: {
        WU:'Tundra', WB:'Scrubland', WR:'Plateau', WG:'Savannah',
        UB:'Underground Sea', UR:'Volcanic Island', UG:'Tropical Island', BR:'Badlands', BG:'Bayou', RG:'Taiga' }},

    // --- COMMANDER ---
    bondLands: { name: 'Bond Lands', desc: 'ETB untapped if you have 2+ opponents.', tier: 1,
        meta: { etb:'conditional', conditionType:'bond', lifeCost:0, coloredUseCost:0, fetchable:false, isFetch:false, mdfc:false },
        cards: {
        WU:'Sea of Clouds', WB:'Vault of Champions', WR:'Spectator Seating', WG:'Bountiful Promenade',
        UB:'Morphic Pool', UR:'Training Center', UG:'Rejuvenating Springs', BR:'Luxury Suite', BG:'Undergrowth Stadium', RG:'Spire Garden' }}
};

// Flexible "any-color" lands — not dual lands, choose 1 color per game
// For deckbuilding source math: counts as a source for ALL your colors
var FLEXIBLE_LANDS = {
    multiversalPassage: {
        name: 'Multiversal Passage',
        desc: 'Choose a basic land type. Pay 2 life or ETB tapped. Fetchable (gains chosen basic type).',
        tier: 1,
        maxCopies: 4,
        condition: null,
        meta: { etb:'choice', conditionType:null, lifeCost:2, coloredUseCost:0, fetchable:true, isFetch:false, mdfc:false }
    },
    startingTown: {
        name: 'Starting Town',
        desc: 'Any color. ETB untapped turns 1-3, tapped afterwards. 1 life for colored mana.',
        tier: 1,
        maxCopies: 4,
        condition: 'turnGated',
        meta: { etb:'conditional', conditionType:'startingTown', lifeCost:0, coloredUseCost:1, fetchable:false, isFetch:false, mdfc:false }
    },
    plazaOfHeroes: {
        name: 'Plaza of Heroes',
        desc: 'Any color for legendary spells. Untapped, no life cost. Hexproof ability.',
        tier: 1,
        maxCopies: 4,
        condition: 'legendary',
        meta: { etb:'untapped', conditionType:null, lifeCost:0, coloredUseCost:0, fetchable:false, isFetch:false, mdfc:false }
    },
    cavernOfSouls: {
        name: 'Cavern of Souls',
        desc: 'Any color for chosen creature type. Untapped. Makes creatures uncounterable.',
        tier: 1,
        maxCopies: 4,
        condition: 'tribal',
        meta: { etb:'untapped', conditionType:null, lifeCost:0, coloredUseCost:0, fetchable:false, isFetch:false, mdfc:false }
    },
    secludedCourtyard: {
        name: 'Secluded Courtyard',
        desc: 'Any color for chosen creature type spells and abilities. Untapped.',
        tier: 1,
        maxCopies: 4,
        condition: 'tribal',
        meta: { etb:'untapped', conditionType:null, lifeCost:0, coloredUseCost:0, fetchable:false, isFetch:false, mdfc:false }
    },
    unclaimedTerritory: {
        name: 'Unclaimed Territory',
        desc: 'Any color for chosen creature type spells only. Untapped.',
        tier: 2,
        maxCopies: 4,
        condition: 'tribal',
        meta: { etb:'untapped', conditionType:null, lifeCost:0, coloredUseCost:0, fetchable:false, isFetch:false, mdfc:false }
    },
    cityOfBrass: {
        name: 'City of Brass',
        desc: 'Any color. Deals 1 damage to you when tapped.',
        tier: 1,
        maxCopies: 4,
        condition: null,
        meta: { etb:'untapped', conditionType:null, lifeCost:0, coloredUseCost:1, fetchable:false, isFetch:false, mdfc:false }
    },
    manaConfluence: {
        name: 'Mana Confluence',
        desc: 'Any color. Pay 1 life to tap for color.',
        tier: 1,
        maxCopies: 4,
        condition: null,
        meta: { etb:'untapped', conditionType:null, lifeCost:0, coloredUseCost:1, fetchable:false, isFetch:false, mdfc:false }
    },
    reflectingPool: {
        name: 'Reflecting Pool',
        desc: 'Any color your other lands could produce. Untapped, no cost.',
        tier: 1,
        maxCopies: 4,
        condition: null,
        meta: { etb:'untapped', conditionType:null, lifeCost:0, coloredUseCost:0, fetchable:false, isFetch:false, mdfc:false }
    },
    commandTower: {
        name: 'Command Tower',
        desc: 'Any color in your commander\'s color identity. Untapped, no cost.',
        tier: 1,
        maxCopies: 4,
        condition: 'commander',
        meta: { etb:'untapped', conditionType:null, lifeCost:0, coloredUseCost:0, fetchable:false, isFetch:false, mdfc:false }
    },
    exoticOrchard: {
        name: 'Exotic Orchard',
        desc: 'Any color an opponent\'s land could produce. Untapped.',
        tier: 1,
        maxCopies: 4,
        condition: 'commander',
        meta: { etb:'untapped', conditionType:null, lifeCost:0, coloredUseCost:0, fetchable:false, isFetch:false, mdfc:false }
    },
    pathOfAncestry: {
        name: 'Path of Ancestry',
        desc: 'Any color. ETB tapped. Scry 1 when casting commander\'s type.',
        tier: 2,
        maxCopies: 4,
        condition: 'commander',
        meta: { etb:'tapped', conditionType:null, lifeCost:0, coloredUseCost:0, fetchable:false, isFetch:false, mdfc:false }
    },
    spireOfIndustry: {
        name: 'Spire of Industry',
        desc: 'Any color if you control an artifact. Pay 1 life. Untapped.',
        tier: 1,
        maxCopies: 4,
        condition: 'artifact',
        meta: { etb:'untapped', conditionType:null, lifeCost:0, coloredUseCost:1, fetchable:false, isFetch:false, mdfc:false }
    },
    ancientZiggurat: {
        name: 'Ancient Ziggurat',
        desc: 'Any color for creature spells only. Untapped, no cost.',
        tier: 1,
        maxCopies: 4,
        condition: 'creatureSpell',
        meta: { etb:'untapped', conditionType:null, lifeCost:0, coloredUseCost:0, fetchable:false, isFetch:false, mdfc:false }
    },
    pillarOfTheParuns: {
        name: 'Pillar of the Paruns',
        desc: 'Any color for multicolor spells only. Untapped, no cost.',
        tier: 1,
        maxCopies: 4,
        condition: 'multicolor',
        meta: { etb:'untapped', conditionType:null, lifeCost:0, coloredUseCost:0, fetchable:false, isFetch:false, mdfc:false }
    }
};

// Which flexible lands are available per format
var FLEXIBLE_LAND_FORMATS = {
    standard:  ['multiversalPassage','startingTown','cavernOfSouls','secludedCourtyard'],
    pioneer:   ['multiversalPassage','startingTown','manaConfluence','plazaOfHeroes','cavernOfSouls','secludedCourtyard','unclaimedTerritory','spireOfIndustry'],
    modern:    ['multiversalPassage','startingTown','cityOfBrass','manaConfluence','reflectingPool','plazaOfHeroes','cavernOfSouls','secludedCourtyard','unclaimedTerritory','spireOfIndustry','ancientZiggurat','pillarOfTheParuns'],
    legacy:    ['multiversalPassage','startingTown','cityOfBrass','manaConfluence','reflectingPool','plazaOfHeroes','cavernOfSouls','secludedCourtyard','unclaimedTerritory','spireOfIndustry','ancientZiggurat','pillarOfTheParuns'],
    commander: ['multiversalPassage','startingTown','cityOfBrass','manaConfluence','reflectingPool','commandTower','exoticOrchard','pathOfAncestry','plazaOfHeroes','cavernOfSouls','secludedCourtyard','unclaimedTerritory','spireOfIndustry','ancientZiggurat','pillarOfTheParuns'],
    limited:   [],
    custom:    []
};

// Utility lands for mono-color and colorless slots (Commander only)
var UTILITY_LANDS = {
    W: [
        { name: 'Castle Ardenvale', desc: 'Creates 1/1 tokens', category: 'token', condition: 'creature', tier: 1 },
        { name: 'Eiganjo, Seat of the Empire', desc: 'Channel: removal spell', category: 'removal', condition: null, tier: 1 },
        { name: 'Emeria, the Sky Ruin', desc: 'Recur creatures from graveyard', category: 'recursion', condition: 'creature', tier: 2 },
        { name: 'Windbrisk Heights', desc: 'Hideaway — free spell on attack', category: 'advantage', condition: 'creature', tier: 2 },
        { name: 'Nykthos, Shrine to Nyx', desc: 'Massive mana from devotion', category: 'ramp', condition: null, tier: 1 },
        { name: "Hall of Heliod's Generosity", desc: 'Recur enchantment to top of library', category: 'recursion', condition: 'enchantment', tier: 1 },
        { name: "Serra's Sanctum", desc: 'Tap for W equal to enchantments you control', category: 'ramp', condition: 'enchantment', tier: 1 },
        { name: 'Kor Haven', desc: 'Prevent all combat damage from target creature', category: 'utility', condition: null, tier: 2 }
    ],
    U: [
        { name: 'Castle Vantress', desc: 'Scry 2 at instant speed', category: 'selection', condition: null, tier: 1 },
        { name: 'Otawara, Soaring City', desc: 'Channel: bounce permanent', category: 'removal', condition: null, tier: 1 },
        { name: 'Mystic Sanctuary', desc: 'Recur instant/sorcery to top', category: 'recursion', condition: null, tier: 1 },
        { name: 'Tolaria West', desc: 'Transmute for any 0-cost card', category: 'tutor', condition: null, tier: 2 },
        { name: 'Nykthos, Shrine to Nyx', desc: 'Massive mana from devotion', category: 'ramp', condition: null, tier: 2 },
        { name: 'Academy Ruins', desc: 'Recur artifact to top of library', category: 'recursion', condition: 'artifact', tier: 1 },
        { name: 'Minamo, School at Water\'s Edge', desc: 'Untap target legendary permanent', category: 'utility', condition: 'legendary', tier: 2 }
    ],
    B: [
        { name: 'Castle Locthwain', desc: 'Draw a card (pay life)', category: 'draw', condition: null, tier: 1 },
        { name: 'Takenuma, Abandoned Mire', desc: 'Channel: recur creature or planeswalker', category: 'recursion', condition: null, tier: 1 },
        { name: 'Urborg, Tomb of Yawgmoth', desc: 'All lands tap for black', category: 'fixing', condition: null, tier: 1 },
        { name: 'Phyrexian Tower', desc: 'Sacrifice creature for 2 black mana', category: 'ramp', condition: 'creature', tier: 1 },
        { name: 'Cabal Coffers', desc: 'Massive mana with Swamps', category: 'ramp', condition: null, tier: 1 },
        { name: 'Nykthos, Shrine to Nyx', desc: 'Massive mana from devotion', category: 'ramp', condition: null, tier: 2 },
        { name: 'Bojuka Bog', desc: 'ETB: exile target player\'s graveyard', category: 'removal', condition: null, tier: 1 },
        { name: "Volrath's Stronghold", desc: 'Recur creature to top of library', category: 'recursion', condition: 'creature', tier: 1 },
        { name: "Shizo, Death's Storehouse", desc: 'Legendary creature gains fear', category: 'evasion', condition: 'legendary', tier: 1 }
    ],
    R: [
        { name: 'Castle Embereth', desc: 'Pump all creatures +1/+0', category: 'pump', condition: 'creature', tier: 1 },
        { name: 'Sokenzan, Crucible of Defiance', desc: 'Channel: create haste tokens', category: 'token', condition: null, tier: 1 },
        { name: 'Valakut, the Molten Pinnacle', desc: 'Burn with 5+ Mountains', category: 'damage', condition: null, tier: 2 },
        { name: 'War Room', desc: 'Draw a card (pay life = colors)', category: 'draw', condition: null, tier: 1 },
        { name: 'Nykthos, Shrine to Nyx', desc: 'Massive mana from devotion', category: 'ramp', condition: null, tier: 1 },
        { name: 'Arena of Glory', desc: 'Creature gains haste', category: 'utility', condition: null, tier: 1 },
        { name: 'Hanweir Battlements', desc: 'Give target creature haste', category: 'utility', condition: 'creature', tier: 2 }
    ],
    G: [
        { name: 'Castle Garenbrig', desc: 'Add 6 green for creatures', category: 'ramp', condition: 'creature', tier: 1 },
        { name: 'Boseiju, Who Endures', desc: 'Channel: destroy artifact/enchantment/nonbasic', category: 'removal', condition: null, tier: 1 },
        { name: 'Yavimaya, Cradle of Growth', desc: 'All lands tap for green', category: 'fixing', condition: null, tier: 1 },
        { name: "Gaea's Cradle", desc: 'Tap for mana equal to creatures', category: 'ramp', condition: 'creature', tier: 1 },
        { name: 'Nykthos, Shrine to Nyx', desc: 'Massive mana from devotion', category: 'ramp', condition: null, tier: 1 },
        { name: 'Yavimaya Hollow', desc: 'Regenerate target creature', category: 'utility', condition: 'creature', tier: 1 },
        { name: 'Shifting Woodland', desc: 'Delirium: copy permanent in your graveyard', category: 'utility', condition: null, tier: 2 },
        { name: 'Mosswort Bridge', desc: 'Hideaway: free spell with 10+ creature power', category: 'advantage', condition: 'creature', tier: 2 }
    ],
    C: [
        { name: 'War Room', desc: 'Draw a card (pay life = colors)', category: 'draw', condition: 'fewColors', tier: 1 },
        { name: "Rogue's Passage", desc: 'Make creature unblockable', category: 'evasion', condition: 'creature', tier: 2 },
        { name: 'Myriad Landscape', desc: 'Fetch two basics (tapped)', category: 'ramp', condition: null, tier: 2 },
        { name: 'Reliquary Tower', desc: 'No maximum hand size', category: 'utility', condition: null, tier: 2 },
        { name: 'Strip Mine', desc: 'Destroy any land', category: 'removal', condition: null, tier: 1 },
        { name: 'Ancient Tomb', desc: 'Add 2 colorless (2 life)', category: 'ramp', condition: null, tier: 1 },
        { name: 'Buried Ruin', desc: 'Recur artifact from graveyard', category: 'recursion', condition: 'artifact', tier: 2 },
        { name: 'Treasure Vault', desc: 'Create Treasure tokens', category: 'ramp', condition: 'artifact', tier: 2 },
        { name: "Inventors' Fair", desc: 'Tutor for artifact (3+ artifacts)', category: 'tutor', condition: 'artifact', tier: 2 },
        { name: 'Blast Zone', desc: 'Scalable board wipe for nonlands', category: 'removal', condition: null, tier: 2 },
        { name: 'Command Beacon', desc: 'Put commander from command zone to hand', category: 'utility', condition: null, tier: 1 },
        { name: "Urza's Saga", desc: 'Tutor artifact with MV 0-1 to battlefield', category: 'tutor', condition: 'artifact', tier: 1 },
        { name: 'Wasteland', desc: 'Destroy target nonbasic land', category: 'removal', condition: null, tier: 1 },
        { name: 'Maze of Ith', desc: 'Prevent all combat damage to/from target creature', category: 'utility', condition: null, tier: 1 },
        { name: 'Homeward Path', desc: 'Each player gains control of creatures they own', category: 'utility', condition: 'creature', tier: 2 },
        { name: 'Emergence Zone', desc: 'Sacrifice: cast spells as though they had flash', category: 'utility', condition: null, tier: 2 },
        { name: 'Field of the Dead', desc: 'Create 2/2 Zombie when land ETBs (7+ diff. lands)', category: 'token', condition: null, tier: 2 },
        { name: 'Scavenger Grounds', desc: 'Exile each player\'s graveyard', category: 'removal', condition: null, tier: 2 },
        { name: 'High Market', desc: 'Sacrifice creature: gain 1 life', category: 'utility', condition: 'creature', tier: 2 },
        { name: "Karn's Bastion", desc: 'Proliferate', category: 'utility', condition: null, tier: 2 },
        { name: "Thespian's Stage", desc: 'Copy any land on battlefield', category: 'ramp', condition: null, tier: 2 },
        { name: 'Tyrite Sanctum', desc: '+1/+1 counter or indestructible for legendary', category: 'pump', condition: 'legendary', tier: 2 }
    ],
    WB: [
        { name: 'Vault of the Archangel', desc: 'Creatures gain deathtouch + lifelink', category: 'pump', condition: 'creature', tier: 1 }
    ],
    WG: [
        { name: 'Gavony Township', desc: '+1/+1 counter on each creature you control', category: 'pump', condition: 'creature', tier: 1 }
    ],
    RG: [
        { name: 'Kessig Wolf Run', desc: 'Trample and +X/+0 to creature', category: 'pump', condition: 'creature', tier: 1 }
    ],
    UG: [
        { name: "Alchemist's Refuge", desc: 'Cast spells as though they had flash', category: 'utility', condition: null, tier: 2 }
    ],
    RW: [
        { name: "Slayers' Stronghold", desc: '+2/+0, vigilance, and haste', category: 'pump', condition: 'creature', tier: 2 },
        { name: 'Sunhome, Fortress of the Legion', desc: 'Creature gains double strike', category: 'pump', condition: 'creature', tier: 2 }
    ]
};

// Build utility land name lookup for deduplication
var UTILITY_LAND_NAMES = {};
(function() {
    for (var color in UTILITY_LANDS) {
        for (var i = 0; i < UTILITY_LANDS[color].length; i++) {
            UTILITY_LAND_NAMES[UTILITY_LANDS[color][i].name.toLowerCase()] = true;
        }
    }
})();

// Build reverse lookup: card name (lowercase) -> { cycleKey, pair }
var LAND_NAME_TO_CYCLE = {};
(function() {
    for (var key in LAND_CYCLES) {
        var cycle = LAND_CYCLES[key];
        for (var pair in cycle.cards) {
            LAND_NAME_TO_CYCLE[cycle.cards[pair].toLowerCase()] = { cycleKey: key, pair: pair };
        }
    }
})();
for (var _fk in FLEXIBLE_LANDS) {
    LAND_NAME_TO_CYCLE[FLEXIBLE_LANDS[_fk].name.toLowerCase()] = { cycleKey: '_flex_' + _fk, pair: 'ALL', isFlex: true };
}

// Which cycles are available in each format, in priority order (best first)
const FORMAT_CYCLE_KEYS = {
    standard: ['shockLands','fastLandsEnemy','vergeLands','surveilLands','hauntLands','restlessLands','scryTemples','gainLands','guildgates'],
    pioneer:  ['shockLands','fastLandsEnemy','painLands','checkLands','slowLands','vergeLands','surveilLands','pathwayLands','revealLands','hauntLands','restlessLands','scryTemples'],
    modern:   ['fetchLands','shockLands','fastLands','horizonLands','painLands','checkLands','filterLands','slowLands','surveilLands','pathwayLands','restlessLands','scryTemples'],
    legacy:   ['fetchLands','originalDuals','shockLands','fastLands','horizonLands','painLands','checkLands','filterLands','slowLands','surveilLands'],
    limited:  ['gainLands','guildgates','scryTemples'],
    commander:['shockLands','fetchLands','bondLands','painLands','checkLands','fastLands','slowLands','filterLands','surveilLands','restlessLands','scryTemples'],
    custom:   ['shockLands','fastLands','painLands','checkLands']
};

// ══════════════════════════════════════════
// Hypergeometric Probability (logChoose)
// ══════════════════════════════════════════

function logFactorial(n) {
    // Stirling's approximation for large n, exact for small n
    if (n < 0) return 0;
    if (n <= 1) return 0;
    if (n < 20) {
        let result = 0;
        for (let i = 2; i <= n; i++) result += Math.log(i);
        return result;
    }
    // Stirling's approximation
    return n * Math.log(n) - n + 0.5 * Math.log(2 * Math.PI * n) + 1/(12*n) - 1/(360*n*n*n);
}

function logChoose(n, k) {
    if (k < 0 || k > n) return -Infinity;
    if (k === 0 || k === n) return 0;
    return logFactorial(n) - logFactorial(k) - logFactorial(n - k);
}

function hypergeometricPMF(x, N, K, n) {
    // P(X = x) where:
    // N = population size (deck size)
    // K = successes in population (colored sources)
    // n = draws (cards drawn by turn)
    // x = successes in draws (colored sources drawn)
    if (x < 0 || x > Math.min(K, n) || x < Math.max(0, n - (N - K))) return 0;
    var logP = logChoose(K, x) + logChoose(N - K, n - x) - logChoose(N, n);
    return Math.exp(logP);
}

function hypergeometricCDF_atLeast(k, N, K, n) {
    // P(X >= k): probability of drawing at least k successes
    if (k <= 0) return 1;
    if (k > Math.min(K, n)) return 0;
    // Sum P(X = i) for i from k to min(K, n)
    var maxX = Math.min(K, n);
    var sum = 0;
    for (var i = k; i <= maxX; i++) {
        sum += hypergeometricPMF(i, N, K, n);
    }
    return Math.min(1, Math.max(0, sum));
}

// ══════════════════════════════════════════
// Karsten's land recommendation
// ══════════════════════════════════════════

// Real Karsten table: key = "pips-turn", value = sources needed in 60-card deck at 90% confidence
// From Frank Karsten's ChannelFireball research
var KARSTEN_TABLE = {
    '1-1':14, '1-2':13, '1-3':12, '1-4':10, '1-5':9, '1-6':9,
    '2-2':20, '2-3':18, '2-4':16, '2-5':15, '2-6':13,
    '3-3':23, '3-4':21, '3-5':19, '3-6':17,
    '4-4':24, '4-5':22, '4-6':20
};

function karstenLookup(pips, turn) {
    // Look up sources needed for `pips` colored pips at `turn` in 60-card deck
    if (pips <= 0) return 0;
    var clampedPips = Math.min(pips, 4);
    var clampedTurn = Math.max(clampedPips, Math.min(turn, 6));
    var key = clampedPips + '-' + clampedTurn;
    return KARSTEN_TABLE[key] || Math.min(14 + (clampedPips - 1) * 4, 24);
}

function findMostDemandingCard(color, cards) {
    // Find the card with the most pips of this color at the lowest MV
    // Returns {pips, turn} or null
    var best = null;
    if (!cards) return null;
    for (var i = 0; i < cards.length; i++) {
        var card = cards[i];
        if (card.isLand) continue;
        var colorPips = card.pips[color] || 0;
        if (colorPips <= 0) continue;
        var turn = card.mv;
        if (turn < 1) turn = 1;
        // More demanding = more pips or same pips at lower turn
        if (!best || colorPips > best.pips || (colorPips === best.pips && turn < best.turn)) {
            best = { pips: colorPips, turn: turn };
        }
    }
    return best;
}

function analyzeDeckContext(cards) {
    var result = {
        legendaryDensity: 0, tribalDensity: 0, dominantType: null,
        creatureCount: 0, totalSpells: 0, typeCounts: {},
        artifactDensity: 0, creatureSpellDensity: 0, multicolorDensity: 0,
        enchantmentDensity: 0, instantSorceryDensity: 0,
        // Ramp analysis fields
        rampCount: 0, cheapRampCount: 0, fastManaCount: 0,
        rampByType: { dork: 0, rock: 0, landRamp: 0, fast: 0, fastOneShot: 0, treasure: 0, etbMana: 0, extraLand: 0 },
        rampSources: { W: 0, U: 0, B: 0, R: 0, G: 0 },
        rampDetails: [],  // [{rampType, mv, weight, colors, qty}]
        cheapDrawCount: 0
    };
    if (!cards || cards.length === 0) return result;

    var totalSpells = 0;
    var legendarySpells = 0;
    var creatureCount = 0;
    var artifactCount = 0;
    var multicolorCount = 0;
    var enchantmentCount = 0;
    var instantSorceryCount = 0;
    var typeCounts = {};

    // Karsten weight coefficients per ramp type
    // fast = repeatable MV0 mana (Mana Crypt, Mox Diamond)
    // fastOneShot = single-use MV0 or exile-from-hand (Lotus Petal, Simian Spirit Guide)
    // dork = repeatable creature tap (Birds of Paradise, Llanowar Elves)
    // rock = repeatable artifact tap (Sol Ring, Arcane Signet)
    // landRamp = puts land onto battlefield (Cultivate, Rampant Growth)
    // treasure = creates Treasure tokens (Smothering Tithe, Dockside Extortionist)
    // etbMana = one-shot ETB mana creature (Burning-Tree Emissary, Priest of Gix)
    // extraLand = additional land drops (Exploration, Azusa)
    var RAMP_WEIGHTS = {
        fast: 1.0, fastOneShot: 0.4, dork: 0.5, rock: 0.75,
        landRamp: 0.75, treasure: 0.25, etbMana: 0.1, extraLand: 0.5
    };

    for (var i = 0; i < cards.length; i++) {
        var card = cards[i];
        if (card.isLand) continue;
        totalSpells += card.qty;
        if (card.isLegendary) legendarySpells += card.qty;
        if (card.isArtifact) artifactCount += card.qty;
        if (card.isMulticolor) multicolorCount += card.qty;
        if (card.isEnchantment) enchantmentCount += card.qty;
        if (card.isInstantSorcery) instantSorceryCount += card.qty;
        if (card.creatureTypes && card.creatureTypes.length > 0) {
            creatureCount += card.qty;
            for (var t = 0; t < card.creatureTypes.length; t++) {
                var ct = card.creatureTypes[t];
                typeCounts[ct] = (typeCounts[ct] || 0) + card.qty;
            }
        }

        // Ramp aggregation
        if (card.rampType) {
            result.rampCount += card.qty;
            result.rampByType[card.rampType] = (result.rampByType[card.rampType] || 0) + card.qty;
            if (card.mv <= 2) result.cheapRampCount += card.qty;
            if (card.rampType === 'fast') result.fastManaCount += card.qty;

            var weight = RAMP_WEIGHTS[card.rampType] || 0;
            var rampColors = card.rampColors || [];
            var isAny = rampColors.indexOf('any') >= 0;

            result.rampDetails.push({ rampType: card.rampType, mv: card.mv, weight: weight, colors: rampColors, qty: card.qty });

            // Accumulate weighted source contributions per color
            COLORS.forEach(function(col) {
                if (isAny || rampColors.indexOf(col) >= 0) {
                    result.rampSources[col] += weight * card.qty;
                }
            });
        }

        // Cheap card draw detection (MV <= 2, non-land, non-ramp, draws cards)
        if (!card.rampType && card.mv <= 2 && card.mv > 0) {
            // We need oracle text, but we only have pips/name in perCardData
            // Mark as cheap draw based on name heuristics stored during import
            if (card.isCheapDraw) {
                result.cheapDrawCount += card.qty;
            }
        }
    }

    result.totalSpells = totalSpells;
    result.creatureCount = creatureCount;
    result.typeCounts = typeCounts;

    if (totalSpells > 0) {
        result.legendaryDensity = legendarySpells / totalSpells;
        result.artifactDensity = artifactCount / totalSpells;
        result.creatureSpellDensity = creatureCount / totalSpells;
        result.multicolorDensity = multicolorCount / totalSpells;
        result.enchantmentDensity = enchantmentCount / totalSpells;
        result.instantSorceryDensity = instantSorceryCount / totalSpells;
    }

    // Find dominant creature type
    var bestType = null, bestCount = 0;
    for (var type in typeCounts) {
        if (typeCounts[type] > bestCount) {
            bestCount = typeCounts[type];
            bestType = type;
        }
    }
    result.dominantType = bestType;
    if (creatureCount > 0) {
        result.tribalDensity = bestCount / creatureCount;
    }

    return result;
}

function computeBasicMattersFloor(cards, activeColors) {
    var result = { totalBasicFloor: 0, perColorFloor: {} };
    COLORS.forEach(function(c) { result.perColorFloor[c] = 0; });
    if (!cards || cards.length === 0) return result;

    // Cards that want a high total basic count
    var totalBasicCards = {
        'land tax': 8,
        'weathered wayfarer': 5,
        'oath of lieges': 6,
        'keeper of the accord': 6,
        "archaeomancer's map": 6,
        'tithe': 5,
        'gift of estates': 5,
        'burnished hart': 4
    };
    // Cards that want basics of a specific color
    var perColorCards = {
        'emeria, the sky ruin': { color: 'W', floor: 7 },
        'emeria shepherd': { color: 'W', floor: 7 },
        'knight of the white orchid': { color: 'W', floor: 5 },
        'cabal coffers': { color: 'B', floor: 6 },
        'cabal stronghold': { color: 'B', floor: 5 },
        'crypt ghast': { color: 'B', floor: 5 },
        'nirkana revenant': { color: 'B', floor: 5 },
        'valakut, the molten pinnacle': { color: 'R', floor: 6 },
        'dread presence': { color: 'B', floor: 5 },
        'nissa, who shakes the world': { color: 'G', floor: 5 }
    };

    for (var i = 0; i < cards.length; i++) {
        var name = cards[i].name.toLowerCase();
        if (totalBasicCards[name] !== undefined) {
            result.totalBasicFloor = Math.max(result.totalBasicFloor, totalBasicCards[name]);
        }
        if (perColorCards[name] !== undefined) {
            var entry = perColorCards[name];
            if (activeColors.indexOf(entry.color) >= 0) {
                result.perColorFloor[entry.color] = Math.max(result.perColorFloor[entry.color], entry.floor);
            }
        }
    }
    return result;
}

function flexLandEffectiveness(flexKey, deckContext) {
    var flex = FLEXIBLE_LANDS[flexKey];
    if (!flex) return 1.0;
    var condition = flex.condition || null;
    if (!condition || condition === 'turnGated') return 1.0;
    if (condition === 'commander') return (deckContext.isCommander) ? 1.0 : 0.0;
    if (condition === 'legendary') return deckContext.legendaryDensity || 0;
    if (condition === 'tribal') {
        var matchingCreatures = (deckContext.creatureCount || 0) * (deckContext.tribalDensity || 0);
        return matchingCreatures / Math.max(1, deckContext.totalSpells || 1);
    }
    if (condition === 'artifact') return deckContext.artifactDensity || 0;
    if (condition === 'creatureSpell') return deckContext.creatureSpellDensity || 0;
    if (condition === 'multicolor') return deckContext.multicolorDensity || 0;
    return 1.0;
}

// Recommend specific utility lands for Commander decks
// Returns array of { name, desc, category, score } sorted by score descending
function recommendUtilityLands(activeList, slots, deckContext, tempoProfile) {
    if (slots <= 0 || state.format !== 'commander') return [];

    var archetype = tempoProfile ? tempoProfile.archetype : 'midrange';
    var isMono = activeList.length === 1;

    // Collect candidates from color-specific + colorless pools
    var candidates = [];
    var seen = {};

    // Color-specific lands
    for (var i = 0; i < activeList.length; i++) {
        var colorLands = UTILITY_LANDS[activeList[i]];
        if (!colorLands) continue;
        for (var j = 0; j < colorLands.length; j++) {
            var land = colorLands[j];
            var key = land.name.toLowerCase();
            if (seen[key]) continue;
            seen[key] = true;
            candidates.push({ name: land.name, desc: land.desc, category: land.category, condition: land.condition, tier: land.tier, colorSpecific: true });
        }
    }

    // Colorless utility lands
    var colorlessLands = UTILITY_LANDS.C || [];
    for (var k = 0; k < colorlessLands.length; k++) {
        var cl = colorlessLands[k];
        var clKey = cl.name.toLowerCase();
        if (seen[clKey]) continue;
        seen[clKey] = true;
        candidates.push({ name: cl.name, desc: cl.desc, category: cl.category, condition: cl.condition, tier: cl.tier, colorSpecific: false });
    }

    // Multicolor utility lands — only if both colors in pair are active
    for (var a = 0; a < activeList.length; a++) {
        for (var b = a + 1; b < activeList.length; b++) {
            [activeList[a] + activeList[b], activeList[b] + activeList[a]].forEach(function(pk) {
                var pairLands = UTILITY_LANDS[pk];
                if (!pairLands) return;
                for (var p = 0; p < pairLands.length; p++) {
                    var pl = pairLands[p];
                    var plKey = pl.name.toLowerCase();
                    if (seen[plKey]) continue;
                    seen[plKey] = true;
                    candidates.push({ name: pl.name, desc: pl.desc, category: pl.category, condition: pl.condition, tier: pl.tier, colorSpecific: true });
                }
            });
        }
    }

    // Filter out cards already in imported decklist
    if (state.mode === 'imported' && state.cards) {
        var importedNames = {};
        for (var m = 0; m < state.cards.length; m++) {
            importedNames[state.cards[m].name.toLowerCase()] = true;
        }
        candidates = candidates.filter(function(c) { return !importedNames[c.name.toLowerCase()]; });
    }

    // Score each candidate
    var creatureDensity = deckContext.creatureSpellDensity || 0;
    var artifactDensity = deckContext.artifactDensity || 0;

    candidates.forEach(function(c) {
        var score = 0;

        // Base score from tier (tier 1 = 10, tier 2 = 6, tier 3 = 3)
        score += c.tier === 1 ? 10 : (c.tier === 2 ? 6 : 3);

        // Mono-color bonus for color-specific lands
        if (isMono && c.colorSpecific) score += 3;

        // Condition bonuses
        if (c.condition === 'creature' && creatureDensity > 0.3) score += 4;
        if (c.condition === 'creature' && creatureDensity > 0.5) score += 2;
        if (c.condition === 'artifact' && artifactDensity > 0.2) score += 4;
        if (c.condition === 'artifact' && artifactDensity > 0.4) score += 2;
        if (c.condition === 'fewColors' && isMono) score += 3;
        if (c.condition === 'enchantment' && (deckContext.enchantmentDensity || 0) > 0.2) score += 4;
        if (c.condition === 'enchantment' && (deckContext.enchantmentDensity || 0) > 0.4) score += 2;
        if (c.condition === 'legendary' && (deckContext.legendaryDensity || 0) > 0.15) score += 4;
        if (c.condition === 'legendary' && (deckContext.legendaryDensity || 0) > 0.35) score += 2;

        // Archetype match
        if (archetype === 'aggro') {
            if (c.category === 'pump' || c.category === 'evasion' || c.category === 'damage' || c.category === 'token') score += 3;
            if (c.category === 'ramp') score -= 1;
        } else if (archetype === 'control') {
            if (c.category === 'draw' || c.category === 'selection' || c.category === 'recursion' || c.category === 'removal') score += 3;
            if (c.category === 'pump') score -= 1;
        } else {
            // Midrange likes a bit of everything
            if (c.category === 'ramp' || c.category === 'draw' || c.category === 'removal') score += 2;
        }

        // Spellslinger bonus
        if ((deckContext.instantSorceryDensity || 0) > 0.4) {
            if (c.category === 'selection' || c.category === 'recursion' || c.category === 'draw') score += 2;
        }
        // Enchantress bonus
        if ((deckContext.enchantmentDensity || 0) > 0.3) {
            if (c.condition === 'enchantment') score += 3;
        }

        c.score = score;
    });

    // Sort by score descending, then tier ascending for ties
    candidates.sort(function(a, b) {
        if (b.score !== a.score) return b.score - a.score;
        return a.tier - b.tier;
    });

    return candidates.slice(0, slots);
}

function recommendedSources(color, deckSize, totalLands, cards) {
    // Per-card Karsten method: find the most demanding card for this color
    var demand = findMostDemandingCard(color, cards);
    if (!demand) {
        // Fallback for manual mode: estimate from aggregate pips
        return recommendedSourcesFromPips(state.pips[color], deckSize, totalLands);
    }
    var base60 = karstenLookup(demand.pips, demand.turn);
    // Scale for non-60-card decks
    var scaleFactor = deckSize / 60;
    return Math.max(1, Math.round(base60 * scaleFactor));
}

function recommendedSourcesFromPips(totalPips, deckSize, totalLands) {
    // Fallback for manual mode: estimate from aggregate pip count
    // Use heuristic: map total pips to an approximate "most demanding" requirement
    if (totalPips <= 0) return 0;
    var totalSpells = state.curve.reduce(function(a, b) { return a + b; }, 0);
    if (totalSpells === 0) return Math.max(1, Math.round(totalPips * 0.7));

    // Estimate: average pips per spell with this color, and earliest turn needed
    var avgPipsPerSpell = totalPips / totalSpells;
    var estMaxPips = Math.min(4, Math.ceil(avgPipsPerSpell * 2));
    // Find earliest MV with spells
    var earliestTurn = 7;
    for (var mv = 1; mv <= 7; mv++) {
        if (state.curve[mv] > 0) { earliestTurn = mv; break; }
    }
    var base60 = karstenLookup(Math.max(1, estMaxPips), earliestTurn);
    var scaleFactor = deckSize / 60;
    return Math.max(1, Math.round(base60 * scaleFactor));
}

// ══════════════════════════════════════════
// UI Initialization
// ══════════════════════════════════════════

// Tier-priority ordering: premium first, budget last
var TIER_ORDER = [
  'fetchLands','originalDuals','shockLands','fastLands','fastLandsEnemy',
  'horizonLands','bondLands','painLands','checkLands','slowLands',
  'vergeLands','filterLands','surveilLands','pathwayLands','revealLands',
  'hauntLands','restlessLands','scryTemples','gainLands','guildgates',
  'desertLands','avatarLands','spiderManLands','finalFantasyLands'
];

function rebuildLandNameLookup() {
    LAND_NAME_TO_CYCLE = {};
    for (var key in LAND_CYCLES) {
        var cycle = LAND_CYCLES[key];
        for (var pair in cycle.cards) {
            LAND_NAME_TO_CYCLE[cycle.cards[pair].toLowerCase()] = { cycleKey: key, pair: pair };
        }
    }
    for (var fk in FLEXIBLE_LANDS) {
        LAND_NAME_TO_CYCLE[FLEXIBLE_LANDS[fk].name.toLowerCase()] = { cycleKey: '_flex_' + fk, pair: 'ALL', isFlex: true };
    }
}

function loadLandDatabase() {
  fetch('/data/land-database.json')
    .then(function(r) { return r.ok ? r.json() : Promise.reject(); })
    .then(function(data) {
      if (!data) return;

      // Update tier order if provided
      if (data.tierOrder && data.tierOrder.length > 0) {
        TIER_ORDER = data.tierOrder;
      }

      // Update/add cycle definitions and collect legality
      if (data.cycles) {
        for (var cycleKey in data.cycles) {
          var src = data.cycles[cycleKey];
          if (!LAND_CYCLES[cycleKey]) {
            // New cycle discovered — add it
            LAND_CYCLES[cycleKey] = {
              name: src.name, desc: src.desc, tier: src.tier,
              meta: src.meta, cards: src.cards
            };
          } else {
            // Existing cycle — update cards and metadata
            var existing = LAND_CYCLES[cycleKey];
            if (src.name) existing.name = src.name;
            if (src.desc) existing.desc = src.desc;
            if (src.tier !== undefined) existing.tier = src.tier;
            if (src.meta) existing.meta = src.meta;
            if (src.cards) {
              for (var pair in src.cards) {
                existing.cards[pair] = src.cards[pair];
              }
            }
          }
        }
      }

      // Update/add flexible land definitions
      if (data.flexibleLands) {
        for (var flexKey in data.flexibleLands) {
          var fsrc = data.flexibleLands[flexKey];
          FLEXIBLE_LANDS[flexKey] = {
            name: fsrc.name, desc: fsrc.desc, tier: fsrc.tier,
            maxCopies: fsrc.maxCopies || 4, condition: fsrc.condition || null, meta: fsrc.meta
          };
        }
      }

      // Rebuild reverse lookup with any new cards
      rebuildLandNameLookup();

      // Rebuild FORMAT_CYCLE_KEYS from legality data
      var fmts = ['standard','pioneer','modern','legacy','commander'];
      for (var f = 0; f < fmts.length; f++) {
        var fmt = fmts[f];
        var keys = [];
        for (var t = 0; t < TIER_ORDER.length; t++) {
          var k = TIER_ORDER[t];
          var legal = data.cycles && data.cycles[k] && data.cycles[k].legality;
          if (LAND_CYCLES[k] && legal && legal[fmt]) {
            keys.push(k);
          }
        }
        // Also check for cycles in TIER_ORDER that aren't in the JSON but exist in LAND_CYCLES
        // (backward compat with hardcoded data)
        if (keys.length > 0) FORMAT_CYCLE_KEYS[fmt] = keys;
      }

      // Rebuild FLEXIBLE_LAND_FORMATS from legality data
      for (var ff = 0; ff < fmts.length; ff++) {
        FLEXIBLE_LAND_FORMATS[fmts[ff]] = [];
      }
      var flexSource = data.flexibleLands || {};
      for (var fk2 in flexSource) {
        var fLegal = flexSource[fk2].legality;
        if (!fLegal) continue;
        for (var ff2 = 0; ff2 < fmts.length; ff2++) {
          if (fLegal[fmts[ff2]]) {
            FLEXIBLE_LAND_FORMATS[fmts[ff2]].push(fk2);
          }
        }
      }
    })
    .catch(function() {}); // Keep hardcoded fallback on network error
}

function init() {
    initWorker();
    setupFormatButtons();
    setupColorToggles();
    renderPipInputs();
    setupCurveListeners();
    updateCurveTotal();
    loadLandDatabase();
}

function setupFormatButtons() {
    var btns = document.querySelectorAll('.format-btn');
    btns.forEach(function(btn) {
        btn.addEventListener('click', function() {
            btns.forEach(function(b) { b.classList.remove('active'); });
            btn.classList.add('active');
            state.format = btn.dataset.format;
            if (btn.dataset.format !== 'custom') {
                var ds = parseInt(btn.dataset.deck);
                var tl = parseInt(btn.dataset.lands);
                state.deckSize = ds;
                state.totalLands = tl;
                document.getElementById('deckSize').value = ds;
                document.getElementById('totalLands').value = tl;
                updateCurveTotal();
            }
        });
    });
}

function setupColorToggles() {
    var toggles = document.querySelectorAll('.color-toggle');
    toggles.forEach(function(t) {
        t.addEventListener('click', function() {
            var c = t.dataset.color;
            if (state.activeColors.has(c)) {
                state.activeColors.delete(c);
                t.classList.remove('active');
            } else {
                state.activeColors.add(c);
                t.classList.add('active');
            }
            renderPipInputs();
        });
    });
}

function renderPipInputs() {
    var section = document.getElementById('pipSection');
    section.innerHTML = '';
    if (state.activeColors.size === 0) {
        section.innerHTML = '<p style="color:var(--text-muted);font-size:0.85rem;text-align:center;padding:1rem 0;">Select at least one color above.</p>';
        return;
    }
    COLORS.forEach(function(c) {
        if (!state.activeColors.has(c)) {
            state.pips[c] = 0;
            return;
        }
        var row = document.createElement('div');
        row.className = 'pip-row';

        var dot = document.createElement('div');
        dot.className = 'pip-color-dot';
        dot.style.background = COLOR_HEX[c];
        if (c === 'B') dot.style.border = '1px solid rgba(255,255,255,0.2)';
        dot.style.color = COLOR_TEXT[c];
        dot.textContent = c;

        var label = document.createElement('div');
        label.className = 'pip-label';
        label.textContent = COLOR_NAMES[c] + ' pips';

        var controls = document.createElement('div');
        controls.className = 'pip-controls';

        var minBtn = document.createElement('button');
        minBtn.className = 'pip-btn';
        minBtn.textContent = '-';
        minBtn.setAttribute('data-color', c);
        minBtn.setAttribute('data-dir', '-1');
        minBtn.addEventListener('click', function() { adjustPip(c, -1); });

        var val = document.createElement('input');
        val.className = 'pip-value';
        val.type = 'number';
        val.min = '0';
        val.max = '99';
        val.value = state.pips[c];
        val.id = 'pip-' + c;
        val.addEventListener('change', function() {
            state.pips[c] = Math.max(0, parseInt(val.value) || 0);
        });

        var plusBtn = document.createElement('button');
        plusBtn.className = 'pip-btn';
        plusBtn.textContent = '+';
        plusBtn.addEventListener('click', function() { adjustPip(c, 1); });

        controls.appendChild(minBtn);
        controls.appendChild(val);
        controls.appendChild(plusBtn);

        row.appendChild(dot);
        row.appendChild(label);
        row.appendChild(controls);
        section.appendChild(row);
    });
}

function adjustPip(color, delta) {
    var input = document.getElementById('pip-' + color);
    var val = Math.max(0, (parseInt(input.value) || 0) + delta);
    input.value = val;
    state.pips[color] = val;
}

function setupCurveListeners() {
    var inputs = document.querySelectorAll('#curveInputs input');
    inputs.forEach(function(inp) {
        inp.addEventListener('input', function() {
            var mv = parseInt(inp.dataset.mv);
            state.curve[mv] = Math.max(0, parseInt(inp.value) || 0);
            updateCurveTotal();
        });
    });

    document.getElementById('deckSize').addEventListener('input', function() {
        state.deckSize = Math.max(20, parseInt(this.value) || 60);
        // Switch to custom format
        selectCustomFormat();
        updateCurveTotal();
    });

    document.getElementById('totalLands').addEventListener('input', function() {
        state.totalLands = Math.max(0, parseInt(this.value) || 0);
        selectCustomFormat();
        updateCurveTotal();
    });
}

function selectCustomFormat() {
    var btns = document.querySelectorAll('.format-btn');
    var isPreset = false;
    btns.forEach(function(b) {
        if (b.dataset.format !== 'custom' && parseInt(b.dataset.deck) === state.deckSize && parseInt(b.dataset.lands) === state.totalLands) {
            isPreset = true;
        }
    });
    if (!isPreset) {
        btns.forEach(function(b) { b.classList.remove('active'); });
        document.querySelector('.format-btn[data-format="custom"]').classList.add('active');
        state.format = 'custom';
    }
}

function updateCurveTotal() {
    var spells = state.curve.reduce(function(a, b) { return a + b; }, 0);
    var total = spells + state.totalLands;
    var el = document.getElementById('curveTotal');
    var mismatch = total !== state.deckSize;
    el.innerHTML = 'Spells: <strong>' + spells + '</strong> / Lands: <strong>' + state.totalLands + '</strong> / Total: <strong' + (mismatch ? ' style="color:#f87171"' : '') + '>' + total + '</strong>' + (mismatch ? ' <span style="color:#f87171;font-size:0.75rem;">(expected ' + state.deckSize + ')</span>' : '');
}

// ══════════════════════════════════════════
// Tempo Profile & Smart Land Optimizer
// ══════════════════════════════════════════

function computeTempoProfile() {
    var curve = state.curve;
    var totalSpells = 0, weightedMV = 0;
    var oneDropCount = 0, twoDropCount = 0;

    if (state.mode === 'imported' && state.cards) {
        state.cards.forEach(function(card) {
            if (card.isLand) return;
            totalSpells += card.qty;
            weightedMV += card.mv * card.qty;
            if (card.mv === 1) oneDropCount += card.qty;
            if (card.mv === 2) twoDropCount += card.qty;
        });
    } else {
        for (var mv = 0; mv <= 7; mv++) {
            var count = curve[mv] || 0;
            totalSpells += count;
            weightedMV += mv * count;
            if (mv === 1) oneDropCount = count;
            if (mv === 2) twoDropCount = count;
        }
    }

    var avgMV = totalSpells > 0 ? weightedMV / totalSpells : 2.5;

    // tempoSensitivity: 0.0 (control) to 1.0 (hyper-aggro)
    var tempoSensitivity = Math.max(0, Math.min(1, (3.5 - avgMV) / 2.0));

    var archetype;
    if (avgMV < 2.2) archetype = 'aggro';
    else if (avgMV <= 3.2) archetype = 'midrange';
    else archetype = 'control';

    // Turn weights: how important is untapped mana on each turn?
    var turnWeights;
    if (archetype === 'aggro') {
        turnWeights = [0, 0.30, 0.30, 0.20, 0.10, 0.05, 0.05];
    } else if (archetype === 'midrange') {
        turnWeights = [0, 0.10, 0.20, 0.30, 0.20, 0.10, 0.10];
    } else {
        turnWeights = [0, 0.05, 0.10, 0.20, 0.25, 0.20, 0.20];
    }

    return {
        avgMV: avgMV,
        oneDropCount: oneDropCount,
        twoDropCount: twoDropCount,
        tempoSensitivity: tempoSensitivity,
        archetype: archetype,
        turnWeights: turnWeights,
        totalSpells: totalSpells
    };
}

function untappedProbability(meta, turn, deckContext) {
    if (!meta) return 0.5;
    var etb = meta.etb;
    if (etb === 'untapped') return 1.0;
    if (etb === 'tapped') return 0.0;
    if (etb === 'choice') return 1.0; // player pays life
    if (etb !== 'conditional') return 0.5;

    var ct = meta.conditionType;
    if (ct === 'startingTown') return turn <= 3 ? 1.0 : 0.0;
    if (ct === 'fast') return turn <= 3 ? 1.0 : 0.0;
    if (ct === 'slow') return turn <= 2 ? 0.0 : 1.0;
    if (ct === 'bond') return deckContext.isCommander ? 1.0 : 0.0;
    if (ct === 'haunt') {
        // ~10% turns 1-2, ~30% turn 3, ~50% turn 4+
        if (turn <= 2) return 0.1;
        if (turn === 3) return 0.3;
        return 0.5;
    }
    if (ct === 'check') {
        // P(matching basic in play) ~ hypergeometric approximation
        // Approximate: with B basics in N cards, drawing turn+6 cards, P(>=1 basic in play by turn T) ~ 1-(1-B/N)^(T+6)
        var basicCount = deckContext.totalBasics || Math.round(state.totalLands * 0.4);
        var deckN = state.deckSize;
        var cardsSeenByTurn = Math.min(turn + 6, deckN);
        // But we need a basic in play, not just drawn. If it's turn T, we've played T-1 lands before this one.
        // Approximate: P(at least 1 matching basic among T-1 land drops from ~T+5 cards seen)
        var pNoBasic = 1;
        for (var i = 0; i < Math.min(turn + 5, deckN); i++) {
            pNoBasic *= (deckN - basicCount - i) / (deckN - i);
            if (pNoBasic < 0) { pNoBasic = 0; break; }
        }
        return Math.max(0, Math.min(1, 1 - pNoBasic));
    }
    if (ct === 'reveal') {
        // P(matching basic in hand) ~ similar to check but in hand specifically
        var basicCount2 = deckContext.totalBasics || Math.round(state.totalLands * 0.4);
        var handSize = Math.min(turn + 6, state.deckSize);
        var pNoReveal = 1;
        for (var j = 0; j < handSize; j++) {
            pNoReveal *= (state.deckSize - basicCount2 - j) / (state.deckSize - j);
            if (pNoReveal < 0) { pNoReveal = 0; break; }
        }
        return Math.max(0, Math.min(1, 1 - pNoReveal));
    }
    return 0.5;
}

function scoreLand(cycleKey, pair, deckContext, tempoProfile, currentAllocation) {
    var cycle = LAND_CYCLES[cycleKey];
    if (!cycle) return -999;
    var meta = cycle.meta;
    var score = 0;

    var c1 = pair[0], c2 = pair[1];
    var colorContrib = meta.mdfc ? 0.5 : 1.0;

    // 1. Color Contribution (0-40 pts) — weighted by source deficiency
    var maxDeficiency = Math.max.apply(null, Object.values(deckContext.needed).map(function(n, i) {
        var col = Object.keys(deckContext.needed)[i];
        return Math.max(0, n - (currentAllocation.sources[col] || 0));
    }));
    if (maxDeficiency <= 0) maxDeficiency = 1;

    if (meta.isFetch) {
        // Fetch lands: score based on effective colors (what they can actually find)
        var activeList = Object.keys(deckContext.needed);
        var effColors = computeFetchEffectiveColors(pair, activeList, currentAllocation);
        var fetchColorScore = 0;
        for (var ec = 0; ec < effColors.length; ec++) {
            var def = Math.max(0, (deckContext.needed[effColors[ec]] || 0) - (currentAllocation.sources[effColors[ec]] || 0));
            fetchColorScore += (def / maxDeficiency) * 20;
        }
        score += Math.min(40, fetchColorScore);
        // Small penalty if fetch only produces 1 or 0 effective colors
        if (effColors.length < 2) score -= 3;
        // On-color bonus: prefer fetches where both printed colors are active
        var onColorCount = 0;
        for (var oc = 0; oc < activeList.length; oc++) {
            if (pair[0] === activeList[oc] || pair[1] === activeList[oc]) onColorCount++;
        }
        if (onColorCount >= 2) score += 3; // Both colors active → more reliable targets
    } else {
        var deficiency1 = Math.max(0, (deckContext.needed[c1] || 0) - (currentAllocation.sources[c1] || 0));
        var deficiency2 = Math.max(0, (deckContext.needed[c2] || 0) - (currentAllocation.sources[c2] || 0));
        score += (deficiency1 / maxDeficiency) * 20 * colorContrib;
        score += (deficiency2 / maxDeficiency) * 20 * colorContrib;
    }

    // 2. Tempo Score (0-30 pts)
    var tempoScore = 0;
    for (var t = 1; t <= 6; t++) {
        var prob = untappedProbability(meta, t, deckContext);
        tempoScore += prob * (tempoProfile.turnWeights[t] || 0);
    }
    score += tempoScore * 30;

    // 3. Life Cost Penalty (0 to -10 pts)
    var lifePenalty = meta.lifeCost * tempoProfile.tempoSensitivity * 2;
    lifePenalty += meta.coloredUseCost * 3 * tempoProfile.tempoSensitivity;
    score -= Math.min(10, lifePenalty);

    // 4. Fetch Synergy Bonus (0-15 pts)
    if (meta.fetchable && currentAllocation.fetchCount > 0) {
        score += Math.min(15, currentAllocation.fetchCount * 2.5);
    }
    if (meta.isFetch) {
        // Count only targets THIS specific fetch can find (matching basic land types)
        var fetchType1 = COLOR_TO_BASIC_TYPE[pair[0]];
        var fetchType2 = COLOR_TO_BASIC_TYPE[pair[1]];
        var reachableTargets = 0;
        COLORS.forEach(function(c) {
            var bType = COLOR_TO_BASIC_TYPE[c];
            if ((bType === fetchType1 || bType === fetchType2) && (currentAllocation.basics[c] || 0) > 0) {
                reachableTargets += currentAllocation.basics[c];
            }
        });
        if (currentAllocation.duals) {
            for (var di = 0; di < currentAllocation.duals.length; di++) {
                var dd = currentAllocation.duals[di];
                if (dd.isFlex || !dd.meta || !dd.meta.fetchable) continue;
                var dType1 = COLOR_TO_BASIC_TYPE[dd.pair[0]];
                var dType2 = COLOR_TO_BASIC_TYPE[dd.pair[1]];
                if (fetchType1 === dType1 || fetchType1 === dType2 ||
                    fetchType2 === dType1 || fetchType2 === dType2) {
                    reachableTargets += dd.qty;
                }
            }
        }
        score += Math.min(15, reachableTargets * 1.5);
    }

    // 5. Utility Bonus (0-5 pts)
    if (cycleKey === 'horizonLands') score += 4; // card draw
    if (cycleKey === 'restlessLands') score += 3; // creature land
    if (cycleKey === 'surveilLands') score += 2; // surveil
    if (cycleKey === 'scryTemples') score += 1.5; // scry

    // 6. Diminishing Returns (-0 to -8 pts) — penalty for 3rd+ copy of same cycle
    if (meta.isFetch) {
        // Per-pair: standard diminishing returns (3rd+ copy of same specific fetch)
        var fetchPairCount = 0;
        for (var fp = 0; fp < currentAllocation.duals.length; fp++) {
            if (currentAllocation.duals[fp].cycleKey === cycleKey && currentAllocation.duals[fp].pair === pair) {
                fetchPairCount = currentAllocation.duals[fp].qty;
                break;
            }
        }
        if (fetchPairCount >= 3) score -= (fetchPairCount - 2) * 4;
        else if (fetchPairCount >= 2) score -= 1;
        // Aggregate: mild penalty to cap total fetch density (~8-10 max)
        var totalFetches = currentAllocation.fetchCount || 0;
        if (totalFetches >= 4) score -= (totalFetches - 3) * 1.5;
    } else {
        var cycleCount = currentAllocation.cycleCounts[cycleKey] || 0;
        if (cycleCount >= 3) score -= (cycleCount - 2) * 4;
        else if (cycleCount >= 2) score -= 1;
    }

    return score;
}

function scoreFlexibleLand(flexKey, deckContext, tempoProfile, currentAllocation, activeList) {
    var flex = FLEXIBLE_LANDS[flexKey];
    if (!flex) return -999;
    var meta = flex.meta;
    var score = 0;

    // Effectiveness multiplier for conditional lands
    // Minimum 15% threshold — below that, the land is too situational to justify a slot
    var effectiveness = flexLandEffectiveness(flexKey, deckContext);
    if (effectiveness < 0.15) return -999;

    // 1. Color Contribution — helps ALL active colors, scaled by effectiveness
    var maxDeficiency = 0;
    activeList.forEach(function(c) {
        var def = Math.max(0, (deckContext.needed[c] || 0) - (currentAllocation.sources[c] || 0));
        if (def > maxDeficiency) maxDeficiency = def;
    });
    if (maxDeficiency <= 0) maxDeficiency = 1;

    var colorScore = 0;
    activeList.forEach(function(c) {
        var def = Math.max(0, (deckContext.needed[c] || 0) - (currentAllocation.sources[c] || 0));
        colorScore += (def / maxDeficiency) * 20;
    });
    score += Math.min(40, colorScore) * effectiveness;

    // 2. Tempo Score
    var tempoScore = 0;
    for (var t = 1; t <= 6; t++) {
        var prob = untappedProbability(meta, t, deckContext);
        tempoScore += prob * (tempoProfile.turnWeights[t] || 0);
    }
    score += tempoScore * 30;

    // 3. Life Cost Penalty
    var lifePenalty = meta.lifeCost * tempoProfile.tempoSensitivity * 2;
    lifePenalty += meta.coloredUseCost * 3 * tempoProfile.tempoSensitivity;
    score -= Math.min(10, lifePenalty);

    // 4. Fetch Synergy (it's fetchable)
    if (meta.fetchable && currentAllocation.fetchCount > 0) {
        score += Math.min(15, currentAllocation.fetchCount * 2.5);
    }

    // 5. Diminishing Returns
    var copies = currentAllocation.flexCopies ? (currentAllocation.flexCopies[flexKey] || 0) : 0;
    if (copies >= 3) score -= (copies - 2) * 4;
    else if (copies >= 2) score -= 1;

    // 6. Slight penalty vs true dual lands — can only produce 1 color per game
    score -= 2;

    // 7. Cavern of Souls bonus for uncounterable (scaled by effectiveness)
    if (flexKey === 'cavernOfSouls') score += 5 * effectiveness;

    return score;
}

function optimizeManaBase(activeList, recommended, cachedDeckAnalysis) {
    var tempoProfile = computeTempoProfile();
    var formatKey = state.format;
    var cycleKeys = FORMAT_CYCLE_KEYS[formatKey] || FORMAT_CYCLE_KEYS['custom'];
    var isCommander = (formatKey === 'commander');
    var copiesPerCycle = isCommander ? 1 : (formatKey === 'limited' ? 1 : 4);

    // Per-color source targets
    var needed = {};
    activeList.forEach(function(c) { needed[c] = recommended[c]; });

    // Analyze deck composition for conditional lands (reuse cached if available)
    var deckAnalysis = cachedDeckAnalysis || ((state.mode === 'imported' && state.cards) ? analyzeDeckContext(state.cards) : analyzeDeckContext(null));

    // Deck context for scoring
    var deckContext = {
        needed: needed,
        isCommander: isCommander,
        totalBasics: 0,
        legendaryDensity: deckAnalysis.legendaryDensity,
        tribalDensity: deckAnalysis.tribalDensity,
        dominantType: deckAnalysis.dominantType,
        creatureCount: deckAnalysis.creatureCount,
        totalSpells: deckAnalysis.totalSpells,
        artifactDensity: deckAnalysis.artifactDensity,
        creatureSpellDensity: deckAnalysis.creatureSpellDensity,
        multicolorDensity: deckAnalysis.multicolorDensity
    };

    // Minimum basics per color
    var minBasicsPerColor = isCommander ? 2 : 1;

    // Basic-matters floor: cards like Land Tax, Emeria, Cabal Coffers need more basics
    var basicMatters = (state.mode === 'imported' && state.cards)
        ? computeBasicMattersFloor(state.cards, activeList)
        : { totalBasicFloor: 0, perColorFloor: {} };

    // Initialize allocation state
    var allocation = {
        duals: [],        // [{cycleKey, pair, name, qty, meta}]
        basics: {},       // {W:4, U:3, ...}
        sources: {},      // current source count per color
        fetchCount: 0,
        fetchableCount: 0,
        cycleCounts: {},  // cycleKey -> total copies allocated
        totalDuals: 0
    };
    activeList.forEach(function(c) {
        allocation.basics[c] = Math.max(minBasicsPerColor, basicMatters.perColorFloor[c] || 0);
        allocation.sources[c] = allocation.basics[c];
    });

    // If totalBasicFloor exceeds sum of per-color basics, distribute extra to most-needed colors
    var reservedBasicsTotal = 0;
    activeList.forEach(function(c) { reservedBasicsTotal += allocation.basics[c]; });
    if (basicMatters.totalBasicFloor > reservedBasicsTotal) {
        var extraBasics = basicMatters.totalBasicFloor - reservedBasicsTotal;
        for (var eb = 0; eb < extraBasics; eb++) {
            var worstC = null, worstDef = -Infinity;
            activeList.forEach(function(c) {
                var deficit = (needed[c] || 0) - (allocation.sources[c] || 0);
                if (deficit > worstDef) { worstDef = deficit; worstC = c; }
            });
            if (worstC) {
                allocation.basics[worstC]++;
                allocation.sources[worstC]++;
                reservedBasicsTotal++;
            }
        }
    }
    deckContext.totalBasics = reservedBasicsTotal;

    // Calculate slots available for duals
    var reservedBasics = reservedBasicsTotal;
    var colorlessLands = Math.max(0, state.totalLands - activeList.reduce(function(s, c) { return s + recommended[c]; }, 0));
    var maxDuals = Math.max(0, state.totalLands - colorlessLands - reservedBasics);

    // Build candidate list: all available duals for our color pairs
    var pairs = [];
    for (var i = 0; i < activeList.length; i++) {
        for (var j = i + 1; j < activeList.length; j++) {
            pairs.push(getColorPair(activeList[i], activeList[j]));
        }
    }

    // All 10 possible color pairs (for off-color fetch evaluation)
    var allPairs = ['WU','WB','WR','WG','UB','UR','UG','BR','BG','RG'];

    var candidates = [];
    cycleKeys.forEach(function(key) {
        var cycle = LAND_CYCLES[key];
        if (!cycle) return;

        if (cycle.meta.isFetch) {
            // For fetch lands: include any fetch where at least one basic type matches an active color
            allPairs.forEach(function(pair) {
                if (!cycle.cards[pair]) return;
                var type1 = COLOR_TO_BASIC_TYPE[pair[0]];
                var type2 = COLOR_TO_BASIC_TYPE[pair[1]];
                var hasActiveType = false;
                for (var ai = 0; ai < activeList.length; ai++) {
                    var activeType = COLOR_TO_BASIC_TYPE[activeList[ai]];
                    if (activeType === type1 || activeType === type2) {
                        hasActiveType = true;
                        break;
                    }
                }
                if (hasActiveType) {
                    var isOnColor = pairs.indexOf(pair) >= 0;
                    candidates.push({ cycleKey: key, pair: pair, name: cycle.cards[pair], isOffColorFetch: !isOnColor });
                }
            });
        } else {
            // Non-fetch cycles: only on-color pairs
            pairs.forEach(function(pair) {
                if (cycle.cards[pair]) {
                    candidates.push({ cycleKey: key, pair: pair, name: cycle.cards[pair] });
                }
            });
        }
    });

    // Track per-candidate allocation
    var candidateQty = {}; // "cycleKey:pair" -> qty allocated
    candidates.forEach(function(c) { candidateQty[c.cycleKey + ':' + c.pair] = 0; });

    // Flexible "any-color" land candidates
    var flexKeys = FLEXIBLE_LAND_FORMATS[formatKey] || [];
    var flexCandidates = [];
    flexKeys.forEach(function(fKey) {
        if (!FLEXIBLE_LANDS[fKey]) return;
        // Skip commander-only lands in non-Commander formats (they produce no mana)
        if (FLEXIBLE_LANDS[fKey].condition === 'commander' && !isCommander) return;
        flexCandidates.push({ flexKey: fKey, name: FLEXIBLE_LANDS[fKey].name, isFlex: true });
    });
    allocation.flexCopies = {};

    // Greedy single-copy allocation loop
    for (var slot = 0; slot < maxDuals; slot++) {
        var bestScore = -Infinity;
        var bestCandidate = null;

        for (var ci = 0; ci < candidates.length; ci++) {
            var cand = candidates[ci];
            var cKey = cand.cycleKey + ':' + cand.pair;
            var currentQty = candidateQty[cKey] || 0;
            if (currentQty >= copiesPerCycle) continue; // max copies reached

            var sc = scoreLand(cand.cycleKey, cand.pair, deckContext, tempoProfile, allocation);
            if (sc > bestScore) {
                bestScore = sc;
                bestCandidate = cand;
            }
        }

        // Also score flexible land candidates
        for (var fi = 0; fi < flexCandidates.length; fi++) {
            var fc = flexCandidates[fi];
            var flexLand = FLEXIBLE_LANDS[fc.flexKey];
            var fCopies = allocation.flexCopies[fc.flexKey] || 0;
            var fMax = isCommander ? 1 : flexLand.maxCopies;
            if (fCopies >= fMax) continue;

            var fScore = scoreFlexibleLand(fc.flexKey, deckContext, tempoProfile, allocation, activeList);
            if (fScore > bestScore) {
                bestScore = fScore;
                bestCandidate = fc;
            }
        }

        if (!bestCandidate) break; // no more candidates

        if (bestCandidate.isFlex) {
            // Flexible land: allocate and update ALL active colors
            var fKey = bestCandidate.flexKey;
            allocation.flexCopies[fKey] = (allocation.flexCopies[fKey] || 0) + 1;
            allocation.totalDuals++;
            var fMeta = FLEXIBLE_LANDS[fKey].meta;

            // Source credit: fractional for conditional lands, full for unconditional
            var sourceContrib = flexLandEffectiveness(fKey, deckContext);
            activeList.forEach(function(c) {
                allocation.sources[c] = (allocation.sources[c] || 0) + sourceContrib;
            });
            if (fMeta.fetchable) allocation.fetchableCount++;

            // Add to duals array for display
            var existingFlex = null;
            for (var d = 0; d < allocation.duals.length; d++) {
                if (allocation.duals[d].name === bestCandidate.name && allocation.duals[d].isFlex) {
                    existingFlex = allocation.duals[d];
                    break;
                }
            }
            if (existingFlex) {
                existingFlex.qty++;
            } else {
                allocation.duals.push({
                    cycleKey: '_flex_' + fKey,
                    pair: 'ALL',
                    name: bestCandidate.name,
                    qty: 1,
                    meta: fMeta,
                    isFlex: true,
                    flexKey: fKey
                });
            }
        } else {
            // Dual land allocation
            var bKey = bestCandidate.cycleKey + ':' + bestCandidate.pair;
            candidateQty[bKey] = (candidateQty[bKey] || 0) + 1;
            var bcMeta = LAND_CYCLES[bestCandidate.cycleKey].meta;

            allocation.totalDuals++;
            allocation.cycleCounts[bestCandidate.cycleKey] = (allocation.cycleCounts[bestCandidate.cycleKey] || 0) + 1;

            if (bcMeta.isFetch) {
                // Fetch lands: credit effective colors (what they can actually find)
                var fetchEffColors = computeFetchEffectiveColors(bestCandidate.pair, activeList, allocation);
                for (var fe = 0; fe < fetchEffColors.length; fe++) {
                    allocation.sources[fetchEffColors[fe]] = (allocation.sources[fetchEffColors[fe]] || 0) + 1;
                }
                allocation.fetchCount++;
            } else {
                var p0 = bestCandidate.pair[0], p1 = bestCandidate.pair[1];
                var contrib = bcMeta.mdfc ? 0.5 : 1;
                allocation.sources[p0] = (allocation.sources[p0] || 0) + contrib;
                allocation.sources[p1] = (allocation.sources[p1] || 0) + contrib;
            }
            if (bcMeta.fetchable) allocation.fetchableCount++;

            var existingDual = null;
            for (var d = 0; d < allocation.duals.length; d++) {
                if (allocation.duals[d].cycleKey === bestCandidate.cycleKey && allocation.duals[d].pair === bestCandidate.pair) {
                    existingDual = allocation.duals[d];
                    break;
                }
            }
            if (existingDual) {
                existingDual.qty++;
            } else {
                var dualEntry = {
                    cycleKey: bestCandidate.cycleKey,
                    pair: bestCandidate.pair,
                    name: bestCandidate.name,
                    qty: 1,
                    meta: bcMeta
                };
                if (bcMeta.isFetch) {
                    dualEntry.effectiveColors = computeFetchEffectiveColors(bestCandidate.pair, activeList, allocation);
                }
                allocation.duals.push(dualEntry);
            }
        }
    }

    // Distribute remaining basic land slots — fill most deficient color first
    var basicTotal = state.totalLands - allocation.totalDuals - colorlessLands;
    var basicsToDistribute = basicTotal - reservedBasics;

    for (var b = 0; b < basicsToDistribute; b++) {
        var worstColor = null, worstDeficit = -Infinity;
        activeList.forEach(function(c) {
            var deficit = (needed[c] || 0) - (allocation.sources[c] || 0);
            if (deficit > worstDeficit) {
                worstDeficit = deficit;
                worstColor = c;
            }
        });
        if (worstColor) {
            allocation.basics[worstColor]++;
            allocation.sources[worstColor]++;
            deckContext.totalBasics++;
        }
    }

    // Compute life cost estimate
    var expectedLifeLoss = 0;
    allocation.duals.forEach(function(d) {
        var m = d.meta;
        // Shock lands: ~70% of the time you pay the 2 life in a typical game
        if (m.etb === 'choice' && m.lifeCost > 0) {
            expectedLifeLoss += d.qty * m.lifeCost * 0.7;
        }
        // Fetch lands: always pay 1 life
        if (m.isFetch) {
            expectedLifeLoss += d.qty * m.lifeCost * 0.85;
        }
        // Pain/Horizon: colored activation used ~60% of the time
        if (m.coloredUseCost > 0) {
            expectedLifeLoss += d.qty * m.coloredUseCost * 0.6;
        }
    });

    return {
        duals: allocation.duals,
        basics: allocation.basics,
        sources: allocation.sources,
        tempoProfile: tempoProfile,
        totalDuals: allocation.totalDuals,
        totalBasics: basicTotal,
        colorlessLands: colorlessLands,
        expectedLifeLoss: Math.round(expectedLifeLoss * 10) / 10,
        fetchCount: allocation.fetchCount,
        fetchableCount: allocation.fetchableCount,
        deckAnalysis: deckAnalysis,
        deckContext: deckContext
    };
}

function landReasonText(cycleKey, meta, flexKey) {
    if (!meta) return '';
    var reasons = [];

    // Flexible land condition descriptions
    if (flexKey) {
        var flex = FLEXIBLE_LANDS[flexKey];
        var condition = flex ? (flex.condition || null) : null;
        if (condition === 'legendary') {
            reasons.push('Any color for legendary spells');
        } else if (condition === 'tribal') {
            reasons.push('Any color for chosen creature type');
            if (flexKey === 'cavernOfSouls') reasons.push('Uncounterable');
        } else if (condition === 'artifact') {
            reasons.push('Any color with artifact in play');
        } else if (condition === 'creatureSpell') {
            reasons.push('Any color for creature spells');
        } else if (condition === 'multicolor') {
            reasons.push('Any color for multicolor spells');
        } else if (condition === 'commander') {
            reasons.push('Any color (Commander)');
        } else if (condition === 'turnGated') {
            reasons.push('Any color T1-3, tapped later');
        } else {
            if (meta.etb === 'choice' && meta.fetchable) reasons.push('Untapped for ' + meta.lifeCost + ' life, fetchable');
            else reasons.push('Any color');
        }
        if (meta.etb === 'tapped') reasons.push('ETB tapped');
        if (meta.coloredUseCost > 0) reasons.push('1 life per tap');
        return reasons.join(' · ');
    }

    if (meta.etb === 'untapped' && meta.lifeCost === 0 && meta.coloredUseCost === 0) {
        if (meta.fetchable) reasons.push('Always untapped, fetchable');
        else if (meta.mdfc) reasons.push('Untapped, one color per side');
        else reasons.push('Always untapped, no cost');
    } else if (meta.etb === 'choice') {
        reasons.push('Untapped for ' + meta.lifeCost + ' life, fetchable');
    } else if (meta.etb === 'tapped') {
        if (meta.fetchable) reasons.push('ETB tapped, fetchable');
        else reasons.push('ETB tapped');
    } else if (meta.etb === 'conditional') {
        var ct = meta.conditionType;
        if (ct === 'startingTown') reasons.push('Untapped T1-3');
        else if (ct === 'fast') reasons.push('Untapped T1-3');
        else if (ct === 'slow') reasons.push('Untapped T3+');
        else if (ct === 'check') reasons.push('Untapped with basic');
        else if (ct === 'reveal') reasons.push('Untapped if basic in hand');
        else if (ct === 'haunt') reasons.push('Untapped below 14 life');
        else if (ct === 'bond') reasons.push('Untapped in multiplayer');
        else reasons.push('Conditional untapped');
    }
    if (meta.isFetch) reasons.push('Finds any fetchable land');
    if (meta.coloredUseCost > 0 && cycleKey === 'horizonLands') reasons.push('Sac to draw');
    else if (meta.coloredUseCost > 0) reasons.push('1 dmg per colored tap');
    if (cycleKey === 'restlessLands') reasons.push('Creature land');
    if (cycleKey === 'surveilLands') reasons.push('Surveil 1');
    if (cycleKey === 'scryTemples') reasons.push('Scry 1');
    return reasons.join(' · ');
}

function renderOptimizedManaBase(result, activeList, rampInfo) {
    var tp = result.tempoProfile;
    var html = '';

    // Tempo Profile Badge
    var badgeColor = tp.archetype === 'aggro' ? '#ef4444' : (tp.archetype === 'midrange' ? '#f59e0b' : '#3b82f6');
    html += '<div class="tempo-badge" style="background:' + badgeColor + '20;border:1px solid ' + badgeColor + '40;color:' + badgeColor + '">';
    html += '<strong>' + tp.archetype.charAt(0).toUpperCase() + tp.archetype.slice(1) + '</strong>';
    html += ' · Avg MV ' + tp.avgMV.toFixed(1);
    if (tp.oneDropCount > 0) html += ' · ' + tp.oneDropCount + ' one-drops';
    html += '</div>';

    // Optimized Land List
    html += '<h4 class="optimizer-heading">Optimized Land Selection</h4>';

    if (result.duals.length > 0) {
        result.duals.forEach(function(d) {
            var cycle = d.isFlex ? FLEXIBLE_LANDS[d.flexKey] : LAND_CYCLES[d.cycleKey];
            var tagColor;
            var cycleName;
            if (d.isFlex && d.flexKey) {
                var flexCond = FLEXIBLE_LANDS[d.flexKey] ? (FLEXIBLE_LANDS[d.flexKey].condition || null) : null;
                var condLabels = {
                    legendary: 'Legendary Fixing', tribal: 'Tribal Fixing',
                    artifact: 'Artifact Fixing', creatureSpell: 'Creature Fixing',
                    multicolor: 'Multicolor Fixing', commander: 'Commander Staple'
                };
                if (condLabels[flexCond]) {
                    tagColor = flexCond === 'commander' ? '#38bdf8' : '#c084fc'; // blue for commander, purple for deck-dependent
                    cycleName = condLabels[flexCond];
                } else if (flexCond === 'turnGated') {
                    tagColor = '#facc15';
                    cycleName = 'Turn-Gated Fixing';
                } else {
                    tagColor = '#4ade80'; // green for unconditional
                    cycleName = cycle ? cycle.name : 'Any Color';
                }
            } else {
                tagColor = d.meta.etb === 'tapped' ? '#71717a' :
                              (d.meta.etb === 'untapped' || d.meta.etb === 'choice' ? '#4ade80' : '#facc15');
                cycleName = cycle ? cycle.name : 'Unknown';
            }
            var reason = landReasonText(d.cycleKey, d.meta, d.flexKey || null);

            html += '<div class="optimizer-land-row">';
            html += '<span class="optimizer-land-qty">' + d.qty + '</span>';
            html += '<span class="optimizer-land-name card-name-link" data-card="' + d.name + '">' + d.name + '</span>';
            html += '<span class="optimizer-land-tag" style="color:' + tagColor + ';border-color:' + tagColor + '40">' + cycleName + '</span>';
            if (reason) html += '<span class="optimizer-land-reason">' + reason + '</span>';
            html += '</div>';
        });
    }

    // Basics
    activeList.forEach(function(c) {
        if (result.basics[c] > 0) {
            html += '<div class="optimizer-land-row">';
            html += '<span class="optimizer-land-qty">' + result.basics[c] + '</span>';
            html += '<span class="optimizer-land-name" style="color:' + COLOR_HEX[c] + '">' + basicLandName(c) + '</span>';
            html += '<span class="optimizer-land-tag" style="color:#71717a;border-color:rgba(113,113,122,0.4)">Basic</span>';
            html += '</div>';
        }
    });

    if (result.colorlessLands > 0) {
        // Try to show named utility land recommendations for Commander
        var multiUtilRecs = recommendUtilityLands(activeList, result.colorlessLands, result.deckContext || {}, result.tempoProfile);
        if (multiUtilRecs.length > 0) {
            for (var mu = 0; mu < multiUtilRecs.length; mu++) {
                html += '<div class="optimizer-land-row">';
                html += '<span class="optimizer-land-qty">1</span>';
                html += '<span class="optimizer-land-name card-name-link" data-card="' + multiUtilRecs[mu].name + '">' + multiUtilRecs[mu].name + '</span>';
                html += '<span class="optimizer-land-tag" style="color:#a78bfa;border-color:rgba(167,139,250,0.4)">Utility</span>';
                html += '<span class="optimizer-land-reason">' + multiUtilRecs[mu].desc + '</span>';
                html += '</div>';
            }
            var remainingUtil = result.colorlessLands - multiUtilRecs.length;
            if (remainingUtil > 0) {
                html += '<div class="optimizer-land-row">';
                html += '<span class="optimizer-land-qty">' + remainingUtil + '</span>';
                html += '<span class="optimizer-land-name">Utility / Colorless</span>';
                html += '<span class="optimizer-land-tag" style="color:#71717a;border-color:rgba(113,113,122,0.4)">Utility</span>';
                html += '</div>';
            }
        } else {
            html += '<div class="optimizer-land-row">';
            html += '<span class="optimizer-land-qty">' + result.colorlessLands + '</span>';
            html += '<span class="optimizer-land-name">Utility / Colorless</span>';
            html += '<span class="optimizer-land-tag" style="color:#71717a;border-color:rgba(113,113,122,0.4)">Utility</span>';
            html += '</div>';
        }
    }

    // Source Summary
    html += '<div class="source-summary">';
    html += '<h4 class="optimizer-heading">Color Sources</h4>';
    activeList.forEach(function(c) {
        var actual = Math.round(result.sources[c] || 0);
        var baseTarget = result.tempoProfile ? (state.mode === 'imported' ? recommendedSources(c, state.deckSize, state.totalLands, state.cards) : recommendedSourcesFromPips(state.pips[c], state.deckSize, state.totalLands)) : 14;
        // Use ramp-adjusted target if available
        var target = (rampInfo && rampInfo.adjusted[c] !== undefined) ? rampInfo.adjusted[c] : baseTarget;
        var pct = target > 0 ? Math.min(100, Math.round((actual / target) * 100)) : 100;
        var isMet = actual >= target;
        var barColor = isMet ? '#4ade80' : '#f87171';

        html += '<div class="source-row">';
        html += '<span class="source-label" style="color:' + COLOR_HEX[c] + '">' + COLOR_NAMES[c] + '</span>';
        html += '<div class="source-bar-track">';
        html += '<div class="source-bar-fill" style="width:' + pct + '%;background:' + barColor + '"></div>';
        html += '</div>';
        html += '<span class="source-count ' + (isMet ? 'source-met' : 'source-short') + '">' + actual + '/' + target + '</span>';
        html += '</div>';
    });
    html += '</div>';

    // Life Cost Estimate
    if (result.expectedLifeLoss > 0) {
        html += '<div class="life-estimate">';
        html += 'Expected life from lands: ~' + result.expectedLifeLoss.toFixed(1) + ' per game';
        html += '</div>';
    }

    return html;
}

// ══════════════════════════════════════════
// Ramp-Aware Source Adjustment
// ══════════════════════════════════════════

// Formats where ramp adjustments apply (Commander, Modern, Legacy)
var RAMP_FORMATS = { commander: true, modern: true, legacy: true };

function computeRampAdjustment(activeList, recommended, cards) {
    // Only apply for imported decks with ramp, in supported formats
    if (state.mode !== 'imported' || !cards || !RAMP_FORMATS[state.format]) {
        return null;
    }

    var deckAnalysis = analyzeDeckContext(cards);
    if (deckAnalysis.rampCount === 0) return null;

    // Per-color: compute ramp source adjustment, considering ramp MV floor
    var adjusted = {};
    var adjustments = {};
    activeList.forEach(function(c) {
        var demand = findMostDemandingCard(c, cards);
        var demandTurn = demand ? demand.turn : 3;
        var demandPips = demand ? demand.pips : 1;

        // Sum ramp sources that can help cast the most demanding card
        // Ramp at MV N can only accelerate spells at MV > N
        var rampContrib = 0;
        for (var r = 0; r < deckAnalysis.rampDetails.length; r++) {
            var rd = deckAnalysis.rampDetails[r];
            if (rd.mv >= demandTurn) continue; // Ramp too slow to help this card
            var isAny = rd.colors.indexOf('any') >= 0;
            if (isAny || rd.colors.indexOf(c) >= 0) {
                rampContrib += rd.weight * rd.qty;
            }
        }

        // Floor: never reduce below minimum for that pip count
        // Minimum = karstenLookup(1, demandTurn) scaled, as a floor
        var minSources = Math.max(1, Math.round(karstenLookup(1, Math.max(1, demandTurn)) * (state.deckSize / 60)));
        var adj = Math.min(rampContrib, recommended[c] - minSources);
        adj = Math.max(0, Math.round(adj));

        adjusted[c] = recommended[c] - adj;
        adjustments[c] = adj;
    });

    // Compute suggested land count (Karsten Commander regression)
    var suggestedLands = null;
    if (state.format === 'commander') {
        var totalSpells = 0, weightedMV = 0;
        for (var i = 0; i < cards.length; i++) {
            if (!cards[i].isLand) {
                totalSpells += cards[i].qty;
                weightedMV += cards[i].mv * cards[i].qty;
            }
        }
        var avgMV = totalSpells > 0 ? weightedMV / totalSpells : 2.5;
        var base = (99 / 60) * (19.59 + 1.90 * avgMV);
        var adj = base - (0.28 * deckAnalysis.cheapRampCount) - (0.28 * deckAnalysis.cheapDrawCount) - deckAnalysis.fastManaCount - 1.35;
        suggestedLands = { low: Math.floor(adj), high: Math.ceil(adj), avgMV: avgMV, cheapRamp: deckAnalysis.cheapRampCount, cheapDraw: deckAnalysis.cheapDrawCount, fastMana: deckAnalysis.fastManaCount };
        // Clamp to reasonable range
        if (suggestedLands.low < 28) suggestedLands.low = 28;
        if (suggestedLands.high < suggestedLands.low) suggestedLands.high = suggestedLands.low;
        if (suggestedLands.high > 42) suggestedLands.high = 42;
    }

    return {
        adjusted: adjusted,
        adjustments: adjustments,
        deckAnalysis: deckAnalysis,
        suggestedLands: suggestedLands
    };
}

function renderRampBanner(rampInfo) {
    if (!rampInfo) return '';
    var da = rampInfo.deckAnalysis;
    var html = '<div class="ramp-banner">';
    html += '<strong>Ramp Detected:</strong> ' + da.rampCount + ' pieces';

    var parts = [];
    var fastTotal = (da.rampByType.fast || 0) + (da.rampByType.fastOneShot || 0);
    if (fastTotal > 0) parts.push(fastTotal + ' fast mana');
    if (da.rampByType.dork > 0) parts.push(da.rampByType.dork + ' dork' + (da.rampByType.dork > 1 ? 's' : ''));
    if (da.rampByType.rock > 0) parts.push(da.rampByType.rock + ' rock' + (da.rampByType.rock > 1 ? 's' : ''));
    if (da.rampByType.landRamp > 0) parts.push(da.rampByType.landRamp + ' land ramp');
    if (da.rampByType.extraLand > 0) parts.push(da.rampByType.extraLand + ' extra land drop' + (da.rampByType.extraLand > 1 ? 's' : ''));
    if (da.rampByType.treasure > 0) parts.push(da.rampByType.treasure + ' treasure');
    if (da.rampByType.etbMana > 0) parts.push(da.rampByType.etbMana + ' ETB mana');
    if (parts.length > 0) html += ' (' + parts.join(', ') + ')';

    html += ' <span class="ramp-adjust">&middot; Sources adjusted by Karsten method</span>';
    html += '</div>';

    // Suggested land count (Commander only)
    if (rampInfo.suggestedLands) {
        var sl = rampInfo.suggestedLands;
        html += '<div class="land-count-hint">';
        html += '<strong>Suggested lands:</strong> ';
        if (sl.low === sl.high) {
            html += sl.low;
        } else {
            html += sl.low + '&ndash;' + sl.high;
        }
        html += ' (currently ' + state.totalLands + ')';
        html += ' <span class="hint-detail">&middot; avg MV ' + sl.avgMV.toFixed(1);
        if (sl.cheapRamp > 0) html += ', ' + sl.cheapRamp + ' cheap ramp';
        if (sl.cheapDraw > 0) html += ', ' + sl.cheapDraw + ' card draw';
        html += '</span>';
        html += '</div>';
    }

    return html;
}

// ══════════════════════════════════════════
// Calculation
// ══════════════════════════════════════════

function calculate(fromImport) {
    // Read latest state
    state.deckSize = Math.max(20, parseInt(document.getElementById('deckSize').value) || 60);
    state.totalLands = Math.max(0, parseInt(document.getElementById('totalLands').value) || 0);
    COLORS.forEach(function(c) {
        var inp = document.getElementById('pip-' + c);
        if (inp) state.pips[c] = Math.max(0, parseInt(inp.value) || 0);
    });

    // Reset to manual mode if not coming from import
    if (!fromImport) {
        state.mode = 'manual';
        state.cards = null;
        state.simResults = null;
    }

    var activeList = COLORS.filter(function(c) { return state.activeColors.has(c) && state.pips[c] > 0; });

    if (activeList.length === 0) {
        showEmptyResults('Select at least one color and enter mana pips to calculate.');
        return;
    }

    // Calculate recommended sources per color
    var recommended = {};
    var totalRecommended = 0;
    activeList.forEach(function(c) {
        recommended[c] = recommendedSources(c, state.deckSize, state.totalLands, state.cards);
        totalRecommended += recommended[c];
    });

    // If total recommended > total lands, scale down proportionally
    if (totalRecommended > state.totalLands && totalRecommended > 0) {
        var scale = state.totalLands / totalRecommended;
        activeList.forEach(function(c) {
            recommended[c] = Math.max(1, Math.round(recommended[c] * scale));
        });
        // Adjust rounding to match exactly
        var newTotal = 0;
        activeList.forEach(function(c) { newTotal += recommended[c]; });
        var diff = state.totalLands - newTotal;
        // Distribute remainder to colors with most pips
        var sorted = activeList.slice().sort(function(a, b) { return state.pips[b] - state.pips[a]; });
        var i = 0;
        while (diff > 0 && i < sorted.length) { recommended[sorted[i]]++; diff--; i++; }
        while (diff < 0 && i < sorted.length) {
            if (recommended[sorted[i]] > 1) { recommended[sorted[i]]--; diff++; }
            i++;
        }
    }

    // If total recommended < total lands, remaining are colorless/utility
    var colorlessLands = Math.max(0, state.totalLands - activeList.reduce(function(s, c) { return s + recommended[c]; }, 0));

    // Compute ramp-adjusted source targets (Commander, Modern, Legacy only)
    var rampInfo = computeRampAdjustment(activeList, recommended, state.cards);
    if (rampInfo) {
        // Apply ramp adjustments to recommended sources
        activeList.forEach(function(c) {
            recommended[c] = rampInfo.adjusted[c];
        });
        colorlessLands = Math.max(0, state.totalLands - activeList.reduce(function(s, c) { return s + recommended[c]; }, 0));
    }

    // Build results HTML
    var html = '';

    // ── Ramp Banner (import mode + ramp detected only) ──
    if (rampInfo) {
        html += renderRampBanner(rampInfo);
    }

    // ── Land Count Cards ──
    html += '<h3>Recommended Land Sources</h3>';
    html += '<div class="land-counts">';
    activeList.forEach(function(c) {
        var pct = state.totalLands > 0 ? Math.round((recommended[c] / state.totalLands) * 100) : 0;
        html += '<div class="land-card" data-color="' + c + '">';
        html += '<div class="land-count">' + recommended[c] + '</div>';
        html += '<div class="land-label">' + COLOR_NAMES[c] + ' Sources</div>';
        html += '<div class="land-pct">' + pct + '% of lands</div>';
        html += '</div>';
    });
    if (colorlessLands > 0) {
        var pct = Math.round((colorlessLands / state.totalLands) * 100);
        html += '<div class="land-card" data-color="C">';
        html += '<div class="land-count">' + colorlessLands + '</div>';
        html += '<div class="land-label">Colorless / Utility</div>';
        html += '<div class="land-pct">' + pct + '% of lands</div>';
        html += '</div>';
    }
    html += '</div>';

    // ── Bar Chart ──
    html += '<div class="chart-section">';
    html += '<h3>Land Distribution</h3>';
    html += '<div class="bar-chart">';
    var maxCount = 0;
    activeList.forEach(function(c) { if (recommended[c] > maxCount) maxCount = recommended[c]; });
    if (colorlessLands > maxCount) maxCount = colorlessLands;
    if (maxCount === 0) maxCount = 1;

    activeList.forEach(function(c) {
        var h = Math.round((recommended[c] / maxCount) * 120);
        html += '<div class="bar-col">';
        html += '<div class="bar-count">' + recommended[c] + '</div>';
        html += '<div class="bar-fill" data-color="' + c + '" style="height:' + h + 'px"></div>';
        html += '<div class="bar-label">' + COLOR_NAMES[c] + '</div>';
        html += '</div>';
    });
    if (colorlessLands > 0) {
        var h = Math.round((colorlessLands / maxCount) * 120);
        html += '<div class="bar-col">';
        html += '<div class="bar-count">' + colorlessLands + '</div>';
        html += '<div class="bar-fill" data-color="C" style="height:' + h + 'px"></div>';
        html += '<div class="bar-label">Colorless</div>';
        html += '</div>';
    }
    html += '</div></div>';

    // ── Cast Rate / Probability Section ──
    html += '<div class="prob-section" id="simSection">';
    html += '<h3>Cast Rate Analysis</h3>';
    if (simWorkerFailed) {
        html += '<div class="sim-fallback-notice">Simulation unavailable &mdash; showing estimated probabilities (hypergeometric).</div>';
        html += renderFallbackProbTable(activeList, recommended);
    } else {
        html += '<div class="sim-progress" id="simProgress">';
        html += '<div class="sim-progress-bar" id="simProgressBar" style="width:0%"></div>';
        html += '<span class="sim-progress-text" id="simProgressText">Starting simulation...</span>';
        html += '</div>';
        html += '<div id="simResultsContainer"></div>';
    }
    html += '</div>';

    // ── Optimized Mana Base ──
    var optimizerResult = null;
    html += '<div class="suggested-section">';
    html += '<h3>Optimized Mana Base</h3>';

    // Reuse deck analysis from ramp computation if available
    var cachedAnalysis = rampInfo ? rampInfo.deckAnalysis : null;

    if (activeList.length >= 2) {
        optimizerResult = optimizeManaBase(activeList, recommended, cachedAnalysis);
        html += renderOptimizedManaBase(optimizerResult, activeList, rampInfo);
    } else {
        // Mono color — compute tempo + deck context for utility land recs
        var c = activeList[0];
        var monoTempo = computeTempoProfile();
        var monoDeckAnalysis = cachedAnalysis || ((state.mode === 'imported' && state.cards) ? analyzeDeckContext(state.cards) : analyzeDeckContext(null));
        var monoDeckContext = {
            needed: {}, isCommander: (state.format === 'commander'),
            totalBasics: recommended[c],
            legendaryDensity: monoDeckAnalysis.legendaryDensity,
            tribalDensity: monoDeckAnalysis.tribalDensity,
            dominantType: monoDeckAnalysis.dominantType,
            creatureCount: monoDeckAnalysis.creatureCount,
            totalSpells: monoDeckAnalysis.totalSpells,
            artifactDensity: monoDeckAnalysis.artifactDensity,
            creatureSpellDensity: monoDeckAnalysis.creatureSpellDensity,
            multicolorDensity: monoDeckAnalysis.multicolorDensity,
            enchantmentDensity: monoDeckAnalysis.enchantmentDensity,
            instantSorceryDensity: monoDeckAnalysis.instantSorceryDensity
        };
        monoDeckContext.needed[c] = recommended[c];

        // Tempo badge
        var monoBadgeColor = monoTempo.archetype === 'aggro' ? '#ef4444' : (monoTempo.archetype === 'midrange' ? '#f59e0b' : '#3b82f6');
        html += '<div class="tempo-badge" style="background:' + monoBadgeColor + '20;border:1px solid ' + monoBadgeColor + '40;color:' + monoBadgeColor + '">';
        html += '<strong>' + monoTempo.archetype.charAt(0).toUpperCase() + monoTempo.archetype.slice(1) + '</strong>';
        html += ' · Avg MV ' + monoTempo.avgMV.toFixed(1);
        if (monoTempo.oneDropCount > 0) html += ' · ' + monoTempo.oneDropCount + ' one-drops';
        html += '</div>';

        html += '<h4 class="optimizer-heading">Mono-' + COLOR_NAMES[c] + ' Mana Base</h4>';

        var utilityRecs = recommendUtilityLands(activeList, colorlessLands, monoDeckContext, monoTempo);
        var basicsCount = recommended[c] - (utilityRecs.length > colorlessLands ? 0 : 0);
        // Basics = total lands minus utility recs
        basicsCount = state.totalLands - utilityRecs.length;

        // Basics row
        html += '<div class="optimizer-land-row">';
        html += '<span class="optimizer-land-qty">' + basicsCount + '</span>';
        html += '<span class="optimizer-land-name" style="color:' + COLOR_HEX[c] + '">' + basicLandName(c) + '</span>';
        html += '<span class="optimizer-land-tag" style="color:#71717a;border-color:rgba(113,113,122,0.4)">Basic</span>';
        html += '</div>';

        // Utility land rows
        if (utilityRecs.length > 0) {
            for (var u = 0; u < utilityRecs.length; u++) {
                var rec = utilityRecs[u];
                html += '<div class="optimizer-land-row">';
                html += '<span class="optimizer-land-qty">1</span>';
                html += '<span class="optimizer-land-name card-name-link" data-card="' + rec.name + '">' + rec.name + '</span>';
                html += '<span class="optimizer-land-tag" style="color:#a78bfa;border-color:rgba(167,139,250,0.4)">Utility</span>';
                html += '<span class="optimizer-land-reason">' + rec.desc + '</span>';
                html += '</div>';
            }
        } else if (colorlessLands > 0) {
            html += '<div class="optimizer-land-row">';
            html += '<span class="optimizer-land-qty">' + colorlessLands + '</span>';
            html += '<span class="optimizer-land-name">Utility / Colorless</span>';
            html += '<span class="optimizer-land-tag" style="color:#71717a;border-color:rgba(113,113,122,0.4)">Utility</span>';
            html += '</div>';
        }
    }

    html += '</div>';

    // ── Available Dual Lands Reference ──
    if (activeList.length >= 2) {
        html += '<div class="suggested-section">';
        html += '<h3>Available Dual Lands</h3>';
        html += buildDualSuggestions(activeList, recommended, colorlessLands);
        html += '</div>';
    }

    document.getElementById('resultsContent').innerHTML = html;

    // Launch Monte Carlo simulation (unless worker failed)
    if (!simWorkerFailed) {
        launchSimulation(activeList, recommended, optimizerResult);
    }

    // Scroll to results on mobile
    if (window.innerWidth <= 960) {
        document.getElementById('resultsPanel').scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
}

// ══════════════════════════════════════════
// Monte Carlo Simulation Integration
// ══════════════════════════════════════════

function initWorker() {
    try {
        simWorker = new Worker('/tools/manabase/sim-worker-wasm.js?v=4', { type: 'module' });
        simEngine = 'wasm';
        simWorker.onmessage = function(e) {
            if (e.data.type === 'ready') {
                simEngine = 'wasm';
            } else if (e.data.type === 'error') {
                console.warn('WASM worker error, falling back to JS:', e.data.message);
                simWorker.terminate(); simWorker = null;
                initJSWorker();
            }
        };
        simWorker.onerror = function(e) {
            simWorkerFailed = false;
            if (simWorker) { simWorker.terminate(); simWorker = null; }
            initJSWorker();
        };
    } catch (e) {
        initJSWorker();
    }
}

function initJSWorker() {
    simEngine = 'js';
    try {
        simWorker = new Worker('/tools/manabase/sim-worker.js');
        simWorker.onerror = function(e) {
            simWorkerFailed = true;
            if (simWorker) { simWorker.terminate(); simWorker = null; }
        };
    } catch (e) {
        simWorkerFailed = true;
    }
}

function landEntersTapped(meta) {
    if (!meta) return false;
    var etb = meta.etb;
    if (etb === 'untapped' || etb === 'choice') return false;
    if (etb === 'tapped') return true;
    // Conditional: conservative estimate for sim
    if (meta.conditionType === 'startingTown' || meta.conditionType === 'fast' || meta.conditionType === 'check' || meta.conditionType === 'reveal') return false;
    if (meta.conditionType === 'slow' || meta.conditionType === 'haunt') return true;
    if (meta.conditionType === 'bond') return false; // untapped in commander
    return false;
}

function buildDeckSpec(optimizerResult) {
    var spec = { size: state.deckSize, spells: [], lands: [] };

    if (state.mode === 'imported' && state.cards) {
        // Import mode: use actual per-card data
        for (var i = 0; i < state.cards.length; i++) {
            var card = state.cards[i];
            if (card.isLand) {
                // Look up cycle metadata for enters_tapped
                var lookup = LAND_NAME_TO_CYCLE[card.name.toLowerCase()];
                var etbTapped = false;
                if (lookup) {
                    var cycleMeta;
                    if (lookup.isFlex) {
                        var fk = lookup.cycleKey.substring(6); // strip '_flex_'
                        cycleMeta = FLEXIBLE_LANDS[fk] && FLEXIBLE_LANDS[fk].meta;
                    } else {
                        cycleMeta = LAND_CYCLES[lookup.cycleKey] && LAND_CYCLES[lookup.cycleKey].meta;
                    }
                    etbTapped = landEntersTapped(cycleMeta);
                }
                spec.lands.push({ name: card.name, qty: card.qty, produces: card.producesColors || [], enters_tapped: etbTapped });
            } else {
                spec.spells.push({ name: card.name, qty: card.qty, mv: card.mv, pips: card.pips });
            }
        }
    } else if (optimizerResult) {
        // Use optimizer output for lands
        var activeList = COLORS.filter(function(c) { return state.activeColors.has(c) && state.pips[c] > 0; });
        var totalPipCount = 0;
        activeList.forEach(function(c) { totalPipCount += state.pips[c]; });

        // Spells from curve
        for (var mv = 1; mv <= 7; mv++) {
            var spellCount = state.curve[mv] || 0;
            if (spellCount <= 0) continue;
            var virtualPips = {};
            activeList.forEach(function(c) {
                if (totalPipCount > 0) {
                    virtualPips[c] = Math.min(mv, Math.round(state.pips[c] / totalPipCount * Math.min(mv, 2)));
                } else {
                    virtualPips[c] = 0;
                }
            });
            var pipSum = 0;
            for (var c in virtualPips) pipSum += virtualPips[c];
            if (pipSum === 0 && activeList.length > 0) virtualPips[activeList[0]] = 1;
            spec.spells.push({ name: mv + '-drop', qty: spellCount, mv: mv, pips: virtualPips });
        }
        if (state.curve[0] > 0) {
            spec.spells.push({ name: '0-drop', qty: state.curve[0], mv: 0, pips: { W:0, U:0, B:0, R:0, G:0 } });
        }

        // Lands from optimizer
        optimizerResult.duals.forEach(function(d) {
            var produces = d.isFlex ? activeList.slice() : (d.effectiveColors ? d.effectiveColors : [d.pair[0], d.pair[1]]);
            spec.lands.push({
                name: d.name, qty: d.qty,
                produces: produces,
                enters_tapped: landEntersTapped(d.meta)
            });
        });
        activeList.forEach(function(c) {
            if (optimizerResult.basics[c] > 0) {
                spec.lands.push({ name: basicLandName(c), qty: optimizerResult.basics[c], produces: [c], enters_tapped: false });
            }
        });
        if (optimizerResult.colorlessLands > 0) {
            spec.lands.push({ name: 'Utility Land', qty: optimizerResult.colorlessLands, produces: [], enters_tapped: false });
        }
    } else {
        // Manual mode without optimizer: synthesize virtual deck
        var activeList2 = COLORS.filter(function(c) { return state.activeColors.has(c) && state.pips[c] > 0; });
        var totalPipCount2 = 0;
        activeList2.forEach(function(c) { totalPipCount2 += state.pips[c]; });

        for (var mv2 = 1; mv2 <= 7; mv2++) {
            var spellCount2 = state.curve[mv2] || 0;
            if (spellCount2 <= 0) continue;
            var virtualPips2 = {};
            activeList2.forEach(function(c) {
                if (totalPipCount2 > 0) {
                    virtualPips2[c] = Math.min(mv2, Math.round(state.pips[c] / totalPipCount2 * Math.min(mv2, 2)));
                } else {
                    virtualPips2[c] = 0;
                }
            });
            var pipSum2 = 0;
            for (var c2 in virtualPips2) pipSum2 += virtualPips2[c2];
            if (pipSum2 === 0 && activeList2.length > 0) virtualPips2[activeList2[0]] = 1;
            spec.spells.push({ name: mv2 + '-drop', qty: spellCount2, mv: mv2, pips: virtualPips2 });
        }
        if (state.curve[0] > 0) {
            spec.spells.push({ name: '0-drop', qty: state.curve[0], mv: 0, pips: { W:0, U:0, B:0, R:0, G:0 } });
        }

        var totalLands = state.totalLands;
        activeList2.forEach(function(c) {
            var count = Math.round(totalLands * (state.pips[c] / Math.max(1, totalPipCount2)));
            if (count > 0) {
                spec.lands.push({ name: basicLandName(c), qty: count, produces: [c], enters_tapped: false });
            }
        });
        var assignedLands = spec.lands.reduce(function(s, l) { return s + l.qty; }, 0);
        var remaining = totalLands - assignedLands;
        if (remaining > 0) {
            spec.lands.push({ name: 'Utility Land', qty: remaining, produces: [], enters_tapped: false });
        }
    }

    return spec;
}

function launchSimulation(activeList, recommended, optimizerResult) {
    if (!simWorker || simWorkerFailed) return;

    var deckSpec = buildDeckSpec(optimizerResult);

    // If deck spec is too small, skip simulation
    var totalCards = 0;
    deckSpec.spells.forEach(function(s) { totalCards += s.qty; });
    deckSpec.lands.forEach(function(l) { totalCards += l.qty; });
    if (totalCards < 10) return;

    simWorker.onmessage = function(e) {
        if (e.data.type === 'progress') {
            var pct = Math.round((e.data.iteration / e.data.total) * 100);
            var bar = document.getElementById('simProgressBar');
            var text = document.getElementById('simProgressText');
            if (bar) bar.style.width = pct + '%';
            if (text) text.textContent = 'Simulating... ' + e.data.iteration.toLocaleString() + ' / ' + e.data.total.toLocaleString() + ' games';
        } else if (e.data.type === 'complete') {
            state.simResults = e.data.results;
            renderSimResults(e.data.results, activeList, recommended);
        } else if (e.data.type === 'error') {
            console.warn('Sim worker error:', e.data.message);
            if (simEngine === 'wasm') {
                simWorker.terminate(); simWorker = null;
                initJSWorker();
                if (simWorker && !simWorkerFailed) {
                    launchSimulation(activeList, recommended);
                }
            }
        }
    };

    simWorker.postMessage({
        type: 'simulate',
        deck: deckSpec,
        params: { iterations: 50000, progressInterval: 5000 }
    });
}

function renderSimResults(results, activeList, recommended) {
    var container = document.getElementById('simResultsContainer');
    var progress = document.getElementById('simProgress');
    if (!container) return;
    if (progress) progress.style.display = 'none';

    var html = '';

    // Summary
    var overallHits = 0, overallTrials = 0;
    results.perCard.forEach(function(card) {
        if (card.mv >= 1 && card.mv <= 7) {
            overallHits += card.castRate;
            overallTrials++;
        }
    });
    var overallRate = overallTrials > 0 ? (overallHits / overallTrials * 100).toFixed(1) : '0.0';
    var engineLabel = (results.engine === 'wasm') ? 'WASM' : 'JS';
    var elapsedStr = results.elapsed < 1000 ? results.elapsed + 'ms' : (results.elapsed / 1000).toFixed(1) + 's';
    html += '<div class="sim-summary">Simulated ' + results.iterations.toLocaleString() + ' games in ' + elapsedStr + ' <span class="sim-engine-badge sim-engine-' + engineLabel.toLowerCase() + '">' + engineLabel + '</span> &mdash; Overall on-curve castability (lands only): <strong>' + overallRate + '%</strong></div>';

    // Cast rate table
    if (state.mode === 'imported' && state.cards) {
        // Per-card table
        html += '<div class="prob-table-wrapper"><table class="prob-table">';
        html += '<thead><tr><th style="text-align:left;">Card</th><th>Cost</th><th>Turn</th><th>Cast Rate (Lands Only)</th></tr></thead><tbody>';
        results.perCard.forEach(function(card) {
            if (card.mv < 1) return;
            var pctVal = card.castRate * 100;
            var pctStr;
            if (card.castRate > 0 && pctVal < 1.0) {
                pctStr = '&lt;1%';
            } else {
                pctStr = pctVal.toFixed(1) + '%';
            }
            var cls = card.castRate >= 0.9 ? 'prob-good' : (card.castRate >= 0.8 ? 'prob-ok' : 'prob-bad');
            var icon = card.castRate >= 0.9 ? ' &#10003;' : (card.castRate < 0.8 ? ' &#10007;' : '');
            html += '<tr>';
            html += '<td class="turn-col" style="text-align:left;"><span class="card-name-link" data-card="' + card.name + '">' + card.name + '</span></td>';
            html += '<td class="cast-mana">' + formatPips(card.pips) + '</td>';
            html += '<td>' + card.mv + '</td>';
            html += '<td class="' + cls + '">' + pctStr + icon + '</td>';
            html += '</tr>';
        });
        html += '</tbody></table></div>';
        if (state.cards) {
            var _rampCtx = analyzeDeckContext(state.cards);
            if (_rampCtx.rampCount > 0) {
                html += '<div style="color:var(--text-muted);font-size:0.72rem;margin-top:0.5rem;padding:0 0.5rem;">';
                html += '* Rates reflect land-based mana only. With ' + _rampCtx.rampCount +
                        ' ramp piece' + (_rampCtx.rampCount !== 1 ? 's' : '') +
                        ' in your deck, actual castability will be higher.';
                html += '</div>';
            }
        }
    } else {
        // Manual mode: per-color benchmark table
        html += '<div class="prob-table-wrapper"><table class="prob-table">';
        html += '<thead><tr><th style="text-align:left;">Color</th><th>Hardest Requirement</th><th>Turn</th><th>Cast Rate (Lands Only)</th></tr></thead><tbody>';
        activeList.forEach(function(c) {
            // Find the matching virtual spell for this color
            var bestCard = null;
            results.perCard.forEach(function(card) {
                if (card.pips[c] > 0 && card.mv >= 1) {
                    if (!bestCard || card.pips[c] > bestCard.pips[c] || (card.pips[c] === bestCard.pips[c] && card.mv < bestCard.mv)) {
                        bestCard = card;
                    }
                }
            });
            if (!bestCard) return;
            var pctStr = (bestCard.castRate * 100).toFixed(1) + '%';
            var cls = bestCard.castRate >= 0.9 ? 'prob-good' : (bestCard.castRate >= 0.8 ? 'prob-ok' : 'prob-bad');
            var pipDesc = '{' + c + '}'.repeat(bestCard.pips[c]) + ' spell';
            html += '<tr>';
            html += '<td class="turn-col" style="text-align:left;color:' + COLOR_HEX[c] + ';">' + COLOR_NAMES[c] + '</td>';
            html += '<td class="cast-mana">' + pipDesc + '</td>';
            html += '<td>' + bestCard.mv + '</td>';
            html += '<td class="' + cls + '">' + pctStr + '</td>';
            html += '</tr>';
        });
        html += '</tbody></table></div>';
    }

    container.innerHTML = html;
}

function formatPips(pips) {
    var s = '';
    COLORS.forEach(function(c) {
        for (var i = 0; i < (pips[c] || 0); i++) {
            s += '{' + c + '}';
        }
    });
    return s || '{C}';
}

function renderFallbackProbTable(activeList, recommended) {
    // Hypergeometric fallback when worker is unavailable
    var html = '<div class="prob-table-wrapper"><table class="prob-table">';
    html += '<thead><tr><th>Turn</th>';
    activeList.forEach(function(c) {
        html += '<th style="color:' + COLOR_HEX[c] + '">' + COLOR_NAMES[c] + ' (' + recommended[c] + ')</th>';
    });
    html += '</tr></thead><tbody>';

    for (var turn = 1; turn <= 7; turn++) {
        var cardsDrawn = 6 + turn;
        html += '<tr><td class="turn-col">Turn ' + turn + ' (' + cardsDrawn + ' cards)</td>';
        activeList.forEach(function(c) {
            var needed = 1; // need at least 1 source of this color by each turn
            var demand = findMostDemandingCard(c, state.cards);
            if (demand && turn >= demand.turn) needed = demand.pips;
            var prob = hypergeometricCDF_atLeast(needed, state.deckSize, recommended[c], cardsDrawn);
            var pctStr = (prob * 100).toFixed(1) + '%';
            var cls = prob >= 0.9 ? 'prob-good' : (prob >= 0.7 ? 'prob-ok' : 'prob-bad');
            html += '<td class="' + cls + '">' + pctStr + '</td>';
        });
        html += '</tr>';
    }
    html += '</tbody></table></div>';
    return html;
}

function basicLandName(c) {
    var names = { W: 'Plains', U: 'Island', B: 'Swamp', R: 'Mountain', G: 'Forest' };
    return names[c] || 'Basic Land';
}

function getColorPair(c1, c2) {
    // Return canonical pair ordering (WUBRG order)
    var order = 'WUBRG';
    if (order.indexOf(c1) < order.indexOf(c2)) return c1 + c2;
    return c2 + c1;
}

function computeFetchEffectiveColors(fetchPair, activeColors, allocation) {
    // Given a fetch land's printed color pair (e.g. "WB" for Marsh Flats),
    // compute which active colors it can effectively produce given current allocation.
    // A fetch finds lands with basic land types matching its pair colors.
    var fetchType1 = COLOR_TO_BASIC_TYPE[fetchPair[0]]; // e.g. Plains
    var fetchType2 = COLOR_TO_BASIC_TYPE[fetchPair[1]]; // e.g. Swamp
    var effectiveSet = {};

    // 1. Check basics: if any active-color basic is fetchable
    for (var i = 0; i < activeColors.length; i++) {
        var c = activeColors[i];
        var basicType = COLOR_TO_BASIC_TYPE[c];
        if ((basicType === fetchType1 || basicType === fetchType2) && (allocation.basics[c] || 0) > 0) {
            effectiveSet[c] = true;
        }
    }

    // 2. Check allocated fetchable duals (shocks, surveil lands, original duals, etc.)
    if (allocation.duals) {
        for (var d = 0; d < allocation.duals.length; d++) {
            var dual = allocation.duals[d];
            if (dual.isFlex) continue; // flex lands don't have basic land types
            var dMeta = dual.meta;
            if (!dMeta || !dMeta.fetchable) continue;
            // This dual has basic land types matching its pair
            var dType1 = COLOR_TO_BASIC_TYPE[dual.pair[0]];
            var dType2 = COLOR_TO_BASIC_TYPE[dual.pair[1]];
            // Can the fetch find this dual? (shares a basic land type)
            if (fetchType1 === dType1 || fetchType1 === dType2 ||
                fetchType2 === dType1 || fetchType2 === dType2) {
                // This dual's active colors are now effective
                if (activeColors.indexOf(dual.pair[0]) >= 0) effectiveSet[dual.pair[0]] = true;
                if (activeColors.indexOf(dual.pair[1]) >= 0) effectiveSet[dual.pair[1]] = true;
            }
        }
    }

    return Object.keys(effectiveSet);
}

function buildDualSuggestions(activeList, recommended, colorlessLands) {
    var html = '';
    var pairs = [];
    var formatKey = state.format;
    var cycleKeys = FORMAT_CYCLE_KEYS[formatKey] || FORMAT_CYCLE_KEYS['custom'];

    // Generate all color pairs
    for (var i = 0; i < activeList.length; i++) {
        for (var j = i + 1; j < activeList.length; j++) {
            pairs.push(getColorPair(activeList[i], activeList[j]));
        }
    }

    // Find available lands per pair from format's cycles
    var availableLands = {}; // pair -> [{cycle, name, tier}]
    pairs.forEach(function(pair) { availableLands[pair] = []; });

    cycleKeys.forEach(function(key) {
        var cycle = LAND_CYCLES[key];
        if (!cycle) return;
        pairs.forEach(function(pair) {
            var cardName = cycle.cards[pair];
            if (cardName) {
                availableLands[pair].push({ cycle: cycle.name, name: cardName, tier: cycle.tier, desc: cycle.desc });
            }
        });
    });

    // Flexible fixing sections — split into unconditional and conditional
    var flexKeysForSuggest = FLEXIBLE_LAND_FORMATS[formatKey] || [];
    if (flexKeysForSuggest.length > 0 && activeList.length >= 2) {
        var unconditionalFlex = [];
        var conditionalFlex = [];
        var isCommanderFormat = (formatKey === 'commander');
        flexKeysForSuggest.forEach(function(fKey) {
            var flex = FLEXIBLE_LANDS[fKey];
            if (!flex) return;
            var cond = flex.condition || null;
            // Commander-condition lands are useless outside Commander (no commander = no mana)
            if (cond === 'commander' && !isCommanderFormat) return;
            if (!cond || cond === 'turnGated' || (cond === 'commander' && isCommanderFormat)) {
                unconditionalFlex.push(fKey);
            } else {
                conditionalFlex.push(fKey);
            }
        });

        if (unconditionalFlex.length > 0) {
            html += '<div class="suggest-card">';
            html += '<h4>Premium Fixing \u2014 Any Color</h4>';
            unconditionalFlex.forEach(function(fKey) {
                var flex = FLEXIBLE_LANDS[fKey];
                var tierLabel = flex.tier === 1 ? 'Premium' : 'Good';
                var tierColor = flex.tier === 1 ? '#4ade80' : '#facc15';
                html += '<span class="suggest-land" style="justify-content:space-between;width:100%;">';
                html += '<span><strong class="card-name-link" data-card="' + flex.name + '">' + flex.name + '</strong> <span style="color:var(--text-muted);font-size:0.65rem;">(' + flex.desc + ')</span></span>';
                html += '<span style="color:' + tierColor + ';font-size:0.65rem;font-weight:600;">' + tierLabel + '</span>';
                html += '</span>';
            });
            html += '</div>';
        }

        if (conditionalFlex.length > 0) {
            // Compute effectiveness for display — only show lands that are actually useful
            var deckAnalysis = (state.mode === 'imported' && state.cards) ? analyzeDeckContext(state.cards) : analyzeDeckContext(null);
            deckAnalysis.isCommander = (state.format === 'commander');
            // Filter: in import mode, only show lands with >0% effectiveness
            // In manual mode, hide conditional lands entirely (no deck data to evaluate)
            var visibleConditional = conditionalFlex.filter(function(fKey) {
                if (state.mode !== 'imported') return false;
                var eff = flexLandEffectiveness(fKey, deckAnalysis);
                return eff >= 0.15; // 15% minimum — below that, too situational
            });
            if (visibleConditional.length > 0) {
                html += '<div class="suggest-card">';
                html += '<h4>Conditional Fixing \u2014 Deck-Dependent</h4>';
                visibleConditional.forEach(function(fKey) {
                    var flex = FLEXIBLE_LANDS[fKey];
                    var eff = flexLandEffectiveness(fKey, deckAnalysis);
                    var effPct = Math.round(eff * 100);
                    var effColor = effPct >= 60 ? '#4ade80' : (effPct > 0 ? '#facc15' : '#71717a');
                    html += '<span class="suggest-land" style="justify-content:space-between;width:100%;">';
                    html += '<span><strong class="card-name-link" data-card="' + flex.name + '">' + flex.name + '</strong> <span style="color:var(--text-muted);font-size:0.65rem;">(' + flex.desc + ')</span></span>';
                    html += '<span style="color:' + effColor + ';font-size:0.65rem;font-weight:600;">' + effPct + '% effective</span>';
                    html += '</span>';
                });
                html += '<p style="color:var(--text-muted);font-size:0.6rem;margin-top:0.3rem;">These lands only fix mana for specific spell types. Effectiveness is based on your deck composition.</p>';
                html += '</div>';
            }
        }
    }

    // Build suggestion: list all available dual lands per color pair
    html += '<div class="suggest-card">';
    html += '<h4>Available Dual Lands (' + formatKey.charAt(0).toUpperCase() + formatKey.slice(1) + ')</h4>';
    html += '<p>All dual land options for your color combination in this format, ordered by competitive tier.</p>';
    html += '</div>';

    pairs.forEach(function(pair) {
        var c1 = pair[0], c2 = pair[1];
        var lands = availableLands[pair];
        if (lands.length === 0) return;

        html += '<div class="suggest-card">';
        html += '<h4 style="display:flex;align-items:center;gap:0.5rem;">';
        html += '<span class="pip-color-dot" style="width:20px;height:20px;font-size:0.55rem;background:' + COLOR_HEX[c1] + ';color:' + COLOR_TEXT[c1] + (c1==='B'?';border:1px solid rgba(255,255,255,0.2)':'') + '">' + c1 + '</span>';
        html += '<span class="pip-color-dot" style="width:20px;height:20px;font-size:0.55rem;background:' + COLOR_HEX[c2] + ';color:' + COLOR_TEXT[c2] + (c2==='B'?';border:1px solid rgba(255,255,255,0.2)':'') + '">' + c2 + '</span>';
        html += ' ' + COLOR_NAMES[c1] + ' / ' + COLOR_NAMES[c2] + ' (' + lands.length + ' options)';
        html += '</h4>';
        html += '<div class="suggest-lands" style="flex-direction:column;gap:0.3rem;">';

        lands.forEach(function(land) {
            var tierLabel = land.tier === 1 ? 'Premium' : (land.tier === 2 ? 'Good' : 'Budget');
            var tierColor = land.tier === 1 ? '#4ade80' : (land.tier === 2 ? '#facc15' : '#71717a');
            html += '<span class="suggest-land" style="justify-content:space-between;width:100%;">';
            html += '<span><strong class="card-name-link" data-card="' + land.name + '">' + land.name + '</strong> <span style="color:var(--text-muted);font-size:0.65rem;">(' + land.cycle + ')</span></span>';
            html += '<span style="color:' + tierColor + ';font-size:0.65rem;font-weight:600;">' + tierLabel + '</span>';
            html += '</span>';
        });
        html += '</div></div>';
    });

    // Triomes for 3+ color decks
    if (activeList.length >= 3 && (formatKey === 'pioneer' || formatKey === 'modern' || formatKey === 'legacy' || formatKey === 'commander')) {
        html += '<div class="suggest-card">';
        html += '<h4>Consider Triomes</h4>';
        html += '<p>With ' + activeList.length + ' colors, Triomes (3-color lands from Ikoria/Streets of New Capenna) provide excellent fixing. They are fetchable and provide three colors, at the cost of always entering tapped.</p>';
        html += '</div>';
    }

    // Commander special
    if (formatKey === 'commander' && activeList.length >= 2) {
        html += '<div class="suggest-card">';
        html += '<h4>Commander Staples</h4>';
        html += '<p>Don\'t forget Commander-specific lands that provide all your colors:</p>';
        html += '<div class="suggest-lands">';
        html += '<span class="suggest-land"><span class="sl-count">1</span> <span class="card-name-link" data-card="Command Tower">Command Tower</span></span>';
        html += '<span class="suggest-land"><span class="sl-count">1</span> <span class="card-name-link" data-card="Exotic Orchard">Exotic Orchard</span></span>';
        html += '<span class="suggest-land"><span class="sl-count">1</span> <span class="card-name-link" data-card="Path of Ancestry">Path of Ancestry</span></span>';
        if (activeList.length >= 3) {
            html += '<span class="suggest-land"><span class="sl-count">1</span> <span class="card-name-link" data-card="Chromatic Lantern">Chromatic Lantern</span> (mana rock)</span>';
        }
        html += '</div></div>';
    }

    return html;
}

function showEmptyResults(msg) {
    document.getElementById('resultsContent').innerHTML = '<div class="results-empty"><div class="empty-icon">&#127183;</div><p>' + msg + '</p></div>';
}

// ══════════════════════════════════════════
// Decklist Import
// ══════════════════════════════════════════

function switchTab(tab) {
    var tabs = document.querySelectorAll('.input-tab');
    tabs.forEach(function(t) {
        t.classList.toggle('active', t.dataset.tab === tab);
    });
    document.getElementById('manualPanel').classList.toggle('active', tab === 'manual');
    document.getElementById('importPanel').classList.toggle('active', tab === 'import');
}

function setImportStatus(msg, type) {
    var el = document.getElementById('importStatus');
    el.className = 'import-status visible ' + type;
    el.innerHTML = msg;
}

function hideImportStatus() {
    var el = document.getElementById('importStatus');
    el.className = 'import-status';
    el.innerHTML = '';
}

function parseDecklist(text) {
    // Normalize: split lines where multiple cards are crammed on one line
    // e.g. "[CREATURES] 1 Accursed Marauder 1 Avenger of Zendikar" or
    // "1 Lightning Bolt 1 Mountain" → separate lines per card
    // Split on: letter/bracket/apostrophe followed by space(s) then qty+space+letter
    // Avoids splitting set code contexts like "(M10) 123" or "(SLD) 1155 *F*"
    text = text.replace(/([a-zA-Z\u00C0-\u024F*\]']) +(\d+ +[a-zA-Z\u00C0-\u024F])/g, '$1\n$2');
    var lines = text.split('\n');
    var cards = [];
    var lineRe = /^\s*(\d+)x?\s+(.+?)(?:\s+\(([A-Z0-9]+)\)(?:\s*(\S+).*)?)?$/;
    var sideboardRe = /^\s*(Sideboard|SB:|Companion|Maybeboard)/i;
    var skipRe = /^\s*(\/\/|Commander|Deck)/i;
    var sectionRe = /^\s*\[.+\]\s*$/;
    var hasSections = /^\s*\[.+\]\s*$/m.test(text);
    var startedParsing = false;
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i].trim();
        // Sideboard header = stop parsing
        if (sideboardRe.test(line)) break;
        // Blank line after we've started = sideboard separator (MTGA format)
        // But NOT if the list uses [SECTION] headers (e.g. Archidekt, Moxfield)
        if (!line) {
            if (startedParsing && !hasSections) break;
            continue;
        }
        // Skip comment, section header, and bracketed category lines
        if (skipRe.test(line) || sectionRe.test(line)) continue;
        var m = line.match(lineRe);
        if (m) {
            startedParsing = true;
            var qty = parseInt(m[1]);
            var name = m[2].trim();
            // Handle split/MDFC — use front face (exports use " // " or " / ")
            var slashIdx = name.indexOf(' // ');
            if (slashIdx < 0) slashIdx = name.indexOf(' / ');
            if (slashIdx > 0) name = name.substring(0, slashIdx);
            var setCode = m[3] || null;
            var collectorNum = m[4] || null;
            cards.push({ qty: qty, name: name, setCode: setCode, collectorNum: collectorNum });
        }
    }
    // Deduplicate by name
    var deduped = {};
    cards.forEach(function(c) {
        var key = c.name.toLowerCase();
        if (deduped[key]) {
            deduped[key].qty += c.qty;
        } else {
            deduped[key] = { qty: c.qty, name: c.name, setCode: c.setCode, collectorNum: c.collectorNum };
        }
    });
    return Object.values(deduped);
}

function parseManaCost(costStr) {
    // Parse Scryfall mana_cost string like "{1}{W}{U}" or "{2}{R}{R}"
    var pips = { W: 0, U: 0, B: 0, R: 0, G: 0 };
    var mv = 0;
    if (!costStr) return { pips: pips, mv: mv };
    var symbolRe = /\{([^}]+)\}/g;
    var match;
    while ((match = symbolRe.exec(costStr)) !== null) {
        var sym = match[1];
        if (sym === 'X') {
            // X costs = 0 for MV
            continue;
        } else if (/^\d+$/.test(sym)) {
            // Generic mana
            mv += parseInt(sym);
        } else if (/^[WUBRG]$/.test(sym)) {
            // Single colored pip
            pips[sym]++;
            mv++;
        } else if (/^[WUBRG]\/P$/.test(sym)) {
            // Phyrexian pip — count as the color
            pips[sym[0]]++;
            mv++;
        } else if (/^[WUBRG]\/[WUBRG]$/.test(sym)) {
            // Hybrid pip — need a source of either color, count 1 for each
            pips[sym[0]]++;
            pips[sym[2]]++;
            mv++;
        } else if (/^2\/[WUBRG]$/.test(sym)) {
            // Twobrid — count as the color
            pips[sym[2]]++;
            mv += 2;
        } else {
            // Snow, colorless pips, etc. — just add to MV
            mv++;
        }
    }
    return { pips: pips, mv: mv };
}

async function lookupCards(cards) {
    // Build lookup for set+collector fallback
    var cardsByName = {};
    cards.forEach(function(c) { cardsByName[c.name.toLowerCase()] = c; });

    // Split into batches of 75
    var batches = [];
    for (var i = 0; i < cards.length; i += 75) {
        batches.push(cards.slice(i, i + 75));
    }
    var allFound = [];
    var notFound = [];
    for (var b = 0; b < batches.length; b++) {
        if (b > 0) {
            // Respect Scryfall rate limit
            await new Promise(function(r) { setTimeout(r, 100); });
        }
        var identifiers = batches[b].map(function(c) { return { name: c.name }; });
        var resp = await fetch('https://api.scryfall.com/cards/collection', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ identifiers: identifiers })
        });
        if (!resp.ok) {
            throw new Error('Scryfall API returned ' + resp.status);
        }
        var data = await resp.json();
        if (data.data) allFound = allFound.concat(data.data);
        if (data.not_found) notFound = notFound.concat(data.not_found);
    }

    // Fallback: retry not-found cards using set + collector_number
    if (notFound.length > 0) {
        var retryIds = [];
        notFound.forEach(function(nf) {
            var orig = cardsByName[(nf.name || '').toLowerCase()];
            if (orig && orig.setCode && orig.collectorNum) {
                retryIds.push({ set: orig.setCode.toLowerCase(), collector_number: orig.collectorNum });
            }
        });
        if (retryIds.length > 0) {
            await new Promise(function(r) { setTimeout(r, 100); });
            var resp2 = await fetch('https://api.scryfall.com/cards/collection', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ identifiers: retryIds })
            });
            if (resp2.ok) {
                var data2 = await resp2.json();
                if (data2.data && data2.data.length > 0) {
                    allFound = allFound.concat(data2.data);
                    // Remove successfully retried cards from notFound
                    var retriedNames = new Set(data2.data.map(function(c) { return c.name.toLowerCase(); }));
                    var retriedSets = new Set(data2.data.map(function(c) { return c.set + ':' + c.collector_number; }));
                    notFound = notFound.filter(function(nf) {
                        var orig = cardsByName[(nf.name || '').toLowerCase()];
                        if (orig && orig.setCode && orig.collectorNum) {
                            return !retriedSets.has(orig.setCode.toLowerCase() + ':' + orig.collectorNum);
                        }
                        return true;
                    });
                }
            }
        }
    }

    return { found: allFound, notFound: notFound };
}

function autoDetectFormat(deckSize) {
    if (deckSize === 40) return 'limited';
    if (deckSize >= 98 && deckSize <= 101) return 'commander';
    return null; // user selects for 60-card
}

function updateUIFromState() {
    // Update deck size and total lands inputs
    document.getElementById('deckSize').value = state.deckSize;
    document.getElementById('totalLands').value = state.totalLands;

    // Update format buttons
    var detectedFormat = autoDetectFormat(state.deckSize);
    if (detectedFormat) {
        state.format = detectedFormat;
        var btns = document.querySelectorAll('.format-btn');
        btns.forEach(function(b) {
            b.classList.toggle('active', b.dataset.format === detectedFormat);
        });
    }

    // Update color toggles
    var toggles = document.querySelectorAll('.color-toggle');
    toggles.forEach(function(t) {
        var c = t.dataset.color;
        t.classList.toggle('active', state.activeColors.has(c));
    });

    // Rebuild pip inputs
    renderPipInputs();

    // Update curve inputs
    var curveInputs = document.querySelectorAll('#curveInputs input');
    curveInputs.forEach(function(inp) {
        var mv = parseInt(inp.dataset.mv);
        inp.value = state.curve[mv] || 0;
    });

    updateCurveTotal();
}

// Classify a non-land card's ramp type from Scryfall data
// Returns { rampType, rampColors, isCheapDraw }
function classifyRamp(frontTypeLine, isArtifact, mainMV, producedMana, oracleText) {
    var rampType = null;
    var rampColors = [];
    var isCreature = /\bCreature\b/i.test(frontTypeLine);

    // Pre-checks for exclusions and sub-classifications
    var isETBMana = /\bwhen\b.+\benters?\b/i.test(oracleText) && producedMana && producedMana.length > 0;
    var isExileFromHand = /\bexile\b.+\bfrom\b.+\bhand\b/i.test(oracleText);
    var createsTreasure = /\bcreate\b.+\btreasure\b|\btreasure token\b/i.test(oracleText);
    var isSacrificeOutlet = /\bsacrifice a creature\b|\bsacrifice a permanent\b/i.test(oracleText);
    // One-shot mana filter: sacrifice is part of the mana ability ("{T}, Sacrifice: Add...")
    // Excludes rocks with optional sac for other effects (Commander's Sphere: "Sacrifice: Draw")
    var isOneShotArtifact = isArtifact && /sacrifice[^.]*\badd\b/i.test(oracleText) && producedMana && producedMana.length > 0;

    // Classification priority (most specific first):
    // 1. MV 0 fast mana — split repeatable vs one-shot
    if (mainMV === 0 && producedMana && producedMana.length > 0) {
        if (/\bsacrifice\b/i.test(oracleText)) {
            rampType = 'fastOneShot'; // Lotus Petal, Lion's Eye Diamond
        } else {
            rampType = 'fast'; // Mox Diamond, Mana Crypt, Chrome Mox
        }
    }
    // 2. Treasure creators (before creature/artifact checks so Dockside hits here)
    else if (createsTreasure && !isSacrificeOutlet) {
        rampType = 'treasure';
    }
    // 3. Creature mana producers (dorks) — with exclusions
    else if (isCreature && producedMana && producedMana.length > 0) {
        if (isExileFromHand) {
            rampType = 'fastOneShot'; // Simian/Elvish Spirit Guide
        } else if (isETBMana && !/\{T\}.*\badd\b/i.test(oracleText)) {
            // ETB-only mana (Burning-Tree Emissary, Priest of Gix)
            // Only flag as ETB if there's no separate tap-for-mana ability
            rampType = 'etbMana';
        } else {
            rampType = 'dork'; // Birds of Paradise, Llanowar Elves, Bloom Tender
        }
    }
    // 4. Artifact mana producers (rocks) — with exclusions
    else if (isArtifact && producedMana && producedMana.length > 0) {
        if (isSacrificeOutlet) {
            rampType = null; // Phyrexian Altar, Ashnod's Altar — combo pieces, not ramp
        } else if (isOneShotArtifact) {
            rampType = null; // Chromatic Star/Sphere — mana filters, net negative
        } else {
            rampType = 'rock'; // Sol Ring, Arcane Signet, Commander's Sphere
        }
    }
    // 5. Land ramp (search YOUR library for a land/Forest/etc. + onto battlefield)
    else if (/search your library.+(?:land|forest|plains|island|swamp|mountain).+onto the battlefield|put.+land.+onto the battlefield/i.test(oracleText)) {
        rampType = 'landRamp';
    }
    // 6. Extra land drop effects (Exploration, Azusa, Oracle of Mul Daya)
    else if (/\badditional lands?\b/i.test(oracleText)) {
        rampType = 'extraLand';
    }

    if (rampType && producedMana) {
        rampColors = producedMana.filter(function(m) { return 'WUBRG'.indexOf(m) >= 0 || m === 'C'; });
        if (rampColors.length === 0 && producedMana.length > 0) {
            rampColors = ['any'];
        }
    } else if (rampType === 'landRamp' || rampType === 'treasure' || rampType === 'extraLand') {
        rampColors = ['any'];
    }

    // Detect cheap card draw (MV <= 2, not ramp, draws cards)
    var isCheapDraw = false;
    if (!rampType && mainMV <= 2 && mainMV > 0) {
        isCheapDraw = /draw.+card|look at the top/i.test(oracleText);
    }

    return { rampType: rampType, rampColors: rampColors, isCheapDraw: isCheapDraw };
}

async function importDecklist() {
    var textarea = document.getElementById('decklistInput');
    var text = textarea.value.trim();

    if (!text) {
        setImportStatus('Paste a decklist to import.', 'error');
        return;
    }

    hideImportStatus();

    // Step 1: Parse
    var cards = parseDecklist(text);
    if (cards.length === 0) {
        setImportStatus('No valid card lines found. Use format: <strong>4 Card Name</strong>', 'error');
        return;
    }

    var totalCards = cards.reduce(function(s, c) { return s + c.qty; }, 0);
    setImportStatus('<span class="import-spinner"></span> Parsed ' + cards.length + ' unique cards (' + totalCards + ' total). Looking up card data...', 'loading');

    // Step 2: Scryfall lookup
    var result;
    try {
        result = await lookupCards(cards);
    } catch (e) {
        setImportStatus('Could not reach Scryfall API. Check your connection.', 'error');
        return;
    }

    // Build a lookup map: lowercase name -> scryfall card object
    // Also index by set:collector for Secret Lair reskins where names differ
    var cardMap = {};
    var setCollectorMap = {};
    result.found.forEach(function(card) {
        cardMap[card.name.toLowerCase()] = card;
        // Also index front face for MDFCs/split cards (Scryfall returns "Front // Back")
        var dblSlash = card.name.indexOf(' // ');
        if (dblSlash > 0) {
            cardMap[card.name.substring(0, dblSlash).toLowerCase()] = card;
        }
        if (card.set && card.collector_number) {
            setCollectorMap[card.set + ':' + card.collector_number] = card;
        }
    });

    // Step 3: Process results — build per-card data AND aggregate state
    var totalPips = { W: 0, U: 0, B: 0, R: 0, G: 0 };
    var curve = [0, 0, 0, 0, 0, 0, 0, 0]; // MV 0-7+
    var totalLands = 0;
    var totalSpells = 0;
    var colorsFound = new Set();
    var perCardData = []; // [{name, qty, mv, pips, isLand, producesColors}]

    cards.forEach(function(c) {
        var scryfallCard = cardMap[c.name.toLowerCase()];
        // Fallback: match by set + collector number (handles Secret Lair reskins)
        if (!scryfallCard && c.setCode && c.collectorNum) {
            scryfallCard = setCollectorMap[c.setCode.toLowerCase() + ':' + c.collectorNum];
        }
        if (!scryfallCard) return;

        var typeLine = scryfallCard.type_line || '';
        var frontTypeLine = typeLine.split('//')[0].trim();
        var isLegendary = /\bLegendary\b/i.test(frontTypeLine);
        var isArtifact = /\bArtifact\b/i.test(frontTypeLine);
        var creatureTypes = [];
        if (/\bCreature\b/i.test(frontTypeLine)) {
            var dashIdx = frontTypeLine.indexOf('\u2014');
            if (dashIdx >= 0) {
                creatureTypes = frontTypeLine.substring(dashIdx + 1).trim().split(/\s+/).filter(function(t) { return t.length > 0; });
            }
        }

        if (/\bLand\b/i.test(typeLine)) {
            totalLands += c.qty;
            var producesColors = [];
            if (scryfallCard.produced_mana) {
                producesColors = scryfallCard.produced_mana.filter(function(m) { return 'WUBRG'.indexOf(m) >= 0; });
            }
            perCardData.push({ name: scryfallCard.name, qty: c.qty, mv: 0, pips: { W:0, U:0, B:0, R:0, G:0 }, isLand: true, producesColors: producesColors, isLegendary: isLegendary, isArtifact: isArtifact, isMulticolor: false, creatureTypes: creatureTypes, isEnchantment: /\bEnchantment\b/i.test(frontTypeLine), isInstantSorcery: /\b(?:Instant|Sorcery)\b/i.test(frontTypeLine) });
            return;
        }

        // Get mana costs — handle adventures, split cards, and MDFCs
        var layout = scryfallCard.layout || '';
        var faces = scryfallCard.card_faces || [];

        // For multi-face cards, always use individual faces to avoid double-counting
        // Top-level mana_cost on adventures/splits concatenates both faces
        var allPips = { W: 0, U: 0, B: 0, R: 0, G: 0 };
        var mainMV = 0;

        if ((layout === 'adventure' || layout === 'split') && faces.length > 1) {
            // Count pips from all faces, use front face MV for curve
            faces.forEach(function(face, idx) {
                var parsed = parseManaCost(face.mana_cost || '');
                COLORS.forEach(function(col) { allPips[col] += parsed.pips[col]; });
                if (idx === 0) mainMV = parsed.mv;
            });
        } else {
            // Normal cards, MDFCs, transforms — use front face only
            var mainCost = scryfallCard.mana_cost || '';
            if (!mainCost && faces.length > 0) {
                mainCost = faces[0].mana_cost || '';
            }
            var mainParsed = parseManaCost(mainCost);
            allPips = mainParsed.pips;
            mainMV = mainParsed.mv;
        }

        // Compute multicolor: 2+ different colored pips
        var _colorCount = 0;
        COLORS.forEach(function(col) { if (allPips[col] > 0) _colorCount++; });
        var isMulticolor = _colorCount >= 2;

        // Detect ramp and cheap draw via classifyRamp()
        var producedMana = scryfallCard.produced_mana || (faces.length > 0 ? faces[0].produced_mana : null);
        var oracleText = scryfallCard.oracle_text || (faces.length > 0 ? (faces[0].oracle_text || '') : '');
        var rampResult = classifyRamp(frontTypeLine, isArtifact, mainMV, producedMana, oracleText);

        // Build per-card data
        perCardData.push({ name: scryfallCard.name, qty: c.qty, mv: mainMV, pips: Object.assign({}, allPips), isLand: false, producesColors: null, isLegendary: isLegendary, isArtifact: isArtifact, isMulticolor: isMulticolor, creatureTypes: creatureTypes, rampType: rampResult.rampType, rampColors: rampResult.rampColors, isCheapDraw: rampResult.isCheapDraw, isEnchantment: /\bEnchantment\b/i.test(frontTypeLine), isInstantSorcery: /\b(?:Instant|Sorcery)\b/i.test(frontTypeLine) });

        // Accumulate pips * quantity
        COLORS.forEach(function(col) {
            var pipCount = allPips[col] * c.qty;
            totalPips[col] += pipCount;
            if (allPips[col] > 0) colorsFound.add(col);
        });

        // Mana curve — use front face MV, cap at 7
        var mvSlot = Math.min(mainMV, 7);
        curve[mvSlot] += c.qty;
        totalSpells += c.qty;
    });

    // Check edge cases
    if (totalSpells === 0 && totalLands > 0) {
        setImportStatus('Decklist contains only lands. Add some spells!', 'error');
        return;
    }
    if (totalSpells === 0 && totalLands === 0) {
        var nfNames = result.notFound.map(function(nf) { return nf.name || JSON.stringify(nf); });
        setImportStatus('No cards recognized by Scryfall.' + (nfNames.length > 0 ? ' Not found: ' + nfNames.join(', ') : ''), 'error');
        return;
    }

    // Step 4: Populate state
    state.activeColors = colorsFound;
    state.pips = totalPips;
    state.curve = curve;
    state.deckSize = totalSpells + totalLands;
    state.totalLands = totalLands;
    state.mode = 'imported';
    state.cards = perCardData;
    state.simResults = null;

    // Step 5: Update UI
    updateUIFromState();

    // Step 6: Switch to manual tab so user can review
    switchTab('manual');

    // Step 7: Auto-calculate
    calculate(true);

    // Step 8: Show success status (on the import panel for when they switch back)
    var statusMsg = 'Imported ' + totalSpells + ' spells, ' + totalLands + ' lands (' + state.deckSize + ' cards).';
    if (colorsFound.size > 0) {
        statusMsg += ' Colors: ' + Array.from(colorsFound).join('');
    }
    if (result.notFound.length > 0) {
        statusMsg += '<br>Not found (' + result.notFound.length + '): ';
        var nfList = '<ul class="import-notfound">';
        result.notFound.forEach(function(nf) {
            nfList += '<li>' + (nf.name || JSON.stringify(nf)) + '</li>';
        });
        nfList += '</ul>';
        statusMsg += nfList;
        setImportStatus(statusMsg, 'info');
    } else {
        setImportStatus(statusMsg, 'success');
    }
}

// ══════════════════════════════════════════
// Card Image Preview (hover/tap)
// ══════════════════════════════════════════
if (typeof document !== 'undefined' && document.getElementById) (function() {
    var preview = document.getElementById('cardPreview');
    if (!preview || !preview.querySelector) return;
    var previewImg = preview.querySelector('img');
    if (!previewImg) return;
    var hideTimer = null;
    var touchShown = false;
    var isTouchDevice = false;

    function scryfallUrl(name) {
        return 'https://api.scryfall.com/cards/named?exact=' + encodeURIComponent(name) + '&format=image&version=normal';
    }

    function positionPreview(el) {
        var rect = el.getBoundingClientRect();
        var imgW = window.innerWidth <= 768 ? 200 : 240;
        var imgH = imgW * 1.4; // approx card aspect ratio
        var pad = 12;
        var x, y;

        if (window.innerWidth <= 768) {
            // Mobile: center above the element
            x = rect.left + rect.width / 2 - imgW / 2;
            y = rect.top - imgH - pad;
            if (y < 8) y = rect.bottom + pad;
        } else {
            // Desktop: right of the element, fall back to left
            x = rect.right + pad;
            y = rect.top - 20;
            if (x + imgW > window.innerWidth - 8) {
                x = rect.left - imgW - pad;
            }
        }
        // Clamp to viewport
        x = Math.max(8, Math.min(x, window.innerWidth - imgW - 8));
        y = Math.max(8, Math.min(y, window.innerHeight - imgH - 8));

        preview.style.left = x + 'px';
        preview.style.top = y + 'px';
    }

    function showPreview(el) {
        var name = el.getAttribute('data-card');
        if (!name) return;
        if (hideTimer) { clearTimeout(hideTimer); hideTimer = null; }
        previewImg.onload = function() { preview.classList.add('visible'); };
        previewImg.onerror = function() { preview.classList.remove('visible'); previewImg.src = ''; };
        previewImg.src = scryfallUrl(name);
        positionPreview(el);
    }

    function hidePreview() {
        preview.classList.remove('visible');
        hideTimer = setTimeout(function() { previewImg.src = ''; }, 150);
        touchShown = false;
    }

    document.addEventListener('mouseover', function(e) {
        if (isTouchDevice) return;
        var link = e.target.closest('.card-name-link');
        if (link) showPreview(link);
    });

    document.addEventListener('mouseout', function(e) {
        if (isTouchDevice) return;
        var link = e.target.closest('.card-name-link');
        if (link) hidePreview();
    });

    document.addEventListener('touchstart', function(e) {
        isTouchDevice = true;
        var link = e.target.closest('.card-name-link');
        if (link) {
            e.preventDefault();
            if (touchShown && preview.classList.contains('visible')) {
                hidePreview();
            } else {
                showPreview(link);
                touchShown = true;
            }
        } else if (touchShown) {
            hidePreview();
        }
    }, { passive: false });
})();

// ══════════════════════════════════════════
// Init
// ══════════════════════════════════════════
init();
</script>
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebApplication","name":"MTG Mana Calculator","url":"https://scrollvault.net/tools/manabase/","applicationCategory":"UtilitiesApplication","description":"Free MTG mana calculator and manabase tool using Frank Karsten's mana math. Get optimal land counts for Standard, Modern, Pioneer, and Commander with hypergeometric probability.","isPartOf":{"@type":"WebSite","name":"ScrollVault","url":"https://scrollvault.net"}}
</script>
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"FAQPage","mainEntity":[{"@type":"Question","name":"How many lands should I put in my MTG deck?","acceptedAnswer":{"@type":"Answer","text":"For a 60-card deck (Standard, Modern, Pioneer), 23-26 lands is typical depending on your mana curve. Aggro decks run 22-23, midrange runs 24-25, and control runs 25-26. For Commander (99 cards + commander), 35-38 lands is the standard range. Use a manabase calculator based on Frank Karsten's math for precise counts tailored to your specific deck."}},{"@type":"Question","name":"How many lands for a 60-card deck?","acceptedAnswer":{"@type":"Answer","text":"Most competitive 60-card decks play between 22 and 26 lands. The exact number depends on your average mana value (mana curve). Low-curve aggro decks like Mono-Red or Burn can get away with 20-22 lands, especially if they run cheap cantrips. Midrange decks typically want 24 lands, while control and ramp strategies often play 25-27. Enter your mana curve into the calculator for a personalized recommendation."}},{"@type":"Question","name":"How many lands for Commander / EDH?","acceptedAnswer":{"@type":"Answer","text":"Commander decks (99 cards + commander) typically run 35-38 lands. The ratio is slightly different from 60-card formats because of the larger deck size and singleton restriction. Decks with a low mana curve and lots of mana rocks can go as low as 33, while 4+ color decks or landfall strategies may want 38-40. Don't forget to count mana-producing artifacts like Sol Ring and signets when planning your mana base."}},{"@type":"Question","name":"What is Frank Karsten's mana math?","acceptedAnswer":{"@type":"Answer","text":"Frank Karsten's mana math is the gold standard for calculating MTG mana bases. Using hypergeometric probability, Karsten determined exactly how many colored sources you need to cast your spells on curve with approximately 90% consistency. For example, a card costing 1WW in a 60-card deck needs about 18 white sources. His research, published on ChannelFireball, is the foundation used by competitive players and this calculator."}},{"@type":"Question","name":"How many colored sources do I need?","acceptedAnswer":{"@type":"Answer","text":"The number of colored sources depends on how many pips of that color appear in your casting costs and what turn you need them. Karsten's guidelines for a 60-card deck: a single colored pip on turn 1 needs about 14 sources, a single pip on turn 3 needs about 12, and double pips (like 1WW) need about 18 sources. This calculator does the math automatically — just input your colored mana symbols and it computes the sources needed per color."}},{"@type":"Question","name":"What is the 40% rule for lands?","acceptedAnswer":{"@type":"Answer","text":"The 40% rule is a rough guideline that suggests about 40% of your deck should be lands. For a 60-card deck that's 24 lands, and for a 40-card Limited deck that's 16-17 lands. While this rule of thumb works as a starting point, the actual number should depend on your mana curve. Aggressive decks with lots of 1-2 drops can go below 40%, while control decks may want to stay at or above it."}},{"@type":"Question","name":"How do dual lands affect my mana base?","acceptedAnswer":{"@type":"Answer","text":"Dual lands (lands that produce two or more colors) are crucial for multicolor decks because each one counts as a source for every color it produces. A Hallowed Fountain counts as both a white source and a blue source, reducing the total lands you need. Premium duals like shock lands and fetch lands are the most efficient because they enter untapped or have basic land types. This calculator's land suggestions section recommends specific dual land cycles based on your format and colors."}},{"@type":"Question","name":"How many lands for a 3-color Commander deck?","acceptedAnswer":{"@type":"Answer","text":"A three-color Commander deck typically runs 36-38 lands, but the real challenge is the color distribution. Each color needs at least 14-16 sources to reliably cast single-pip spells by turn 3. With three colors, you need heavy investment in multicolor lands: fetch lands, shock lands, triomes, and check lands that produce two of your three colors. Budget options include pain lands, filter lands, and the battlebond lands."}},{"@type":"Question","name":"What is the mana curve and why does it matter for lands?","acceptedAnswer":{"@type":"Answer","text":"The mana curve is the distribution of mana values (casting costs) across your nonland cards. It directly determines how many lands you need: a deck full of 1-2 drops can function on 22 lands, while a deck with lots of 4-6 drops needs 25+. The ideal curve depends on your strategy — aggro decks want a low curve peaking at 1-2, midrange peaks at 2-3, and control wants a flatter distribution with powerful top-end."}},{"@type":"Question","name":"How do I calculate mana for Limited / Draft decks?","acceptedAnswer":{"@type":"Answer","text":"For 40-card Limited decks (Draft and Sealed), the standard is 17 lands. The color split depends on your deck's pip distribution. A mostly-red deck splashing white might run 10 Mountains and 7 Plains, while an even two-color deck wants about 9/8 or 8/9. Use the Limited format preset in this calculator, enter your colored pips from your drafted cards, and it computes the optimal basic land split."}},{"@type":"Question","name":"How does this mana calculator differ from other MTG land calculators?","acceptedAnswer":{"@type":"Answer","text":"Most MTG land calculators only tell you how many total lands to run. This calculator goes further by implementing Frank Karsten's hypergeometric probability model — the same math used by Pro Tour players. It calculates the exact number of colored sources per color, shows your probability of casting each spell on curve, and recommends specific dual land cycles for your format. It also includes a decklist import feature that auto-detects your mana pips via Scryfall."}},{"@type":"Question","name":"Should I count mana rocks as colored sources?","acceptedAnswer":{"@type":"Answer","text":"Mana rocks like Sol Ring, Arcane Signet, and Signets contribute to your mana production but are not technically lands. In Commander, mana rocks are essential — most decks run 8-12 ramp pieces. A rock that produces your color counts as roughly 0.5-0.75 of a colored source because it can be removed and doesn't affect your opening hand land count. The safe approach: build your land base as if rocks don't exist, then add rocks on top as acceleration."}}]}
</script>
</body>
</html>
