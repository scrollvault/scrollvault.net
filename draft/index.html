<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MTG Draft Simulator — Practice Draft Against AI Bots Free | ScrollVault</title>
    <meta name="description" content="Free MTG draft simulator with smart AI opponents. Practice drafting TMNT, Aetherdrift, Foundations and 15+ real sets. 3 packs, 14 cards, 7 AI drafters. Build your deck and export to Arena.">
    <meta name="robots" content="index, follow">
    <meta property="og:title" content="MTG Draft Simulator — Practice Draft Against AI Bots Free">
    <meta property="og:description" content="Free MTG draft simulator with smart AI opponents. Practice drafting from 14+ real sets. Build your deck and export to Arena.">
    <meta property="og:type" content="website">
    <meta property="og:locale" content="en_US">
    <meta property="og:site_name" content="ScrollVault">
    <meta property="og:url" content="https://scrollvault.net/draft/">
    <meta property="og:image" content="https://scrollvault.net/og-default.png">
    <meta property="og:image:alt" content="MTG Draft Simulator — Practice Draft Against AI Bots">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@scrollvault">
    <meta name="twitter:title" content="MTG Draft Simulator — Practice Draft Against AI Bots Free">
    <meta name="twitter:description" content="Free MTG draft simulator with smart AI opponents. 14+ real sets, 7 AI drafters, Arena export.">
    <meta name="twitter:image" content="https://scrollvault.net/og-default.png">
    <meta name="twitter:image:alt" content="MTG Draft Simulator — Practice Draft Against AI Bots">
    <link rel="canonical" href="https://scrollvault.net/draft/">
    <link rel="preload" href="/css/fonts/inter-latin.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="/css/fonts/space-grotesk-latin.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="icon" href="/favicon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-1CV3DS33WK"></script>
    <script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','G-1CV3DS33WK');</script>
<style>
@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 400 700;
  font-display: swap;
  src: url('/css/fonts/inter-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
@font-face {
  font-family: 'Space Grotesk';
  font-style: normal;
  font-weight: 400 700;
  font-display: swap;
  src: url('/css/fonts/space-grotesk-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
/* ── Theme Variables ── */
:root {
    --bg-dark: #0f0f0f; --card-bg: #1a1a1a; --card-border: rgba(255,255,255,0.08);
    --card-hover-glow: rgba(139,92,246,0.25); --text-primary: #ffffff;
    --text-secondary: #a1a1aa; --text-muted: #71717a;
    --nav-bg: rgba(15,15,15,0.95); --nav-border: rgba(255,255,255,0.06);
    --gradient-purple: linear-gradient(135deg, #a855f7 0%, #6366f1 100%);
    --shadow-sm: 0 1px 2px rgba(0,0,0,0.3); --shadow-md: 0 4px 6px rgba(0,0,0,0.4);
    --shadow-lg: 0 10px 15px rgba(0,0,0,0.5);
    --color-W: #F9FAF4; --color-U: #0E68AB; --color-B: #150B00; --color-R: #D3202A; --color-G: #00733E;
    --color-M: #C5AF46; --color-C: #9E9E9E;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
html { scroll-behavior: smooth; }
body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; background: var(--bg-dark); color: var(--text-primary); line-height: 1.6; min-height: 100vh; }
h1,h2,h3,h4,h5,h6 { font-family: 'Space Grotesk', -apple-system, sans-serif; font-weight: 600; line-height: 1.3; }
a { color: inherit; text-decoration: none; transition: color 0.2s ease; }
a:hover { color: #a78bfa; }
.container { max-width: 1280px; margin: 0 auto; padding: 0 1rem; }
.transition-all { transition: all 0.2s ease; }

/* ── Nav ── */
.nav { position: fixed; top: 0; left: 0; right: 0; background: var(--nav-bg); border-bottom: 1px solid var(--nav-border); z-index: 1000; height: 64px; display: flex; align-items: center; }
.nav-content { display: flex; justify-content: space-between; align-items: center; width: 100%; }
.nav-logo { font-family: 'Space Grotesk', sans-serif; font-size: 1.5rem; font-weight: 700; background: var(--gradient-purple); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
.nav-links { display: flex; gap: 2rem; list-style: none; }
.nav-links a { font-size: 0.9rem; font-weight: 500; color: var(--text-secondary); }
.nav-links a:hover, .nav-links a.active { color: var(--text-primary); }
.mobile-menu-btn { display: none; background: none; border: none; color: var(--text-primary); font-size: 1.5rem; cursor: pointer; }
@media (max-width: 768px) {
    .nav-links { display: none; position: absolute; top: 64px; left: 0; right: 0; background: var(--nav-bg); border-bottom: 1px solid var(--nav-border); flex-direction: column; padding: 1rem; gap: 0; }
    .nav-links.active { display: flex; }
    .nav-links a { padding: 0.75rem 1rem; display: block; border-bottom: 1px solid var(--card-border); }
    .nav-links a:last-child { border-bottom: none; }
    .mobile-menu-btn { display: block; }
}

/* ── Footer ── */
footer { border-top: 1px solid var(--card-border); padding: 2rem 0; }
.footer-content { display: flex; flex-direction: column; align-items: center; gap: 1rem; text-align: center; }
.footer-logo { font-family: 'Space Grotesk', sans-serif; font-size: 1.25rem; font-weight: 700; background: var(--gradient-purple); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
.footer-text { color: var(--text-muted); font-size: 0.875rem; }
.footer-links { display: flex; gap: 1.5rem; list-style: none; }
.footer-links a { color: var(--text-secondary); font-size: 0.875rem; }
.footer-links a:hover { color: var(--text-primary); }
.wubrg-dots { display: flex; gap: 0.5rem; justify-content: center; margin-top: 0.25rem; }
.mana-dot { width: 10px; height: 10px; border-radius: 50%; }

/* ── Main ── */
main { margin-top: 64px; min-height: calc(100vh - 64px); }

/* ── Screen 1: Set Selection ── */
.screen { display: none; }
.screen.active { display: block; }

.hero-section { padding: 4rem 0 2rem; text-align: center; }
.hero-section h1 { font-size: 3rem; margin-bottom: 0.5rem; background: var(--gradient-purple); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
.hero-section .subtitle { color: var(--text-secondary); font-size: 1.1rem; margin-bottom: 0.5rem; }
.hero-section .rules-text { color: var(--text-muted); font-size: 0.9rem; }

.set-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); gap: 1.5rem; padding: 2rem 0 4rem; max-width: 720px; margin: 0 auto; }
.set-card { background: var(--card-bg); border: 1px solid var(--card-border); border-radius: 12px; padding: 2rem; transition: transform 0.2s ease, box-shadow 0.2s ease; cursor: default; }
.set-card:hover { transform: translateY(-4px); box-shadow: var(--shadow-lg), 0 0 30px var(--card-hover-glow); }
.set-card-header { display: flex; align-items: center; gap: 1rem; margin-bottom: 1.5rem; }
.set-icon { width: 48px; height: 48px; filter: brightness(0) invert(1); }
.set-card-header h3 { font-size: 1.25rem; }
.set-meta { display: flex; gap: 1.5rem; color: var(--text-secondary); font-size: 0.875rem; margin-bottom: 1.5rem; }
.set-meta span { display: flex; align-items: center; gap: 0.35rem; }

.btn-start { display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.75rem 2rem; background: var(--gradient-purple); border: none; border-radius: 8px; font-weight: 600; font-size: 1rem; color: white; cursor: pointer; font-family: inherit; transition: transform 0.2s ease, box-shadow 0.2s ease; }
.btn-start:hover { transform: translateY(-2px); box-shadow: 0 4px 20px rgba(139,92,246,0.4); }
.btn-start:disabled { opacity: 0.6; cursor: wait; transform: none; box-shadow: none; }
.btn-start .spinner { display: none; width: 16px; height: 16px; border: 2px solid rgba(255,255,255,0.3); border-top-color: white; border-radius: 50%; animation: spin 0.6s linear infinite; }
.btn-start.loading .spinner { display: inline-block; }
.btn-start.loading .btn-text { display: none; }
@keyframes spin { to { transform: rotate(360deg); } }

/* ── Screen 2: Draft Phase ── */
.draft-layout { display: flex; gap: 1.5rem; padding: 1.5rem 0 4rem; min-height: calc(100vh - 64px - 120px); }
.pack-area { flex: 7; min-width: 0; }
.pool-area { flex: 3; min-width: 240px; }

/* Pack header */
.pack-header { margin-bottom: 1rem; }
.pack-info { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; }
.pack-label { font-family: 'Space Grotesk', sans-serif; font-size: 1.1rem; font-weight: 600; }
.pass-direction { color: var(--text-muted); font-size: 0.85rem; display: flex; align-items: center; gap: 0.35rem; }
.progress-bar { height: 3px; background: rgba(255,255,255,0.08); border-radius: 2px; overflow: hidden; }
.progress-fill { height: 100%; background: var(--gradient-purple); border-radius: 2px; transition: width 0.3s ease; }
.keyboard-hint { color: var(--text-muted); font-size: 0.75rem; margin-top: 0.5rem; }

/* Pack grid */
.pack-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; contain: layout style; }
.pack-card { position: relative; border-radius: 4px; overflow: hidden; cursor: pointer; will-change: transform; transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.3s ease; aspect-ratio: 488 / 680; }
.pack-card img { width: 100%; height: 100%; object-fit: cover; display: block; border-radius: 4px; pointer-events: none; }
.pack-card:hover { transform: scale(1.08); box-shadow: 0 0 20px rgba(168,85,247,0.4); z-index: 10; }
.pack-card.picked { animation: pickFlash 0.4s ease; box-shadow: 0 0 25px rgba(255,215,0,0.6); }
.pack-card.fading { opacity: 0; transform: scale(0.95); pointer-events: none; }
.pack-card .card-number { position: absolute; top: 4px; left: 4px; background: rgba(0,0,0,0.75); color: white; font-size: 0.65rem; font-weight: 600; padding: 1px 5px; border-radius: 3px; pointer-events: none; }
@keyframes pickFlash {
    0% { box-shadow: 0 0 0 rgba(255,215,0,0); }
    50% { box-shadow: 0 0 35px rgba(255,215,0,0.8); transform: scale(1.05); }
    100% { box-shadow: 0 0 25px rgba(255,215,0,0.3); transform: scale(1); }
}

/* Tooltip */
.card-tooltip { position: fixed; z-index: 2000; background: #222; border: 1px solid rgba(255,255,255,0.15); border-radius: 8px; padding: 0.75rem; max-width: 280px; pointer-events: none; opacity: 0; transition: opacity 0.15s ease; font-size: 0.8rem; box-shadow: 0 8px 32px rgba(0,0,0,0.6); }
.card-tooltip.visible { opacity: 1; }
.card-tooltip .tt-name { font-family: 'Space Grotesk', sans-serif; font-weight: 600; font-size: 0.9rem; margin-bottom: 0.25rem; }
.card-tooltip .tt-cost { color: var(--text-secondary); font-size: 0.8rem; margin-bottom: 0.25rem; }
.card-tooltip .tt-type { color: var(--text-muted); font-size: 0.75rem; margin-bottom: 0.5rem; border-bottom: 1px solid var(--card-border); padding-bottom: 0.4rem; }
.card-tooltip .tt-oracle { color: var(--text-secondary); font-size: 0.75rem; line-height: 1.5; }
.card-tooltip .tt-pt { color: var(--text-primary); font-weight: 600; font-size: 0.8rem; margin-top: 0.4rem; text-align: right; }
.card-tooltip .tt-rating { color: #a855f7; font-size: 0.7rem; margin-top: 0.25rem; }

/* Pool sidebar */
.pool-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 1px solid var(--card-border); }
.pool-header h3 { font-size: 1rem; }
.pool-count { color: var(--text-muted); font-size: 0.85rem; }

.pool-colors { display: flex; flex-direction: column; gap: 0.75rem; }
.pool-color-group { background: rgba(255,255,255,0.02); border-radius: 6px; padding: 0.5rem; }
.pool-color-label { display: flex; align-items: center; gap: 0.4rem; margin-bottom: 0.35rem; font-size: 0.75rem; font-weight: 600; color: var(--text-secondary); }
.pool-color-dot { width: 8px; height: 8px; border-radius: 50%; }
.pool-color-cards { display: flex; flex-wrap: wrap; gap: 2px; }
.pool-mini-card { width: 36px; height: 50px; border-radius: 2px; overflow: hidden; transition: transform 0.15s ease; cursor: pointer; }
.pool-mini-card img { width: 100%; height: 100%; object-fit: cover; display: block; }
.pool-mini-card:hover { transform: scale(1.3); z-index: 5; position: relative; }

/* Mana curve mini */
.mini-curve { margin-top: 1rem; padding-top: 0.75rem; border-top: 1px solid var(--card-border); }
.mini-curve h4 { font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem; }
.curve-bars { display: flex; align-items: flex-end; gap: 3px; height: 40px; }
.curve-bar { flex: 1; background: rgba(168,85,247,0.4); border-radius: 2px 2px 0 0; min-height: 2px; transition: height 0.2s ease; position: relative; }
.curve-bar-label { position: absolute; bottom: -14px; left: 50%; transform: translateX(-50%); font-size: 0.6rem; color: var(--text-muted); }
.curve-bar-count { position: absolute; top: -14px; left: 50%; transform: translateX(-50%); font-size: 0.6rem; color: var(--text-secondary); }

/* ── Screen 3: Deck Builder ── */
.builder-layout { padding: 1.5rem 0 4rem; }
.builder-header { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; margin-bottom: 1.5rem; }
.builder-header h2 { font-size: 1.5rem; background: var(--gradient-purple); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
.builder-actions { display: flex; gap: 0.75rem; flex-wrap: wrap; }

.btn { display: inline-flex; align-items: center; gap: 0.4rem; padding: 0.5rem 1.25rem; border: 1px solid var(--card-border); border-radius: 6px; font-size: 0.85rem; font-weight: 500; color: var(--text-secondary); background: var(--card-bg); cursor: pointer; font-family: inherit; transition: all 0.2s ease; }
.btn:hover { border-color: rgba(139,92,246,0.5); color: var(--text-primary); }
.btn-primary { background: var(--gradient-purple); border-color: transparent; color: white; }
.btn-primary:hover { box-shadow: 0 4px 20px rgba(139,92,246,0.4); color: white; }

/* Deck stats bar */
.deck-stats { display: flex; gap: 1.5rem; flex-wrap: wrap; align-items: center; margin-bottom: 1.5rem; padding: 1rem; background: var(--card-bg); border: 1px solid var(--card-border); border-radius: 8px; }
.stat { font-size: 0.9rem; color: var(--text-secondary); }
.stat strong { color: var(--text-primary); }

/* Mainboard / Sideboard toggle info */
.board-tabs { display: flex; gap: 0; margin-bottom: 1rem; }
.board-tab { padding: 0.5rem 1.25rem; background: var(--card-bg); border: 1px solid var(--card-border); font-size: 0.85rem; font-weight: 500; color: var(--text-muted); cursor: pointer; font-family: inherit; transition: all 0.2s ease; }
.board-tab:first-child { border-radius: 6px 0 0 6px; }
.board-tab:last-child { border-radius: 0 6px 6px 0; border-left: none; }
.board-tab.active { background: rgba(168,85,247,0.15); border-color: rgba(168,85,247,0.4); color: var(--text-primary); }

/* Deck columns */
.deck-columns { display: flex; gap: 1rem; flex-wrap: wrap; margin-bottom: 2rem; }
.deck-column { flex: 1; min-width: 140px; max-width: 200px; }
.deck-col-header { display: flex; align-items: center; gap: 0.35rem; margin-bottom: 0.5rem; font-size: 0.8rem; font-weight: 600; color: var(--text-secondary); padding-bottom: 0.35rem; border-bottom: 2px solid; }
.deck-col-header .col-dot { width: 8px; height: 8px; border-radius: 50%; }
.deck-card-entry { display: flex; align-items: center; gap: 0.4rem; padding: 0.25rem 0.35rem; border-radius: 4px; cursor: pointer; transition: background 0.15s ease; font-size: 0.8rem; }
.deck-card-entry:hover { background: rgba(255,255,255,0.06); }
.deck-card-entry .entry-img { width: 28px; height: 40px; border-radius: 2px; overflow: hidden; flex-shrink: 0; }
.deck-card-entry .entry-img img { width: 100%; height: 100%; object-fit: cover; display: block; }
.deck-card-entry .entry-name { color: var(--text-secondary); flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.deck-card-entry .entry-cmc { color: var(--text-muted); font-size: 0.7rem; flex-shrink: 0; }
.deck-card-entry.sideboarded { opacity: 0.4; }

/* Mana curve histogram */
.curve-section { margin-bottom: 2rem; }
.curve-section h3 { font-size: 1rem; margin-bottom: 1rem; }
.histogram { display: flex; align-items: flex-end; gap: 6px; height: 120px; padding: 0 1rem; }
.histo-col { flex: 1; display: flex; flex-direction: column; align-items: center; gap: 4px; max-width: 60px; }
.histo-bar { width: 100%; border-radius: 3px 3px 0 0; min-height: 0; transition: height 0.3s ease; background: var(--gradient-purple); position: relative; z-index: 1; }
.histo-label { font-size: 0.7rem; color: var(--text-muted); }
.histo-count { font-size: 0.7rem; color: var(--text-secondary); }

/* Lands section */
.lands-section { margin-bottom: 2rem; padding: 1.25rem; background: var(--card-bg); border: 1px solid var(--card-border); border-radius: 8px; }
.lands-section h3 { font-size: 1rem; margin-bottom: 1rem; }
.land-controls { display: flex; flex-wrap: wrap; gap: 1rem; align-items: center; margin-bottom: 1rem; }
.land-control { display: flex; align-items: center; gap: 0.5rem; }
.land-control .land-symbol { width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.7rem; font-weight: 700; }
.land-control button { width: 24px; height: 24px; border-radius: 4px; border: 1px solid var(--card-border); background: var(--card-bg); color: var(--text-secondary); cursor: pointer; font-size: 0.9rem; font-family: inherit; display: flex; align-items: center; justify-content: center; transition: all 0.15s ease; }
.land-control button:hover { border-color: rgba(168,85,247,0.5); color: var(--text-primary); }
.land-control .land-count { font-size: 0.9rem; font-weight: 600; width: 20px; text-align: center; }

/* Toast */
.toast { position: fixed; bottom: 2rem; left: 50%; transform: translateX(-50%) translateY(100px); background: #333; color: white; padding: 0.75rem 1.5rem; border-radius: 8px; font-size: 0.9rem; z-index: 3000; transition: transform 0.3s ease, opacity 0.3s ease; opacity: 0; pointer-events: none; }
.toast.visible { transform: translateX(-50%) translateY(0); opacity: 1; }

/* ── Mobile Card Preview Panel ── */
.mobile-preview-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 1500; opacity: 0; pointer-events: none; transition: opacity 0.2s ease; }
.mobile-preview-overlay.visible { opacity: 1; pointer-events: auto; }
.mobile-preview { position: fixed; bottom: 0; left: 0; right: 0; z-index: 1600; background: #1e1e1e; border-top: 1px solid rgba(255,255,255,0.12); border-radius: 16px 16px 0 0; padding: 0 1rem 1.5rem; transform: translateY(100%); transition: transform 0.25s ease; max-height: 70vh; overflow-y: auto; pointer-events: none; }
.mobile-preview.visible { transform: translateY(0); pointer-events: auto; }
.mobile-preview-handle { width: 36px; height: 4px; background: rgba(255,255,255,0.25); border-radius: 2px; margin: 10px auto 12px; }
.mobile-preview-body { display: flex; gap: 1rem; align-items: flex-start; }
.mobile-preview-img { flex-shrink: 0; width: 120px; border-radius: 4px; overflow: hidden; }
.mobile-preview-img img { width: 100%; display: block; border-radius: 4px; }
.mobile-preview-info { flex: 1; min-width: 0; }
.mobile-preview-info .mp-name { font-family: 'Space Grotesk', sans-serif; font-weight: 600; font-size: 1.05rem; margin-bottom: 0.25rem; }
.mobile-preview-info .mp-cost { color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 0.2rem; }
.mobile-preview-info .mp-type { color: var(--text-muted); font-size: 0.8rem; margin-bottom: 0.5rem; padding-bottom: 0.4rem; border-bottom: 1px solid var(--card-border); }
.mobile-preview-info .mp-oracle { color: var(--text-secondary); font-size: 0.82rem; line-height: 1.55; margin-bottom: 0.5rem; }
.mobile-preview-info .mp-pt { font-weight: 600; font-size: 0.85rem; }
.mobile-preview-info .mp-rating { color: #a855f7; font-size: 0.75rem; margin-top: 0.2rem; }
.mobile-preview-actions { display: flex; gap: 0.75rem; margin-top: 1rem; }
.mobile-preview-actions .btn-pick { flex: 1; padding: 0.85rem; background: var(--gradient-purple); border: none; border-radius: 10px; font-weight: 700; font-size: 1rem; color: white; cursor: pointer; font-family: inherit; }
.mobile-preview-actions .btn-cancel { padding: 0.85rem 1.25rem; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.12); border-radius: 10px; font-weight: 500; font-size: 1rem; color: var(--text-secondary); cursor: pointer; font-family: inherit; }

/* Selected card glow on mobile */
.pack-card.selected { outline: 3px solid #a855f7; outline-offset: 2px; transform: scale(1.04); box-shadow: 0 0 20px rgba(168,85,247,0.5); z-index: 10; }

/* ── Responsive ── */
@media (max-width: 900px) {
    .draft-layout { flex-direction: column; }
    .pool-area { order: 2; }
    .pack-grid { grid-template-columns: repeat(3, 1fr); }
    .deck-column { min-width: 120px; }
}
@media (max-width: 600px) {
    .hero-section h1 { font-size: 2rem; }
    .hero-section { padding: 2.5rem 0 1rem; }
    .pack-grid { grid-template-columns: repeat(3, 1fr); gap: 6px; }
    .deck-columns { gap: 0.5rem; }
    .deck-column { min-width: 100px; }
    .keyboard-hint { display: none; }
    .builder-actions { width: 100%; }
    .builder-actions .btn { flex: 1; justify-content: center; font-size: 0.8rem; padding: 0.5rem 0.75rem; }
    .deck-stats { gap: 0.75rem; flex-wrap: wrap; }
    .set-grid { grid-template-columns: 1fr; }
}

/* ── FAQ Section ── */
.faq-section { padding: 3rem 0 2rem; }
.faq-section h2 { font-size: 1.75rem; margin-bottom: 1.5rem; background: var(--gradient-purple); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
.faq-list { display: flex; flex-direction: column; gap: 0.75rem; max-width: 800px; }
.faq-item { background: var(--card-bg); border: 1px solid var(--card-border); border-radius: 10px; overflow: hidden; }
.faq-item summary { padding: 1rem 1.25rem; font-weight: 600; font-size: 0.95rem; cursor: pointer; list-style: none; display: flex; justify-content: space-between; align-items: center; }
.faq-item summary::-webkit-details-marker { display: none; }
.faq-item summary::after { content: '+'; font-size: 1.25rem; color: var(--text-muted); flex-shrink: 0; margin-left: 1rem; transition: transform 0.2s; }
.faq-item[open] summary::after { content: '\2212'; }
.faq-answer { padding: 0 1.25rem 1rem; color: var(--text-secondary); font-size: 0.9rem; line-height: 1.7; }
.faq-answer p { margin-bottom: 0.5rem; }
.faq-answer ul { margin: 0.5rem 0 0.5rem 1.5rem; }
.faq-answer a { color: #a78bfa; text-decoration: underline; }

/* ── Pick Suggestion Glow ── */
.pack-card.suggested { outline: 2px solid rgba(255,215,0,0.5); outline-offset: 1px; }
.suggestion-badge { position: absolute; bottom: 4px; right: 4px; background: rgba(255,215,0,0.9); color: #000; font-size: 0.6rem; font-weight: 700; padding: 1px 5px; border-radius: 3px; pointer-events: none; }

/* ── Settings Toggle ── */
.settings-bar { display: flex; gap: 1.5rem; align-items: center; justify-content: center; margin-top: 0.75rem; }
.toggle-label { display: flex; align-items: center; gap: 0.5rem; font-size: 0.8rem; color: var(--text-muted); cursor: pointer; }
.toggle-label input[type="checkbox"] { accent-color: #a855f7; width: 14px; height: 14px; }

/* ── Pool Analysis Stats ── */
.pool-stats { display: flex; gap: 1rem; flex-wrap: wrap; margin-bottom: 1rem; padding: 0.75rem; background: var(--card-bg); border: 1px solid var(--card-border); border-radius: 8px; font-size: 0.8rem; color: var(--text-secondary); }
.pool-stats .stat-group { display: flex; align-items: center; gap: 0.35rem; }
.pool-stats .color-bar { height: 10px; border-radius: 2px; min-width: 4px; }

/* ── Color Filters ── */
.color-filters { display: flex; gap: 0.35rem; flex-wrap: wrap; align-items: center; margin-bottom: 1rem; }
.color-filter { width: auto; min-width: 32px; height: 32px; border-radius: 16px; border: 2px solid transparent; background: var(--card-bg); color: var(--text-secondary); font-size: 0.75rem; font-weight: 600; font-family: 'Inter', sans-serif; cursor: pointer; transition: all 0.15s; padding: 0 0.5rem; display: flex; align-items: center; justify-content: center; }
.color-filter.cf-mana { width: 32px; padding: 0; border-radius: 50%; }
.color-filter:hover { border-color: rgba(168,85,247,0.5); }
.color-filter.active { border-color: #a855f7; box-shadow: 0 0 8px rgba(168,85,247,0.4); }

/* ── Rarity Glow ── */
.rarity-mythic { box-shadow: 0 0 0 2px #f97316, 0 0 12px rgba(249,115,22,0.5); }
.rarity-rare { box-shadow: 0 0 0 2px #eab308, 0 0 10px rgba(234,179,8,0.4); }
.rarity-uncommon { box-shadow: 0 0 0 1px #94a3b8, 0 0 8px rgba(148,163,184,0.25); }

/* Touch devices: hide hover tooltip */
@media (hover: none) and (pointer: coarse) {
    .card-tooltip { display: none !important; }
    .pack-card:hover { transform: none; box-shadow: none; z-index: auto; }
    .pack-card.selected { transform: scale(1.04); box-shadow: 0 0 20px rgba(168,85,247,0.5); z-index: 10; }
    .pool-mini-card:hover { transform: none; z-index: auto; }
}

/* ── Feature 1: Pack Card Entrance Animation ── */
@keyframes packReveal {
    from { opacity: 0; transform: translateY(12px) scale(0.95); }
    to { opacity: 1; transform: translateY(0) scale(1); }
}
.pack-card.pack-entering { opacity: 0; animation: packReveal 0.32s ease forwards; }

/* ── Feature 2: Pack Transition Banner ── */
@keyframes bannerSlide {
    0% { opacity: 0; transform: translate(-50%, -20px); }
    15% { opacity: 1; transform: translate(-50%, 0); }
    80% { opacity: 1; transform: translate(-50%, 0); }
    100% { opacity: 0; transform: translate(-50%, -10px); }
}
.pack-transition {
    position: fixed; top: 80px; left: 50%; transform: translateX(-50%);
    background: rgba(30,30,30,0.95); border: 1px solid rgba(168,85,247,0.4);
    border-radius: 10px; padding: 0.6rem 1.5rem; z-index: 1200;
    font-family: 'Space Grotesk', sans-serif; font-size: 1.1rem; font-weight: 600;
    color: #e2e2e2; text-align: center; pointer-events: none;
    animation: bannerSlide 0.8s ease forwards;
    box-shadow: 0 4px 24px rgba(168,85,247,0.25);
}

/* ── Feature 3: Draft Complete Celebration ── */
@keyframes celebShimmer {
    0% { background-position: -200% center; }
    100% { background-position: 200% center; }
}
@keyframes celebPulse {
    0% { transform: scale(0.8); opacity: 0; }
    40% { transform: scale(1.05); opacity: 1; }
    100% { transform: scale(1); opacity: 1; }
}
.draft-complete-overlay {
    position: fixed; inset: 0; background: rgba(0,0,0,0.8);
    z-index: 1300; display: none; align-items: center; justify-content: center; flex-direction: column;
}
.draft-complete-overlay.visible { display: flex; }
.draft-complete-overlay h2 {
    font-family: 'Space Grotesk', sans-serif; font-size: 2.5rem; font-weight: 700;
    background: linear-gradient(90deg, #ffd700, #ffaa00, #ffd700, #fff5cc, #ffd700);
    background-size: 200% auto; -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
    animation: celebShimmer 1.8s linear infinite, celebPulse 0.6s ease forwards;
}
.draft-complete-overlay .celeb-stats {
    color: var(--text-secondary); font-size: 1rem; margin-top: 0.75rem;
    animation: celebPulse 0.6s ease 0.2s forwards; opacity: 0;
}

/* ── Feature 4: Color Signal Dots ── */
.draft-signals { display: none; gap: 0.5rem; align-items: center; margin-bottom: 0.75rem; padding: 0.5rem; background: rgba(255,255,255,0.02); border-radius: 6px; }
.draft-signals.visible { display: flex; }
.draft-signals-label { font-size: 0.65rem; color: var(--text-muted); margin-right: 0.25rem; }
.signal-dot {
    width: 18px; height: 18px; border-radius: 50%; position: relative;
    border: 1.5px solid rgba(255,255,255,0.15); transition: all 0.3s ease;
}
.signal-dot .signal-fill {
    position: absolute; inset: 2px; border-radius: 50%;
    opacity: 0.15; transition: opacity 0.3s ease;
}
.signal-dot.open { box-shadow: 0 0 6px 2px rgba(255,215,0,0.4); border-color: rgba(255,215,0,0.5); }
.signal-fill-W { background: var(--color-W); }
.signal-fill-U { background: var(--color-U); }
.signal-fill-B { background: #6b5b3a; }
.signal-fill-R { background: var(--color-R); }
.signal-fill-G { background: var(--color-G); }

/* ── Feature 5: Draft Stats in Pool Sidebar ── */
.pool-draft-stats { display: flex; gap: 0.6rem; flex-wrap: wrap; margin-bottom: 0.75rem; font-size: 0.75rem; color: var(--text-muted); }

/* ── Feature 6: Card Rating Display ── */
.entry-rating {
    font-size: 0.65rem; font-weight: 700; padding: 1px 4px; border-radius: 3px;
    flex-shrink: 0; margin-left: auto; margin-right: 0.25rem;
}
.rating-good { background: rgba(34,197,94,0.2); color: #4ade80; }
.rating-ok { background: rgba(234,179,8,0.2); color: #facc15; }
.rating-bad { background: rgba(239,68,68,0.2); color: #f87171; }

/* ── Feature 7: Sort Toggle Buttons ── */
.builder-sort-buttons { display: flex; gap: 0.25rem; align-items: center; }
.sort-label { font-size: 0.7rem; color: var(--text-muted); margin-right: 0.25rem; }
.sort-btn {
    padding: 0.3rem 0.6rem; font-size: 0.7rem; font-weight: 600; font-family: inherit;
    background: var(--card-bg); border: 1px solid var(--card-border); border-radius: 4px;
    color: var(--text-muted); cursor: pointer; transition: all 0.15s ease;
}
.sort-btn:hover { border-color: rgba(168,85,247,0.4); color: var(--text-secondary); }
.sort-btn.active { background: rgba(168,85,247,0.15); border-color: rgba(168,85,247,0.5); color: var(--text-primary); }

/* ── Feature 8: Sideboard Button ── */
.entry-sb-btn {
    font-size: 0.6rem; font-weight: 700; font-family: inherit;
    padding: 1px 4px; border-radius: 3px; cursor: pointer;
    background: rgba(168,85,247,0.15); border: 1px solid rgba(168,85,247,0.3);
    color: #c4b5fd; flex-shrink: 0; opacity: 0; transition: opacity 0.15s ease;
}
.deck-card-entry:hover .entry-sb-btn { opacity: 1; }
.deck-card-entry.sideboarded .entry-sb-btn { background: rgba(34,197,94,0.15); border-color: rgba(34,197,94,0.3); color: #86efac; }
@media (hover: none) and (pointer: coarse) {
    .entry-sb-btn { opacity: 0.6; }
}

/* ── Deck Lightbox ── */
.deck-lightbox-overlay {
    position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 2500;
    opacity: 0; pointer-events: none; transition: opacity 0.2s ease;
}
.deck-lightbox-overlay.visible { opacity: 1; pointer-events: auto; }
.deck-lightbox {
    position: fixed; z-index: 2600; background: #1e1e1e;
    border: 1px solid rgba(255,255,255,0.12); overflow-y: auto;
    opacity: 0; pointer-events: none; transition: opacity 0.2s ease, transform 0.25s ease;
}
.deck-lightbox.visible { opacity: 1; pointer-events: auto; }
/* Desktop: centered modal */
@media (hover: hover) and (pointer: fine) {
    .deck-lightbox {
        top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.95);
        border-radius: 12px; width: 560px; max-width: 94vw; max-height: 85vh;
        box-shadow: 0 16px 48px rgba(0,0,0,0.6);
    }
    .deck-lightbox.visible { transform: translate(-50%, -50%) scale(1); }
}
/* Mobile: bottom sheet */
@media (hover: none) and (pointer: coarse) {
    .deck-lightbox {
        bottom: 0; left: 0; right: 0; transform: translateY(100%);
        border-radius: 16px 16px 0 0; max-height: 80vh;
    }
    .deck-lightbox.visible { transform: translateY(0); }
}
.deck-lightbox-close {
    position: absolute; top: 10px; right: 12px; width: 32px; height: 32px;
    border-radius: 50%; border: 1px solid rgba(255,255,255,0.15);
    background: rgba(255,255,255,0.08); color: var(--text-secondary);
    font-size: 1.1rem; cursor: pointer; display: flex; align-items: center;
    justify-content: center; z-index: 1; transition: all 0.15s ease;
}
.deck-lightbox-close:hover { background: rgba(255,255,255,0.15); color: var(--text-primary); }
.deck-lightbox-handle { width: 36px; height: 4px; background: rgba(255,255,255,0.25); border-radius: 2px; margin: 10px auto 8px; display: none; }
@media (hover: none) and (pointer: coarse) { .deck-lightbox-handle { display: block; } }
/* Desktop prev/next arrows (outside body) */
.deck-lightbox-nav {
    position: absolute; top: 50%; width: 36px; height: 36px; border-radius: 50%;
    border: 1px solid rgba(255,255,255,0.15); background: rgba(255,255,255,0.08);
    color: var(--text-secondary); font-size: 1.1rem; cursor: pointer;
    display: flex; align-items: center; justify-content: center; transform: translateY(-50%);
    transition: all 0.15s ease; z-index: 1;
}
.deck-lightbox-nav:hover { background: rgba(255,255,255,0.15); color: var(--text-primary); }
.deck-lightbox-nav:disabled { opacity: 0.3; cursor: default; }
.deck-lightbox-nav.dl-prev { left: 12px; }
.deck-lightbox-nav.dl-next { right: 12px; }
@media (hover: none) and (pointer: coarse) { .deck-lightbox-nav { display: none; } }
/* Mobile inline nav row */
.deck-lightbox-nav-row { display: none; justify-content: center; gap: 1.5rem; padding: 0.5rem 0 0; }
@media (hover: none) and (pointer: coarse) { .deck-lightbox-nav-row { display: flex; } }
.deck-lightbox-nav-row button {
    width: 44px; height: 44px; border-radius: 50%;
    border: 1px solid rgba(255,255,255,0.15); background: rgba(255,255,255,0.08);
    color: var(--text-secondary); font-size: 1.2rem; cursor: pointer;
    display: flex; align-items: center; justify-content: center; transition: all 0.15s ease;
}
.deck-lightbox-nav-row button:hover { background: rgba(255,255,255,0.15); color: var(--text-primary); }
.deck-lightbox-nav-row button:disabled { opacity: 0.3; cursor: default; }
/* Body layout */
.deck-lightbox-body { display: flex; gap: 1.25rem; padding: 1.25rem; align-items: flex-start; }
@media (hover: none) and (pointer: coarse) {
    .deck-lightbox-body { flex-direction: column; align-items: center; padding: 0.75rem 1rem 1rem; }
}
.deck-lightbox-img { flex-shrink: 0; border-radius: 6px; overflow: hidden; }
@media (hover: hover) and (pointer: fine) { .deck-lightbox-img { width: 220px; } }
@media (hover: none) and (pointer: coarse) { .deck-lightbox-img { width: 160px; } }
.deck-lightbox-img img { width: 100%; display: block; border-radius: 6px; }
.deck-lightbox-info { flex: 1; min-width: 0; }
.dl-name { font-family: 'Space Grotesk', sans-serif; font-weight: 600; font-size: 1.15rem; margin-bottom: 0.25rem; }
.dl-cost { color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 0.2rem; }
.dl-type { color: var(--text-muted); font-size: 0.85rem; margin-bottom: 0.5rem; padding-bottom: 0.4rem; border-bottom: 1px solid var(--card-border); }
.dl-oracle { color: var(--text-secondary); font-size: 0.85rem; line-height: 1.6; margin-bottom: 0.5rem; white-space: pre-line; }
.dl-pt { font-weight: 600; font-size: 0.9rem; margin-bottom: 0.25rem; }
.dl-rating { color: #a855f7; font-size: 0.8rem; margin-bottom: 0.75rem; }
.deck-lightbox-actions { margin-top: 0.5rem; }
.dl-sb-btn {
    padding: 0.5rem 1.25rem; border-radius: 8px; font-weight: 600; font-size: 0.85rem;
    font-family: inherit; cursor: pointer; transition: all 0.15s ease;
    background: rgba(168,85,247,0.15); border: 1px solid rgba(168,85,247,0.4); color: #c4b5fd;
}
.dl-sb-btn:hover { background: rgba(168,85,247,0.25); border-color: rgba(168,85,247,0.6); }
.dl-sb-btn.in-sideboard { background: rgba(34,197,94,0.15); border-color: rgba(34,197,94,0.4); color: #86efac; }
.dl-sb-btn.in-sideboard:hover { background: rgba(34,197,94,0.25); border-color: rgba(34,197,94,0.6); }
.stat-hint { color: var(--text-muted); font-size: 0.8rem; }

/* ── Feature 9: Ideal Curve Overlay ── */
.histo-bar-area { position: relative; width: 100%; height: 80px; display: flex; align-items: flex-end; }
.histo-ideal {
    position: absolute; bottom: 0; left: -2px; right: -2px;
    border: 1.5px dashed rgba(255,255,255,0.18); border-bottom: none;
    border-radius: 3px 3px 0 0; pointer-events: none; transition: height 0.3s ease;
}

/* ── Feature 10: Deck Quality Feedback ── */
.deck-feedback { display: flex; gap: 0.5rem; flex-wrap: wrap; margin-top: 0.75rem; }
.feedback-item {
    font-size: 0.75rem; font-weight: 600; padding: 0.25rem 0.6rem;
    border-radius: 12px; display: inline-block;
}
.feedback-item.warn { background: rgba(234,179,8,0.15); color: #fbbf24; }
.feedback-item.good { background: rgba(34,197,94,0.15); color: #4ade80; }

@media (max-width: 600px) {
    .draft-complete-overlay h2 { font-size: 1.75rem; }
    .draft-signals { gap: 0.35rem; }
    .signal-dot { width: 15px; height: 15px; }
    .builder-sort-buttons { width: 100%; justify-content: center; }
}
    </style>
</head>
<body>
    <nav class="nav">
        <div class="container nav-content">
            <a href="/" class="nav-logo">ScrollVault</a>
            <button class="mobile-menu-btn" onclick="document.getElementById('navLinks').classList.toggle('active')">&#9776;</button>
            <ul class="nav-links" id="navLinks">
                <li><a href="/">Home</a></li>
                <li><a href="/news/">News</a></li>
                <li><a href="/guides/">Guides</a></li>
                <li><a href="/decks/">Top Decks</a></li>
                <li><a href="/draft/" class="active">Draft</a></li>
                <li><a href="/tools/">Tools</a></li>
                <li><a href="/about.html">About</a></li>
                <li><a href="/contact.html">Contact</a></li>
            </ul>
        </div>
    </nav>

    <main>
        <!-- ══════ Screen 1: Set Selection ══════ -->
        <div id="screenSelect" class="screen active">
            <div class="hero-section">
                <div class="container">
                    <h1>MTG Draft Simulator</h1>
                    <p class="subtitle">Practice drafting against 7 AI opponents with real set cards</p>
                    <p class="rules-text">3 packs, 14 cards each. Pick 1, pass the rest.</p>
                    <div class="settings-bar">
                        <label class="toggle-label"><input type="checkbox" id="showSuggestions"> Show pick suggestions</label>
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="set-grid" id="setGrid">
                    <!-- Populated by JS -->
                </div>
            </div>
        </div>

        <!-- ══════ Screen 2: Draft Phase ══════ -->
        <div id="screenDraft" class="screen">
            <div class="container">
                <div class="pack-header">
                    <div class="pack-info">
                        <span class="pack-label" id="packLabel">Pack 1 — Pick 1 of 14</span>
                        <span class="pass-direction" id="passDirection">Passing left &#8594;</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                    </div>
                    <div class="keyboard-hint">Keys 1-9 to quick-pick &middot; Z to undo last pick</div>
                </div>
                <div class="draft-layout">
                    <div class="pack-area">
                        <div class="pack-grid" id="packGrid">
                            <!-- Populated by JS -->
                        </div>
                    </div>
                    <div class="pool-area">
                        <div class="pool-header">
                            <h3>Your Picks</h3>
                            <span class="pool-count" id="poolCount">0 cards</span>
                        </div>
                        <div class="draft-signals" id="draftSignals">
                            <span class="draft-signals-label">Signals</span>
                            <div class="signal-dot" data-color="W"><div class="signal-fill signal-fill-W"></div></div>
                            <div class="signal-dot" data-color="U"><div class="signal-fill signal-fill-U"></div></div>
                            <div class="signal-dot" data-color="B"><div class="signal-fill signal-fill-B"></div></div>
                            <div class="signal-dot" data-color="R"><div class="signal-fill signal-fill-R"></div></div>
                            <div class="signal-dot" data-color="G"><div class="signal-fill signal-fill-G"></div></div>
                        </div>
                        <div class="pool-draft-stats" id="poolDraftStats"></div>
                        <div class="pool-colors" id="poolColors">
                            <!-- Populated by JS -->
                        </div>
                        <div class="mini-curve">
                            <h4>Mana Curve</h4>
                            <div class="curve-bars" id="miniCurveBars">
                                <div class="curve-bar"><span class="curve-bar-label">1</span><span class="curve-bar-count"></span></div>
                                <div class="curve-bar"><span class="curve-bar-label">2</span><span class="curve-bar-count"></span></div>
                                <div class="curve-bar"><span class="curve-bar-label">3</span><span class="curve-bar-count"></span></div>
                                <div class="curve-bar"><span class="curve-bar-label">4</span><span class="curve-bar-count"></span></div>
                                <div class="curve-bar"><span class="curve-bar-label">5+</span><span class="curve-bar-count"></span></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ══════ Screen 3: Deck Builder ══════ -->
        <div id="screenBuild" class="screen">
            <div class="container builder-layout">
                <div class="builder-header">
                    <h2>Build Your Deck</h2>
                    <div class="builder-actions">
                        <button class="btn" onclick="autoBuildDeck()">Auto-Build Deck</button>
                        <button class="btn" onclick="autoSuggestLands()">Auto-Suggest Lands</button>
                        <button class="btn btn-primary" onclick="exportDeck()">Export to Arena</button>
                        <button class="btn" onclick="viewBotDecks()">View Bot Decks</button>
                        <button class="btn" onclick="draftAgain()">Draft Again</button>
                        <button class="btn" onclick="changeSet()">Change Set</button>
                    </div>
                    <div class="builder-sort-buttons">
                        <span class="sort-label">Sort:</span>
                        <button class="sort-btn active" data-sort="cmc" onclick="sortBuilderBy('cmc')">CMC</button>
                        <button class="sort-btn" data-sort="rating" onclick="sortBuilderBy('rating')">Rating</button>
                        <button class="sort-btn" data-sort="name" onclick="sortBuilderBy('name')">Name</button>
                    </div>
                </div>

                <div class="color-filters" id="builderColorFilters">
                    <button class="color-filter active" data-color="all" onclick="filterBuilder('all')">All</button>
                    <button class="color-filter cf-mana" data-color="W" onclick="filterBuilder('W')" style="background:var(--color-W);color:#333;">W</button>
                    <button class="color-filter cf-mana" data-color="U" onclick="filterBuilder('U')" style="background:var(--color-U);color:#fff;">U</button>
                    <button class="color-filter cf-mana" data-color="B" onclick="filterBuilder('B')" style="background:var(--color-B);color:#fff;border:1px solid rgba(255,255,255,0.3);">B</button>
                    <button class="color-filter cf-mana" data-color="R" onclick="filterBuilder('R')" style="background:var(--color-R);color:#fff;">R</button>
                    <button class="color-filter cf-mana" data-color="G" onclick="filterBuilder('G')" style="background:var(--color-G);color:#fff;">G</button>
                    <button class="color-filter" data-color="M" onclick="filterBuilder('M')">Multi</button>
                    <button class="color-filter" data-color="C" onclick="filterBuilder('C')">C</button>
                </div>

                <div class="deck-stats" id="deckStats">
                    <span class="stat"><strong id="statMain">0</strong> mainboard</span>
                    <span class="stat"><strong id="statSpells">0</strong> spells</span>
                    <span class="stat"><strong id="statLands">0</strong> lands</span>
                    <span class="stat"><strong id="statSide">0</strong> sideboard</span>
                    <span class="stat stat-hint">Click card for details · SB to sideboard</span>
                </div>
                <div class="deck-feedback" id="deckFeedback"></div>

                <!-- Lands -->
                <div class="lands-section">
                    <h3>Lands</h3>
                    <div class="land-controls" id="landControls">
                        <!-- Populated by JS -->
                    </div>
                </div>

                <!-- Mana Curve -->
                <div class="curve-section">
                    <h3>Mana Curve</h3>
                    <div class="histogram" id="histogram">
                        <!-- Populated by JS -->
                    </div>
                </div>

                <!-- Board tabs -->
                <div class="board-tabs">
                    <button class="board-tab active" data-board="main" onclick="switchBoard('main')">Mainboard</button>
                    <button class="board-tab" data-board="side" onclick="switchBoard('side')">Sideboard</button>
                </div>

                <!-- Deck columns -->
                <div class="deck-columns" id="deckColumns">
                    <!-- Populated by JS -->
                </div>
            </div>
        </div>
    </main>

        <!-- ══════ FAQ Section ══════ -->
        <div class="faq-section">
            <div class="container">
                <h2>MTG Draft Simulator FAQ</h2>
                <div class="faq-list">
                    <details class="faq-item">
                        <summary>How does the MTG draft simulator work?</summary>
                        <div class="faq-answer">
                            <p>Our draft simulator replicates a real 8-player booster draft. You sit at a virtual table with 7 AI opponents. Each player opens a pack of 14 cards, picks one, and passes the rest. Packs alternate passing direction each round (left, right, left). After 3 packs and 42 total picks, you build a 40-card deck from your picks plus basic lands.</p>
                        </div>
                    </details>
                    <details class="faq-item">
                        <summary>How many cards do you pick in an MTG draft?</summary>
                        <div class="faq-answer">
                            <p>In a standard booster draft, you make 42 picks total: 14 cards from each of 3 packs (14 &times; 3 = 42). You then build a minimum 40-card deck from those picks, adding basic lands as needed. Most players end up playing 22-24 spells and 16-18 lands.</p>
                        </div>
                    </details>
                    <details class="faq-item">
                        <summary>How many packs in a Magic draft?</summary>
                        <div class="faq-answer">
                            <p>A standard MTG booster draft uses 3 packs per player. With 8 players, that's 24 packs total. Pack 1 passes left, Pack 2 passes right, and Pack 3 passes left again. Each pack starts with 14 draftable cards.</p>
                        </div>
                    </details>
                    <details class="faq-item">
                        <summary>Can I practice MTG draft for free?</summary>
                        <div class="faq-answer">
                            <p>Yes! This draft simulator is completely free with no account required. Practice as many drafts as you like from 14+ real Magic sets. The AI bots use intelligent pick logic based on card ratings, color signals, and curve considerations, giving you realistic practice for paper or Arena drafts.</p>
                        </div>
                    </details>
                    <details class="faq-item">
                        <summary>What sets are available to draft?</summary>
                        <div class="faq-answer">
                            <p>We currently support 14 sets with pre-loaded card data and ratings, including recent sets like Lorwyn Eclipsed, Aetherdrift, Foundations, Duskmourn, Bloomburrow, Modern Horizons 3, and more. New sets are added regularly as they release. Each set uses real card data from Scryfall with expert-calibrated draft ratings.</p>
                        </div>
                    </details>
                    <details class="faq-item">
                        <summary>How do the AI draft bots pick cards?</summary>
                        <div class="faq-answer">
                            <p>Each AI bot uses a scoring system that considers the card's base rating, color fit (bots develop color preferences as they draft), mana curve needs, creature density targets, and open-color signals. Early picks focus on raw power, while later picks prioritize staying on-color and filling curve gaps. A small random factor prevents bots from being too predictable.</p>
                        </div>
                    </details>
                    <details class="faq-item">
                        <summary>How to export draft deck to MTG Arena?</summary>
                        <div class="faq-answer">
                            <p>After building your deck, click the "Export to Arena" button. This copies your decklist (mainboard, lands, and sideboard) in MTGA-compatible format to your clipboard. Open MTG Arena, go to Decks, click Import, and paste. Note that only cards legal in your Arena collection will be available for actual play.</p>
                        </div>
                    </details>
                    <details class="faq-item">
                        <summary>What is the best draft strategy for beginners?</summary>
                        <div class="faq-answer">
                            <p>Start with the BREAD method: <strong>B</strong>ombs (powerful rares/mythics), <strong>R</strong>emoval (cards that destroy creatures), <strong>E</strong>vasion (flying, menace, trample), <strong>A</strong>ggro (efficient creatures), <strong>D</strong>uds (everything else). Stick to 2 colors, aim for 15-17 creatures, and prioritize 2-3 mana cost cards for a smooth curve. Use our <a href="/tools/manabase/">Mana Base Calculator</a> to optimize your land count.</p>
                        </div>
                    </details>
                </div>
            </div>
        </div>

    <!-- Mobile Card Preview (bottom sheet) -->
    <div class="mobile-preview-overlay" id="mobileOverlay" onclick="closeMobilePreview()"></div>
    <div class="mobile-preview" id="mobilePreview">
        <div class="mobile-preview-handle"></div>
        <div class="mobile-preview-body">
            <div class="mobile-preview-img"><img id="mpImg" src="" alt=""></div>
            <div class="mobile-preview-info">
                <div class="mp-name" id="mpName"></div>
                <div class="mp-cost" id="mpCost"></div>
                <div class="mp-type" id="mpType"></div>
                <div class="mp-oracle" id="mpOracle"></div>
                <div class="mp-pt" id="mpPt"></div>
                <div class="mp-rating" id="mpRating"></div>
            </div>
        </div>
        <div class="mobile-preview-actions">
            <button class="btn-cancel" onclick="closeMobilePreview()">Cancel</button>
            <button class="btn-pick" id="mpPickBtn" onclick="confirmMobilePick()">Pick This Card</button>
        </div>
    </div>

    <!-- Tooltip (desktop only) -->
    <div class="card-tooltip" id="cardTooltip">
        <div class="tt-name"></div>
        <div class="tt-cost"></div>
        <div class="tt-type"></div>
        <div class="tt-oracle"></div>
        <div class="tt-pt"></div>
        <div class="tt-rating"></div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <!-- Deck Lightbox -->
    <div class="deck-lightbox-overlay" id="deckLightboxOverlay"></div>
    <div class="deck-lightbox" id="deckLightbox">
        <div class="deck-lightbox-handle"></div>
        <button class="deck-lightbox-close" id="dlClose">&times;</button>
        <button class="deck-lightbox-nav dl-prev" id="dlPrevDesktop">&#8249;</button>
        <button class="deck-lightbox-nav dl-next" id="dlNextDesktop">&#8250;</button>
        <div class="deck-lightbox-body">
            <div class="deck-lightbox-img"><img id="dlImg" src="" alt=""></div>
            <div class="deck-lightbox-info">
                <div class="dl-name" id="dlName"></div>
                <div class="dl-cost" id="dlCost"></div>
                <div class="dl-type" id="dlType"></div>
                <div class="dl-oracle" id="dlOracle"></div>
                <div class="dl-pt" id="dlPt"></div>
                <div class="dl-rating" id="dlRating"></div>
                <div class="deck-lightbox-actions">
                    <button class="dl-sb-btn" id="dlSbBtn"></button>
                </div>
            </div>
        </div>
        <div class="deck-lightbox-nav-row">
            <button id="dlPrevMobile">&#8249;</button>
            <button id="dlNextMobile">&#8250;</button>
        </div>
    </div>

    <!-- Draft Complete Celebration -->
    <div class="draft-complete-overlay" id="draftCompleteOverlay">
        <h2>Draft Complete!</h2>
        <div class="celeb-stats" id="celebStats"></div>
    </div>

    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-logo">ScrollVault</div>
                <div class="wubrg-dots">
                    <span class="mana-dot" style="background: #F9FAF4"></span>
                    <span class="mana-dot" style="background: #0E68AB"></span>
                    <span class="mana-dot" style="background: #150B00; border: 1px solid rgba(255,255,255,0.2)"></span>
                    <span class="mana-dot" style="background: #D3202A"></span>
                    <span class="mana-dot" style="background: #00733E"></span>
                </div>
                <p class="footer-text">&copy; 2026 scrollvault.net. Magic: The Gathering is a trademark of Wizards of the Coast. Card images &copy; Wizards of the Coast via Scryfall.</p>
                <ul class="footer-links">
                    <li><a href="/privacy.html">Privacy Policy</a></li>
                    <li><a href="/terms.html">Terms of Service</a></li>
                    <li><a href="/contact.html">Contact</a></li>
                    <li><a href="/about/authors.html">Authors</a></li>
                    <li><a href="/about/editorial-policy.html">Editorial Policy</a></li>
                </ul>
            </div>
        </div>
    </footer>

<script>
/* ═══════════════════════════════════════════
   MTG Draft Simulator
   ═══════════════════════════════════════════ */

// ── Touch Detection ──
const isTouchDevice = window.matchMedia('(hover: none) and (pointer: coarse)').matches;
let mobileSelectedIndex = -1;

// ── Constants ──
const COLOR_ORDER = ['W','U','B','R','G','Multi','Colorless'];
const COLOR_NAMES = { W:'White', U:'Blue', B:'Black', R:'Red', G:'Green', Multi:'Multicolor', Colorless:'Colorless' };
const COLOR_HEX = { W:'#F9FAF4', U:'#0E68AB', B:'#3d3020', R:'#D3202A', G:'#00733E', Multi:'#C5AF46', Colorless:'#9E9E9E' };
const LAND_NAMES = { W:'Plains', U:'Island', B:'Swamp', R:'Mountain', G:'Forest' };
const MANA_COLORS = ['W','U','B','R','G'];
const NUM_SEATS = 8;
const PACKS_PER_DRAFT = 3;
const CARDS_PER_PACK = 14;

// ── State ──
let setData = null;
let setsIndex = [];
let allPacks = []; // [seat][pack] = array of cards
let currentPack = 0;
let currentPick = 0;
let humanPool = [];
let humanColorWeights = { W:0, U:0, B:0, R:0, G:0 };
let botPools = []; // botPools[0..6] for bots 1-7
let botStates = []; // Enhanced bot state
let undoStack = [];
let currentBoard = 'main'; // 'main' or 'side'
let sideboardSet = new Set(); // indices into humanPool that are sideboarded
let lands = { W:0, U:0, B:0, R:0, G:0 };
let draftInProgress = false;
let showPickSuggestions = false;
let activeBuilderFilters = new Set(['all']);
let humanOpenSignals = { W:0, U:0, B:0, R:0, G:0 };
let builderSortBy = 'cmc';
let deckLightboxOpen = false;
let deckLightboxList = [];
let deckLightboxCurrent = -1;

// ── Screens ──
function showScreen(id) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(id).classList.add('active');
    window.scrollTo(0, 0);
}

// ── Toast ──
function showToast(msg) {
    const t = document.getElementById('toast');
    t.textContent = msg;
    t.classList.add('visible');
    setTimeout(() => t.classList.remove('visible'), 2500);
}

// ══════════════════════════════════════════
// Screen 1: Set Selection
// ══════════════════════════════════════════
function loadSets() {
    return fetch('/draft/data/sets.json')
        .then(resp => resp.json())
        .then(data => { setsIndex = data; renderSetGrid(); })
        .catch(e => console.error('Failed to load sets:', e));
}

function renderSetGrid() {
    const grid = document.getElementById('setGrid');
    grid.innerHTML = '';
    setsIndex.forEach(set => {
        const card = document.createElement('div');
        card.className = 'set-card';
        card.innerHTML = `
            <div class="set-card-header">
                <img src="${set.icon_uri}" alt="${set.set_name}" class="set-icon" onerror="this.style.display='none'">
                <div>
                    <h3>${set.set_name}</h3>
                    <span style="color:var(--text-muted);font-size:0.8rem;text-transform:uppercase;letter-spacing:0.5px">${set.set_code}</span>
                </div>
            </div>
            <div class="set-meta">
                <span>&#x1F0CF; ${set.card_count} cards</span>
                <span>&#128197; ${formatDate(set.released_at)}</span>
                <span>&#127183; ${set.pack_size} per pack</span>
            </div>
            <button class="btn-start" onclick="startDraft('${set.set_code}', this)">
                <span class="btn-text">Start Draft</span>
                <span class="spinner"></span>
            </button>
        `;
        grid.appendChild(card);
    });
}

function formatDate(dateStr) {
    const d = new Date(dateStr + 'T00:00:00');
    return d.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
}

// ══════════════════════════════════════════
// Draft Engine
// ══════════════════════════════════════════
async function startDraft(setCode, btn) {
    if (draftInProgress) return;
    btn.classList.add('loading');
    btn.disabled = true;

    try {
        const resp = await fetch(`/draft/data/${setCode}.json`);
        setData = await resp.json();
    } catch (e) {
        console.error('Failed to load set data:', e);
        btn.classList.remove('loading');
        btn.disabled = false;
        showToast('Failed to load set data');
        return;
    }

    // Reset state
    humanPool = [];
    humanColorWeights = { W:0, U:0, B:0, R:0, G:0 };
    botPools = [];
    botStates = [];
    undoStack = [];
    sideboardSet = new Set();
    lands = { W:0, U:0, B:0, R:0, G:0 };
    currentPack = 0;
    currentPick = 0;
    draftInProgress = true;
    showPickSuggestions = document.getElementById('showSuggestions').checked;
    humanOpenSignals = { W:0, U:0, B:0, R:0, G:0 };
    builderSortBy = 'cmc';
    deckLightboxOpen = false; deckLightboxList = []; deckLightboxCurrent = -1;

    // Init bots
    for (let i = 1; i < NUM_SEATS; i++) {
        botPools.push([]);
        botStates.push(createBotState(i));
    }

    // Init WASM worker
    initDraftWorker();

    // Generate all packs
    generateAllPacks();

    // Preload pack 1 images
    preloadPackImages(0);

    btn.classList.remove('loading');
    btn.disabled = false;

    showScreen('screenDraft');
    renderCurrentPack();
}

function generateAllPacks() {
    allPacks = [];
    const usedRares = new Set();

    for (let seat = 0; seat < NUM_SEATS; seat++) {
        allPacks[seat] = [];
        for (let pack = 0; pack < PACKS_PER_DRAFT; pack++) {
            allPacks[seat][pack] = generatePack(usedRares);
        }
    }
}

function generatePack(usedRares) {
    const cards = setData.cards;
    const pack = [];

    // 1 rare or mythic (87.5% rare, 12.5% mythic)
    let rm = null;
    let attempts = 0;
    while (!rm && attempts < 100) {
        const isMythic = Math.random() < 0.125;
        const pool = isMythic ? cards.mythic : cards.rare;
        const candidate = pool[Math.floor(Math.random() * pool.length)];
        if (!usedRares.has(candidate.collector_number)) {
            rm = candidate;
            usedRares.add(candidate.collector_number);
        }
        attempts++;
    }
    if (!rm) {
        // Fallback: pick any rare/mythic
        const allRM = [...cards.rare, ...cards.mythic];
        rm = allRM[Math.floor(Math.random() * allRM.length)];
    }
    pack.push(rm);

    // 3 uncommons (no duplicates within pack)
    const usedInPack = new Set([rm.collector_number]);
    const uncommons = pickRandom(cards.uncommon, 3, usedInPack);
    pack.push(...uncommons);

    // 10 commons (no duplicates within pack)
    const commons = pickRandom(cards.common, 10, usedInPack);
    pack.push(...commons);

    // Shuffle
    shuffle(pack);
    return pack;
}

function pickRandom(pool, count, usedSet) {
    const result = [];
    const poolCopy = [...pool];
    shuffle(poolCopy);
    for (const card of poolCopy) {
        if (result.length >= count) break;
        if (!usedSet.has(card.collector_number)) {
            result.push(card);
            usedSet.add(card.collector_number);
        }
    }
    // If not enough unique cards, allow dupes
    while (result.length < count) {
        result.push(pool[Math.floor(Math.random() * pool.length)]);
    }
    return result;
}

function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
}

// ── Pack Passing ──
function getHumanPack() {
    // Human is seat 0. After picks, packs rotate.
    // Pack 0 (1st): passes left (seat+1)
    // Pack 1 (2nd): passes right (seat-1)
    // Pack 2 (3rd): passes left (seat+1)
    // After N picks, the pack that started at seat S is now at seat (S + N*direction) mod 8
    // We need: which pack is currently in front of seat 0?
    // Pack started at seat S, after currentPick passes it's at seat (S + currentPick * dir) mod 8
    // We want (S + currentPick * dir) mod 8 == 0
    // So S = (0 - currentPick * dir) mod 8 = (-currentPick * dir) mod 8
    const dir = (currentPack % 2 === 0) ? 1 : -1; // left = +1, right = -1
    const originSeat = ((0 - currentPick * dir) % NUM_SEATS + NUM_SEATS) % NUM_SEATS;
    return allPacks[originSeat][currentPack];
}

function getBotPack(botSeat) {
    const dir = (currentPack % 2 === 0) ? 1 : -1;
    const originSeat = ((botSeat - currentPick * dir) % NUM_SEATS + NUM_SEATS) % NUM_SEATS;
    return allPacks[originSeat][currentPack];
}

// ── Bot State Factory ──
function createBotState(seatIndex) {
    return {
        seat: seatIndex || 1,
        colorWeights: { W:0, U:0, B:0, R:0, G:0 },
        curveCounts: [0, 0, 0, 0, 0, 0, 0, 0], // CMC 0-7+
        creatureCount: 0,
        spellCount: 0,
        removalCount: 0,
        openColors: [], // Colors seen late in packs (signals)
        picks: [], // DraftCard objects for get_bot_deck
        signalStrength: [0.5, 0.5, 0.5, 0.5, 0.5], // WUBRG openness
        keywordsSeen: [] // keyword clustering
    };
}

// ── Enhanced Scoring ──
function scoreCard(card, state, pickNumber) {
    let base = card.rating;

    // Color commitment (stronger as draft progresses)
    let colorFit = 0;
    if (card.colors.length === 0) {
        colorFit = 0.3; // Colorless cards always decent
    } else {
        const totalWeight = Object.values(state.colorWeights).reduce((a, b) => a + b, 0) || 1;
        colorFit = card.colors.reduce((sum, c) => sum + (state.colorWeights[c] || 0), 0) / totalWeight;
    }
    const exploitFactor = Math.min(1, Math.max(0, (pickNumber - 4) / 14));
    const colorBonus = 1.0 + (colorFit * exploitFactor * 1.8);

    // Curve needs: prefer 2-3 drops if lacking
    let curveBonus = 0;
    const cmc = Math.min(Math.ceil(card.cmc || 0), 7);
    const totalPicks = state.creatureCount + state.spellCount;
    if (totalPicks > 5) {
        if ((cmc === 2 || cmc === 3) && state.curveCounts[cmc] < 4) curveBonus = 0.4;
        else if (cmc === 1 && state.curveCounts[1] < 2) curveBonus = 0.2;
        else if (cmc >= 6 && state.curveCounts[6] + state.curveCounts[7] >= 3) curveBonus = -0.3;
    }

    // Creature density: want 14-16 creatures in final deck
    let creatureBonus = 0;
    const tl = (card.type_line || '').toLowerCase();
    const isCreature = tl.includes('creature');
    if (totalPicks > 10) {
        const creatureRatio = state.creatureCount / Math.max(1, totalPicks);
        if (isCreature && creatureRatio < 0.55) creatureBonus = 0.3;
        else if (!isCreature && creatureRatio > 0.65) creatureBonus = 0.2;
    }

    // Removal bonus
    let removalBonus = 0;
    const oracle = (card.oracle_text || '').toLowerCase();
    if (oracle.includes('destroy target') || oracle.includes('exile target') ||
        oracle.match(/deals?\s+\d+\s+damage\s+to\s+(target|any)/)) {
        removalBonus = 0.3;
    }

    // Signal reading: open colors get a small boost
    let signalBonus = 0;
    if (card.colors.length > 0 && state.openColors.length > 0) {
        const onSignal = card.colors.some(c => state.openColors.includes(c));
        if (onSignal) signalBonus = 0.2;
    }

    // Early pick rarity bonus (don't pass bombs)
    const rarityBonus = (pickNumber < 6 && (card.rarity === 'rare' || card.rarity === 'mythic')) ? 0.4 : 0;

    const jitter = Math.random() * 0.3;
    return base * colorBonus + curveBonus + creatureBonus + removalBonus + signalBonus + rarityBonus + jitter;
}

function updateBotState(botState, card) {
    card.colors.forEach(c => {
        if (botState.colorWeights[c] !== undefined) {
            botState.colorWeights[c] += card.rating;
        }
    });
    const cmc = Math.min(Math.ceil(card.cmc || 0), 7);
    botState.curveCounts[cmc]++;
    const tl = (card.type_line || '').toLowerCase();
    if (tl.includes('creature')) botState.creatureCount++;
    botState.spellCount++;

    // Track picks for WASM get_bot_deck
    botState.picks.push(card);

    // Track removal
    const oracle = (card.oracle_text || '').toLowerCase();
    if (oracle.includes('destroy target') || oracle.includes('exile target') ||
        oracle.match(/deals?\s+\d+\s+damage\s+to\s+(target|any)/)) {
        botState.removalCount++;
    }

    // Track keywords
    if (card.keywords && card.keywords.length > 0) {
        card.keywords.forEach(function(kw) {
            if (botState.keywordsSeen.indexOf(kw) === -1) {
                botState.keywordsSeen.push(kw);
            }
        });
    }
}

// ── Human color weight tracking ──
function updateHumanWeights(card) {
    card.colors.forEach(c => {
        if (humanColorWeights[c] !== undefined) {
            humanColorWeights[c] += card.rating;
        }
    });
}

// ── Human Pick ──
function humanPick(cardIndex) {
    const pack = getHumanPack();
    if (cardIndex < 0 || cardIndex >= pack.length) return;

    const card = pack[cardIndex];

    // Save undo state
    undoStack.push({
        pack: currentPack,
        pick: currentPick,
        cardIndex: cardIndex,
        card: card,
        poolLength: humanPool.length
    });

    // Remove from pack
    pack.splice(cardIndex, 1);
    humanPool.push(card);
    updateHumanWeights(card);

    // Track color signals: remaining high-rated cards late in pack indicate open colors
    if (currentPick >= 5) {
        pack.forEach(function(c) {
            if (c.rating >= 3.0) {
                c.colors.forEach(function(col) {
                    if (humanOpenSignals[col] !== undefined) {
                        humanOpenSignals[col] += (currentPick >= 9) ? 2 : 1;
                    }
                });
            }
        });
    }

    // Animate pick
    const packGrid = document.getElementById('packGrid');
    const cardEls = packGrid.querySelectorAll('.pack-card');
    if (cardEls[cardIndex]) {
        cardEls[cardIndex].classList.add('picked');
    }

    // Bot picks (WASM async or JS sync)
    doBotPicks();

    // Advance pick/pack state
    advanceDraftState();
}

function advanceDraftState() {
    currentPick++;

    if (currentPick >= CARDS_PER_PACK) {
        // Next pack
        currentPack++;
        currentPick = 0;

        if (currentPack >= PACKS_PER_DRAFT) {
            // Draft complete — show celebration overlay
            draftInProgress = false;
            var creatureCount = humanPool.filter(function(c) { return (c.type_line || '').toLowerCase().includes('creature'); }).length;
            var overlay = document.getElementById('draftCompleteOverlay');
            document.getElementById('celebStats').textContent = humanPool.length + ' cards picked \u00b7 ' + creatureCount + ' creatures';
            overlay.classList.add('visible');
            setTimeout(function() {
                overlay.classList.remove('visible');
                showScreen('screenBuild');
                renderDeckBuilder();
            }, 2200);
            return;
        }

        // Pack transition banner
        var packNum = currentPack + 1;
        var passDir = (currentPack % 2 === 0) ? 'Passing Left \u2192' : 'Passing Right \u2190';
        var banner = document.createElement('div');
        banner.className = 'pack-transition';
        banner.textContent = 'Pack ' + packNum + ' \u2014 ' + passDir;
        document.body.appendChild(banner);
        setTimeout(function() { if (banner.parentNode) banner.parentNode.removeChild(banner); }, 900);

        // Preload next pack images
        preloadPackImages(currentPack);

        // Slightly longer delay for pack transitions
        setTimeout(function() {
            renderCurrentPack();
            renderPool();
        }, 500);
        return;
    } else {
        // Preload next pack's images in background
        if (currentPick === 0) {
            preloadPackImages(currentPack);
        }
    }

    // Re-render with delay for animation
    setTimeout(function() {
        renderCurrentPack();
        renderPool();
    }, 350);
}

function doBotPicks() {
    if (wasmDraftWorker && wasmDraftReady) {
        doBotPicksWasm();
    } else {
        doBotPicksJS();
    }
}

function doBotPicksJS() {
    const globalPick = currentPack * CARDS_PER_PACK + currentPick;

    for (let b = 0; b < NUM_SEATS - 1; b++) {
        const botSeat = b + 1;
        const pack = getBotPack(botSeat);
        if (pack.length === 0) continue;

        let bestIdx = 0;
        let bestScore = -Infinity;
        for (let i = 0; i < pack.length; i++) {
            const s = scoreCard(pack[i], botStates[b], globalPick);
            if (s > bestScore) {
                bestScore = s;
                bestIdx = i;
            }
        }

        const picked = pack.splice(bestIdx, 1)[0];
        botPools[b].push(picked);
        updateBotState(botStates[b], picked);

        // Signal reading: if a good card (rating > 3) wheels late, its colors are open
        if (currentPick >= 6) {
            pack.forEach(card => {
                if (card.rating >= 3.0) {
                    card.colors.forEach(c => {
                        if (!botStates[b].openColors.includes(c)) {
                            botStates[b].openColors.push(c);
                        }
                    });
                }
            });
        }
    }
}

function doBotPicksWasm() {
    // Capture live pack references BEFORE advanceDraftState changes currentPick
    var savedGlobalPick = currentPack * CARDS_PER_PACK + currentPick;
    var botDataArr = [];
    var packDataArr = [];
    var packRefs = []; // live array refs for splicing on callback
    for (var b = 0; b < NUM_SEATS - 1; b++) {
        var botSeat = b + 1;
        var pack = getBotPack(botSeat);
        packRefs.push(pack);
        botDataArr.push({
            seat: botSeat,
            colorWeights: botStates[b].colorWeights,
            curveCounts: Array.from(botStates[b].curveCounts),
            creatureCount: botStates[b].creatureCount,
            spellCount: botStates[b].spellCount,
            removalCount: botStates[b].removalCount,
            picks: botStates[b].picks,
            signalStrength: Array.from(botStates[b].signalStrength),
            keywordsSeen: botStates[b].keywordsSeen.slice(),
            primaryColors: [],
            creatureRatio: botStates[b].creatureCount / Math.max(1, botStates[b].spellCount)
        });
        packDataArr.push(pack.slice());
    }

    wasmDraftWorker.postMessage({ type: 'bot_picks', bots: botDataArr, packs: packDataArr });

    // Store refs so onmessage can apply picks to the correct pack arrays
    pendingBotPicks = { packRefs: packRefs, globalPick: savedGlobalPick };
}

var pendingBotPicks = null;

function applyWasmBotPicks(pickIndices) {
    if (!pendingBotPicks) return;
    var packRefs = pendingBotPicks.packRefs;
    var globalPick = pendingBotPicks.globalPick;

    for (var b = 0; b < NUM_SEATS - 1; b++) {
        var pack = packRefs[b];
        if (!pack || pack.length === 0) continue;

        var bestIdx = pickIndices[b] || 0;
        if (bestIdx >= pack.length) bestIdx = 0;

        var picked = pack.splice(bestIdx, 1)[0];
        botPools[b].push(picked);
        updateBotState(botStates[b], picked);

        // Signal reading: if late in pack, note open colors
        if (globalPick >= 6) {
            pack.forEach(function(card) {
                if (card.rating >= 3.0) {
                    card.colors.forEach(function(c) {
                        if (!botStates[b].openColors.includes(c)) {
                            botStates[b].openColors.push(c);
                        }
                    });
                }
            });
        }
    }
    pendingBotPicks = null;
}

// ── Undo ──
function undoPick() {
    if (undoStack.length === 0) return;
    const last = undoStack.pop();

    // Undo bot picks: we can't perfectly undo bot picks, but we can restore the human pick
    // For simplicity, we only undo the human pick (bots already picked)
    // This means undo is approximate, but that's acceptable for a draft simulator
    // Actually, let's do a proper undo by regenerating. But that's complex.
    // Simple approach: just put the card back

    // Restore state
    currentPack = last.pack;
    currentPick = last.pick;
    humanPool.splice(last.poolLength);

    // Put card back in pack at original position
    const pack = getHumanPack();
    // Note: bots already picked from their packs, we can't undo that.
    // But we can put the human's card back.
    pack.splice(last.cardIndex, 0, last.card);

    renderCurrentPack();
    renderPool();
    showToast('Undo: pick returned');
}

// ── Image Preloading ──
function preloadPackImages(packNum) {
    if (packNum >= PACKS_PER_DRAFT) return;
    // Preload human's pack images
    const dir = (packNum % 2 === 0) ? 1 : -1;
    // At pick 0, the pack at seat 0 is the one that started at seat 0
    const pack = allPacks[0][packNum];
    if (!pack) return;
    pack.forEach(card => {
        const img = new Image();
        img.src = card.image_small;
    });
}

// ══════════════════════════════════════════
// Screen 2: Rendering
// ══════════════════════════════════════════
function renderCurrentPack() {
    const pack = getHumanPack();
    const grid = document.getElementById('packGrid');
    grid.innerHTML = '';

    // Calculate suggestion if enabled (JS fallback, WASM async overlay)
    let suggestedIdx = -1;
    if (showPickSuggestions && pack.length > 0) {
        const globalPick = currentPack * CARDS_PER_PACK + currentPick;
        const humanState = {
            colorWeights: humanColorWeights,
            curveCounts: getHumanCurveCounts(),
            creatureCount: humanPool.filter(c => (c.type_line || '').toLowerCase().includes('creature')).length,
            spellCount: humanPool.length,
            openColors: []
        };
        // JS fallback suggestion
        let bestScore = -Infinity;
        pack.forEach((card, i) => {
            const s = scoreCard(card, humanState, globalPick);
            if (s > bestScore) { bestScore = s; suggestedIdx = i; }
        });
        // Fire WASM suggestion async (will overlay if different)
        if (wasmDraftReady) {
            requestWasmSuggestion(pack, function(scores) {
                var wasmBest = 0;
                var wasmBestScore = -Infinity;
                for (var i = 0; i < scores.length; i++) {
                    if (scores[i] > wasmBestScore) { wasmBestScore = scores[i]; wasmBest = i; }
                }
                // Update suggestion highlight if different from JS
                var cards = document.querySelectorAll('#packGrid .pack-card');
                cards.forEach(function(el, idx) {
                    el.classList.remove('suggested');
                    var badge = el.querySelector('.suggestion-badge');
                    if (badge) badge.remove();
                });
                if (cards[wasmBest]) {
                    cards[wasmBest].classList.add('suggested');
                    var badge = document.createElement('span');
                    badge.className = 'suggestion-badge';
                    badge.textContent = 'TOP';
                    cards[wasmBest].appendChild(badge);
                }
            });
        }
    }

    pack.forEach((card, i) => {
        const div = document.createElement('div');
        div.className = 'pack-card rarity-' + (card.rarity || 'common') + ' pack-entering';
        div.style.animationDelay = (i * 28) + 'ms';
        if (i === suggestedIdx) div.classList.add('suggested');
        let badge = '';
        if (i === suggestedIdx) badge = '<span class="suggestion-badge">TOP</span>';
        div.innerHTML = `
            <img src="${card.image_small}" alt="${card.name}" loading="lazy">
            <span class="card-number">${i + 1}</span>
            ${badge}
        `;
        if (isTouchDevice) {
            div.addEventListener('click', (e) => {
                e.preventDefault();
                openMobilePreview(card, i);
            });
        } else {
            div.addEventListener('click', () => humanPick(i));
            div.addEventListener('mouseenter', (e) => showTooltip(card, e));
            div.addEventListener('mousemove', (e) => moveTooltip(e));
            div.addEventListener('mouseleave', hideTooltip);
        }
        grid.appendChild(div);
    });

    // Remove entrance animation class after animations complete
    setTimeout(function() {
        grid.querySelectorAll('.pack-entering').forEach(function(el) { el.classList.remove('pack-entering'); });
    }, pack.length * 28 + 320);

    // Preload next pack in background
    if (currentPick < CARDS_PER_PACK - 1) {
        // Preload remaining images already loaded
    } else if (currentPack + 1 < PACKS_PER_DRAFT) {
        preloadPackImages(currentPack + 1);
    }

    // Update header
    const packNum = currentPack + 1;
    const pickNum = currentPick + 1;
    document.getElementById('packLabel').textContent = `Pack ${packNum} \u2014 Pick ${pickNum} of ${CARDS_PER_PACK}`;

    const dir = (currentPack % 2 === 0) ? 'left' : 'right';
    const arrow = dir === 'left' ? '\u2192' : '\u2190';
    document.getElementById('passDirection').innerHTML = `Passing ${dir} ${arrow}`;

    const totalPicks = PACKS_PER_DRAFT * CARDS_PER_PACK;
    const donePicks = currentPack * CARDS_PER_PACK + currentPick;
    document.getElementById('progressFill').style.width = `${(donePicks / totalPicks) * 100}%`;
}

// ── Tooltip ──
function showTooltip(card, e) {
    const tip = document.getElementById('cardTooltip');
    tip.querySelector('.tt-name').textContent = card.name;
    tip.querySelector('.tt-cost').textContent = card.mana_cost || '';
    tip.querySelector('.tt-type').textContent = card.type_line;
    tip.querySelector('.tt-oracle').textContent = card.oracle_text || '';

    let ptText = '';
    if (card.power !== null && card.toughness !== null) {
        ptText = `${card.power}/${card.toughness}`;
    } else if (card.loyalty !== null) {
        ptText = `Loyalty: ${card.loyalty}`;
    }
    tip.querySelector('.tt-pt').textContent = ptText;
    let ratingText = `Rating: ${card.rating.toFixed(1)} \u2022 ${card.rarity}`;
    if (card.gih_wr) ratingText += ` \u2022 ${card.gih_wr}% GIH WR`;
    tip.querySelector('.tt-rating').textContent = ratingText;

    tip.classList.add('visible');
    moveTooltip(e);
}

function moveTooltip(e) {
    const tip = document.getElementById('cardTooltip');
    const pad = 15;
    let x = e.clientX + pad;
    let y = e.clientY + pad;

    // Keep on screen
    const rect = tip.getBoundingClientRect();
    if (x + 280 > window.innerWidth) x = e.clientX - 280 - pad;
    if (y + rect.height > window.innerHeight) y = e.clientY - rect.height - pad;

    tip.style.left = x + 'px';
    tip.style.top = y + 'px';
}

function hideTooltip() {
    document.getElementById('cardTooltip').classList.remove('visible');
}

// ── Pool Rendering ──
function getCardColorGroup(card) {
    if (card.colors.length > 1) return 'Multi';
    if (card.colors.length === 0) return 'Colorless';
    return card.colors[0];
}

function renderPool() {
    const container = document.getElementById('poolColors');
    container.innerHTML = '';

    // Group by color
    const groups = {};
    COLOR_ORDER.forEach(c => groups[c] = []);
    humanPool.forEach(card => {
        const group = getCardColorGroup(card);
        groups[group].push(card);
    });

    // Sort within groups by CMC
    Object.values(groups).forEach(arr => arr.sort((a, b) => a.cmc - b.cmc));

    COLOR_ORDER.forEach(color => {
        if (groups[color].length === 0) return;
        const div = document.createElement('div');
        div.className = 'pool-color-group';
        const borderStyle = color === 'B' ? '1px solid rgba(255,255,255,0.2)' : 'none';
        div.innerHTML = `
            <div class="pool-color-label">
                <span class="pool-color-dot" style="background:${COLOR_HEX[color]};border:${borderStyle}"></span>
                ${COLOR_NAMES[color]} (${groups[color].length})
            </div>
            <div class="pool-color-cards">
                ${groups[color].map(card => {
                    const idx = humanPool.indexOf(card);
                    if (isTouchDevice) {
                        return `<div class="pool-mini-card" onclick="showPoolCardPreview(${idx})">
                            <img src="${card.image_small}" alt="${card.name}" loading="lazy">
                        </div>`;
                    } else {
                        return `<div class="pool-mini-card" onmouseenter="showTooltip(humanPool[${idx}], event)" onmousemove="moveTooltip(event)" onmouseleave="hideTooltip()">
                            <img src="${card.image_small}" alt="${card.name}" loading="lazy">
                        </div>`;
                    }
                }).join('')}
            </div>
        `;
        container.appendChild(div);
    });

    // Update pool count
    document.getElementById('poolCount').textContent = `${humanPool.length} cards`;

    // Update mini mana curve
    updateMiniCurve();

    // Update draft signals and stats
    renderDraftSignals();
    renderDraftStats();
}

function updateMiniCurve() {
    const counts = [0, 0, 0, 0, 0]; // CMC 1, 2, 3, 4, 5+
    humanPool.forEach(card => {
        const cmc = Math.min(Math.max(Math.ceil(card.cmc), 1), 5);
        if (card.cmc === 0) return; // lands
        if (cmc >= 5) counts[4]++;
        else counts[cmc - 1]++;
    });

    const max = Math.max(...counts, 1);
    const bars = document.querySelectorAll('#miniCurveBars .curve-bar');
    bars.forEach((bar, i) => {
        const h = (counts[i] / max) * 36;
        bar.style.height = Math.max(2, h) + 'px';
        bar.querySelector('.curve-bar-count').textContent = counts[i] || '';
    });
}

// ── Draft Signal Dots ──
function renderDraftSignals() {
    var container = document.getElementById('draftSignals');
    if (humanPool.length < 3) { container.classList.remove('visible'); return; }
    container.classList.add('visible');

    var maxWeight = Math.max.apply(null, MANA_COLORS.map(function(c) { return humanColorWeights[c]; })) || 1;
    var maxSignal = Math.max.apply(null, MANA_COLORS.map(function(c) { return humanOpenSignals[c]; })) || 1;

    container.querySelectorAll('.signal-dot').forEach(function(dot) {
        var c = dot.dataset.color;
        var commitment = humanColorWeights[c] / maxWeight;
        var openness = humanOpenSignals[c] / maxSignal;
        dot.querySelector('.signal-fill').style.opacity = Math.max(0.1, commitment * 0.9);
        dot.classList.toggle('open', openness > 0.4 && humanOpenSignals[c] >= 2);
    });
}

// ── Draft Stats (Creatures / Spells / Removal) ──
function renderDraftStats() {
    var el = document.getElementById('poolDraftStats');
    if (humanPool.length === 0) { el.textContent = ''; return; }
    var creatures = 0, removal = 0;
    humanPool.forEach(function(card) {
        var tl = (card.type_line || '').toLowerCase();
        if (tl.includes('creature')) creatures++;
        var oracle = (card.oracle_text || '').toLowerCase();
        if (oracle.includes('destroy target') || oracle.includes('exile target') ||
            oracle.match(/deals?\s+\d+\s+damage\s+to\s+(target|any)/)) removal++;
    });
    var noncreature = humanPool.length - creatures;
    el.textContent = creatures + ' creatures \u00b7 ' + noncreature + ' noncreature \u00b7 ' + removal + ' removal';
}

// ── Mobile Preview ──
function openMobilePreview(card, index) {
    mobileSelectedIndex = index;

    // Highlight selected card in grid
    document.querySelectorAll('.pack-card').forEach((el, i) => {
        el.classList.toggle('selected', i === index);
    });

    // Fill preview panel
    document.getElementById('mpImg').src = card.image_normal || card.image_small;
    document.getElementById('mpName').textContent = card.name;
    document.getElementById('mpCost').textContent = card.mana_cost || '';
    document.getElementById('mpType').textContent = card.type_line;
    document.getElementById('mpOracle').textContent = card.oracle_text || '';

    let ptText = '';
    if (card.power !== null && card.toughness !== null) ptText = `${card.power}/${card.toughness}`;
    else if (card.loyalty !== null) ptText = `Loyalty: ${card.loyalty}`;
    document.getElementById('mpPt').textContent = ptText;
    document.getElementById('mpRating').textContent = `Rating: ${card.rating.toFixed(1)} \u2022 ${card.rarity}` + (card.gih_wr ? ` \u2022 ${card.gih_wr}% GIH WR` : '');

    // Show pick button and panel
    document.getElementById('mpPickBtn').style.display = '';
    document.getElementById('mobileOverlay').classList.add('visible');
    document.getElementById('mobilePreview').classList.add('visible');
}

function closeMobilePreview() {
    mobileSelectedIndex = -1;
    document.querySelectorAll('.pack-card').forEach(el => el.classList.remove('selected'));
    document.getElementById('mobileOverlay').classList.remove('visible');
    document.getElementById('mobilePreview').classList.remove('visible');
}

function confirmMobilePick() {
    if (mobileSelectedIndex < 0) return;
    const idx = mobileSelectedIndex;
    closeMobilePreview();
    humanPick(idx);
}

function showPoolCardPreview(poolIndex) {
    const card = humanPool[poolIndex];
    if (!card) return;
    document.getElementById('mpImg').src = card.image_normal || card.image_small;
    document.getElementById('mpName').textContent = card.name;
    document.getElementById('mpCost').textContent = card.mana_cost || '';
    document.getElementById('mpType').textContent = card.type_line;
    document.getElementById('mpOracle').textContent = card.oracle_text || '';
    let ptText = '';
    if (card.power !== null && card.toughness !== null) ptText = `${card.power}/${card.toughness}`;
    else if (card.loyalty !== null) ptText = `Loyalty: ${card.loyalty}`;
    document.getElementById('mpPt').textContent = ptText;
    document.getElementById('mpRating').textContent = `Rating: ${card.rating.toFixed(1)} \u2022 ${card.rarity}` + (card.gih_wr ? ` \u2022 ${card.gih_wr}% GIH WR` : '');
    // Hide pick button for pool view
    document.getElementById('mpPickBtn').style.display = 'none';
    mobileSelectedIndex = -1;
    document.getElementById('mobileOverlay').classList.add('visible');
    document.getElementById('mobilePreview').classList.add('visible');
}

// ── Keyboard ──
document.addEventListener('keydown', (e) => {
    if (!draftInProgress) return;
    const screen = document.getElementById('screenDraft');
    if (!screen.classList.contains('active')) return;

    if (e.key === 'z' || e.key === 'Z') {
        e.preventDefault();
        undoPick();
        return;
    }

    const num = parseInt(e.key);
    if (num >= 1 && num <= 9) {
        e.preventDefault();
        humanPick(num - 1);
    }
});

// ══════════════════════════════════════════
// Screen 3: Deck Builder
// ══════════════════════════════════════════
function renderDeckBuilder() {
    sideboardSet = new Set();
    lands = { W:0, U:0, B:0, R:0, G:0 };
    currentBoard = 'main';
    activeBuilderFilters = new Set(['all']);
    document.querySelectorAll('#builderColorFilters .color-filter').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.color === 'all');
    });

    renderLandControls();
    renderDeckColumns();
    renderHistogram();
    updateDeckStats();

    // Set board tab active
    document.querySelectorAll('.board-tab').forEach(t => t.classList.toggle('active', t.dataset.board === 'main'));
}

function switchBoard(board) {
    currentBoard = board;
    document.querySelectorAll('.board-tab').forEach(t => t.classList.toggle('active', t.dataset.board === board));
    renderDeckColumns();
}

function toggleSideboard(poolIndex) {
    if (sideboardSet.has(poolIndex)) {
        sideboardSet.delete(poolIndex);
    } else {
        sideboardSet.add(poolIndex);
    }
    renderDeckColumns();
    renderHistogram();
    updateDeckStats();
}

function filterBuilder(color) {
    if (color === 'all') {
        activeBuilderFilters = new Set(['all']);
    } else {
        activeBuilderFilters.delete('all');
        if (activeBuilderFilters.has(color)) activeBuilderFilters.delete(color);
        else activeBuilderFilters.add(color);
        if (activeBuilderFilters.size === 0) activeBuilderFilters = new Set(['all']);
    }
    document.querySelectorAll('#builderColorFilters .color-filter').forEach(btn => {
        btn.classList.toggle('active', activeBuilderFilters.has(btn.dataset.color));
    });
    renderDeckColumns();
}

function cardMatchesBuilderFilter(card) {
    if (activeBuilderFilters.has('all')) return true;
    const colors = card.colors || [];
    const tl = (card.type_line || '').toLowerCase();
    if (activeBuilderFilters.has('C') && colors.length === 0 && !tl.includes('land')) return true;
    if (activeBuilderFilters.has('M') && colors.length > 1) return true;
    for (const c of colors) {
        if (activeBuilderFilters.has(c)) return true;
    }
    return false;
}

function renderDeckColumns() {
    const container = document.getElementById('deckColumns');
    container.innerHTML = '';

    // Filter cards for current board view
    const mainCards = [];
    const sideCards = [];
    humanPool.forEach((card, i) => {
        if (sideboardSet.has(i)) {
            sideCards.push({ card, index: i });
        } else {
            mainCards.push({ card, index: i });
        }
    });

    const displayCards = currentBoard === 'main' ? mainCards : sideCards;

    // Group by color
    const groups = {};
    COLOR_ORDER.forEach(c => groups[c] = []);
    displayCards.forEach(({ card, index }) => {
        const group = getCardColorGroup(card);
        groups[group].push({ card, index });
    });

    // Sort within group based on builderSortBy
    Object.values(groups).forEach(function(arr) {
        if (builderSortBy === 'rating') {
            arr.sort(function(a, b) { return (b.card.rating || 0) - (a.card.rating || 0) || a.card.name.localeCompare(b.card.name); });
        } else if (builderSortBy === 'name') {
            arr.sort(function(a, b) { return a.card.name.localeCompare(b.card.name); });
        } else {
            arr.sort(function(a, b) { return a.card.cmc - b.card.cmc || a.card.name.localeCompare(b.card.name); });
        }
    });

    COLOR_ORDER.forEach(color => {
        if (groups[color].length === 0) return;

        const col = document.createElement('div');
        col.className = 'deck-column';
        const borderStyle = color === 'B' ? '1px solid rgba(255,255,255,0.2)' : 'none';
        col.innerHTML = `
            <div class="deck-col-header" style="border-color:${COLOR_HEX[color]}">
                <span class="col-dot" style="background:${COLOR_HEX[color]};border:${borderStyle}"></span>
                ${COLOR_NAMES[color]} (${groups[color].length})
            </div>
        `;

        groups[color].forEach(({ card, index }) => {
            const entry = document.createElement('div');
            entry.className = 'deck-card-entry';
            if (sideboardSet.has(index)) entry.classList.add('sideboarded');
            if (!cardMatchesBuilderFilter(card)) entry.style.display = 'none';

            // Rating badge
            var r = card.rating || 0;
            var ratingClass = r >= 3.5 ? 'rating-good' : (r >= 2.5 ? 'rating-ok' : 'rating-bad');
            var sbLabel = sideboardSet.has(index) ? 'MB' : 'SB';

            entry.innerHTML = `
                <div class="entry-img"><img src="${card.image_small}" alt="${card.name}" loading="lazy"></div>
                <span class="entry-name">${card.name}</span>
                <span class="entry-rating ${ratingClass}">${r.toFixed(1)}</span>
                <span class="entry-cmc">${card.cmc > 0 ? card.mana_cost : ''}</span>
                <button class="entry-sb-btn" title="${sbLabel === 'SB' ? 'Move to sideboard' : 'Move to mainboard'}">${sbLabel}</button>
            `;

            // SB button click handler (stopPropagation)
            var sbBtn = entry.querySelector('.entry-sb-btn');
            sbBtn.addEventListener('click', function(e) { e.stopPropagation(); toggleSideboard(index); });

            entry.addEventListener('click', () => openDeckLightbox(index));
            if (!isTouchDevice) {
                entry.addEventListener('mouseenter', (e) => showTooltip(card, e));
                entry.addEventListener('mousemove', (e) => moveTooltip(e));
                entry.addEventListener('mouseleave', hideTooltip);
            }
            col.appendChild(entry);
        });

        container.appendChild(col);
    });
}

// ── Deck Lightbox ──
function buildDeckLightboxList() {
    var mainCards = [];
    var sideCards = [];
    humanPool.forEach(function(card, i) {
        if (sideboardSet.has(i)) { sideCards.push({ card: card, poolIndex: i }); }
        else { mainCards.push({ card: card, poolIndex: i }); }
    });
    var displayCards = currentBoard === 'main' ? mainCards : sideCards;
    var groups = {};
    COLOR_ORDER.forEach(function(c) { groups[c] = []; });
    displayCards.forEach(function(item) {
        var group = getCardColorGroup(item.card);
        if (!cardMatchesBuilderFilter(item.card)) return;
        groups[group].push(item);
    });
    Object.values(groups).forEach(function(arr) {
        if (builderSortBy === 'rating') {
            arr.sort(function(a, b) { return (b.card.rating || 0) - (a.card.rating || 0) || a.card.name.localeCompare(b.card.name); });
        } else if (builderSortBy === 'name') {
            arr.sort(function(a, b) { return a.card.name.localeCompare(b.card.name); });
        } else {
            arr.sort(function(a, b) { return a.card.cmc - b.card.cmc || a.card.name.localeCompare(b.card.name); });
        }
    });
    var flat = [];
    COLOR_ORDER.forEach(function(color) { flat = flat.concat(groups[color]); });
    return flat;
}

function openDeckLightbox(poolIndex) {
    deckLightboxList = buildDeckLightboxList();
    deckLightboxCurrent = -1;
    for (var i = 0; i < deckLightboxList.length; i++) {
        if (deckLightboxList[i].poolIndex === poolIndex) { deckLightboxCurrent = i; break; }
    }
    if (deckLightboxCurrent === -1) return;
    deckLightboxOpen = true;
    populateDeckLightbox();
    document.getElementById('deckLightboxOverlay').classList.add('visible');
    document.getElementById('deckLightbox').classList.add('visible');
    document.body.style.overflow = 'hidden';
}

function populateDeckLightbox() {
    var item = deckLightboxList[deckLightboxCurrent];
    if (!item) return;
    var card = item.card;
    document.getElementById('dlImg').src = card.image_normal || card.image_small;
    document.getElementById('dlImg').alt = card.name;
    document.getElementById('dlName').textContent = card.name;
    document.getElementById('dlCost').textContent = card.mana_cost || '';
    document.getElementById('dlType').textContent = card.type_line || '';
    document.getElementById('dlOracle').textContent = card.oracle_text || '';
    var ptText = '';
    if (card.power !== null && card.power !== undefined && card.toughness !== null && card.toughness !== undefined) {
        ptText = card.power + '/' + card.toughness;
    } else if (card.loyalty !== null && card.loyalty !== undefined) {
        ptText = 'Loyalty: ' + card.loyalty;
    }
    document.getElementById('dlPt').textContent = ptText;
    var r = card.rating || 0;
    var ratingText = 'Rating: ' + r.toFixed(1) + ' \u2022 ' + (card.rarity || '');
    if (card.gih_wr) ratingText += ' \u2022 ' + card.gih_wr + '% GIH WR';
    document.getElementById('dlRating').textContent = ratingText;
    // SB button
    var sbBtn = document.getElementById('dlSbBtn');
    var isSB = sideboardSet.has(item.poolIndex);
    sbBtn.textContent = isSB ? 'Move to Mainboard' : 'Move to Sideboard';
    sbBtn.className = 'dl-sb-btn' + (isSB ? ' in-sideboard' : '');
    // Nav buttons
    var hasPrev = deckLightboxCurrent > 0;
    var hasNext = deckLightboxCurrent < deckLightboxList.length - 1;
    document.getElementById('dlPrevDesktop').disabled = !hasPrev;
    document.getElementById('dlNextDesktop').disabled = !hasNext;
    document.getElementById('dlPrevMobile').disabled = !hasPrev;
    document.getElementById('dlNextMobile').disabled = !hasNext;
}

function closeDeckLightbox() {
    deckLightboxOpen = false;
    document.getElementById('deckLightboxOverlay').classList.remove('visible');
    document.getElementById('deckLightbox').classList.remove('visible');
    document.body.style.overflow = '';
}

function navigateDeckLightbox(delta) {
    var next = deckLightboxCurrent + delta;
    if (next < 0 || next >= deckLightboxList.length) return;
    deckLightboxCurrent = next;
    populateDeckLightbox();
}

// Lightbox event wiring
(function() {
    document.getElementById('deckLightboxOverlay').addEventListener('click', closeDeckLightbox);
    document.getElementById('dlClose').addEventListener('click', closeDeckLightbox);
    document.getElementById('dlPrevDesktop').addEventListener('click', function() { navigateDeckLightbox(-1); });
    document.getElementById('dlNextDesktop').addEventListener('click', function() { navigateDeckLightbox(1); });
    document.getElementById('dlPrevMobile').addEventListener('click', function() { navigateDeckLightbox(-1); });
    document.getElementById('dlNextMobile').addEventListener('click', function() { navigateDeckLightbox(1); });
    document.getElementById('dlSbBtn').addEventListener('click', function() {
        var item = deckLightboxList[deckLightboxCurrent];
        if (!item) return;
        toggleSideboard(item.poolIndex);
        // Rebuild list since board changed; card may have moved boards
        deckLightboxList = buildDeckLightboxList();
        // Try to stay on same card
        var found = -1;
        for (var i = 0; i < deckLightboxList.length; i++) {
            if (deckLightboxList[i].poolIndex === item.poolIndex) { found = i; break; }
        }
        if (found >= 0) {
            deckLightboxCurrent = found;
            populateDeckLightbox();
        } else {
            closeDeckLightbox();
        }
    });
    // Keyboard
    document.addEventListener('keydown', function(e) {
        if (!deckLightboxOpen) return;
        if (e.key === 'Escape') { e.preventDefault(); closeDeckLightbox(); }
        else if (e.key === 'ArrowLeft') { e.preventDefault(); navigateDeckLightbox(-1); }
        else if (e.key === 'ArrowRight') { e.preventDefault(); navigateDeckLightbox(1); }
    });
    // Touch swipe on lightbox
    var touchStartX = 0;
    var touchStartY = 0;
    var lb = document.getElementById('deckLightbox');
    lb.addEventListener('touchstart', function(e) {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
    }, { passive: true });
    lb.addEventListener('touchend', function(e) {
        if (!deckLightboxOpen) return;
        var dx = e.changedTouches[0].clientX - touchStartX;
        var dy = e.changedTouches[0].clientY - touchStartY;
        if (Math.abs(dx) > 50 && Math.abs(dx) > Math.abs(dy) * 1.5) {
            if (dx < 0) navigateDeckLightbox(1);   // swipe left = next
            else navigateDeckLightbox(-1);          // swipe right = prev
        }
    }, { passive: true });
})();

function renderHistogram() {
    const container = document.getElementById('histogram');
    container.innerHTML = '';

    // Count CMC for mainboard cards only
    const counts = [0, 0, 0, 0, 0, 0, 0]; // 0, 1, 2, 3, 4, 5, 6+
    humanPool.forEach((card, i) => {
        if (sideboardSet.has(i)) return;
        const cmc = Math.min(Math.ceil(card.cmc), 6);
        if (card.type_line && card.type_line.toLowerCase().includes('land')) return;
        counts[Math.max(0, cmc)]++;
    });

    // Color distribution for bars
    const colorCounts = {};
    MANA_COLORS.forEach(c => colorCounts[c] = [0,0,0,0,0,0,0]);
    humanPool.forEach((card, i) => {
        if (sideboardSet.has(i)) return;
        if (card.type_line && card.type_line.toLowerCase().includes('land')) return;
        const cmc = Math.min(Math.ceil(card.cmc), 6);
        const bucket = Math.max(0, cmc);
        const group = getCardColorGroup(card);
        if (MANA_COLORS.includes(group)) {
            colorCounts[group][bucket]++;
        }
    });

    const idealCurve = [0, 2, 6, 5, 4, 2, 1]; // ideal limited creature curve
    const max = Math.max(Math.max.apply(null, counts), Math.max.apply(null, idealCurve), 1);
    const labels = ['0', '1', '2', '3', '4', '5', '6+'];

    labels.forEach((label, i) => {
        const col = document.createElement('div');
        col.className = 'histo-col';
        const h = (counts[i] / max) * 80;
        const idealH = (idealCurve[i] / max) * 80;
        col.innerHTML = `
            <span class="histo-count">${counts[i] || ''}</span>
            <div class="histo-bar-area">
                <div class="histo-ideal" style="height:${Math.max(0, idealH)}px"></div>
                <div class="histo-bar" style="height:${Math.max(0, h)}px"></div>
            </div>
            <span class="histo-label">${label}</span>
        `;
        container.appendChild(col);
    });
}

function renderLandControls() {
    const container = document.getElementById('landControls');
    container.innerHTML = '';

    const colorInfo = [
        { c: 'W', name: 'Plains', bg: '#F9FAF4', fg: '#333' },
        { c: 'U', name: 'Island', bg: '#0E68AB', fg: '#fff' },
        { c: 'B', name: 'Swamp', bg: '#3d3020', fg: '#fff' },
        { c: 'R', name: 'Mountain', bg: '#D3202A', fg: '#fff' },
        { c: 'G', name: 'Forest', bg: '#00733E', fg: '#fff' }
    ];

    colorInfo.forEach(info => {
        const ctrl = document.createElement('div');
        ctrl.className = 'land-control';
        ctrl.innerHTML = `
            <div class="land-symbol" style="background:${info.bg};color:${info.fg}">${info.c}</div>
            <button onclick="changeLand('${info.c}', -1)">&minus;</button>
            <span class="land-count" id="land-${info.c}">${lands[info.c]}</span>
            <button onclick="changeLand('${info.c}', 1)">+</button>
        `;
        container.appendChild(ctrl);
    });

    // Total lands display
    const total = document.createElement('div');
    total.style.cssText = 'margin-left:0.5rem;font-size:0.85rem;color:var(--text-secondary)';
    total.id = 'landTotal';
    total.textContent = `Total: ${Object.values(lands).reduce((a, b) => a + b, 0)} lands`;
    container.appendChild(total);

    // Auto suggest button is in builder-actions
}

function changeLand(color, delta) {
    lands[color] = Math.max(0, lands[color] + delta);
    document.getElementById(`land-${color}`).textContent = lands[color];
    document.getElementById('landTotal').textContent = `Total: ${Object.values(lands).reduce((a, b) => a + b, 0)} lands`;
    updateDeckStats();
}

function autoSuggestLands() {
    // Count color pips in mainboard cards
    const pips = { W:0, U:0, B:0, R:0, G:0 };

    humanPool.forEach((card, i) => {
        if (sideboardSet.has(i)) return;
        if (!card.mana_cost) return;
        const cost = card.mana_cost;
        (cost.match(/\{W\}/g) || []).forEach(() => pips.W++);
        (cost.match(/\{U\}/g) || []).forEach(() => pips.U++);
        (cost.match(/\{B\}/g) || []).forEach(() => pips.B++);
        (cost.match(/\{R\}/g) || []).forEach(() => pips.R++);
        (cost.match(/\{G\}/g) || []).forEach(() => pips.G++);
    });

    const totalPips = Object.values(pips).reduce((a, b) => a + b, 0) || 1;
    const mainSpells = humanPool.filter((c, i) => !sideboardSet.has(i)).length;
    const targetLands = Math.max(0, 40 - mainSpells); // Usually aim for 40-card deck with ~17 lands
    const desiredLands = Math.min(Math.max(targetLands, 15), 18);

    // Distribute lands proportional to pips
    const newLands = { W:0, U:0, B:0, R:0, G:0 };
    let assigned = 0;

    // First pass: proportional
    MANA_COLORS.forEach(c => {
        if (pips[c] > 0) {
            newLands[c] = Math.round((pips[c] / totalPips) * desiredLands);
            assigned += newLands[c];
        }
    });

    // Adjust to hit target
    const activeColors = MANA_COLORS.filter(c => pips[c] > 0);
    while (assigned > desiredLands && activeColors.length > 0) {
        // Remove from smallest
        activeColors.sort((a, b) => newLands[a] - newLands[b]);
        for (const c of activeColors) {
            if (assigned <= desiredLands) break;
            if (newLands[c] > 0) { newLands[c]--; assigned--; }
        }
    }
    while (assigned < desiredLands && activeColors.length > 0) {
        // Add to largest pip color
        activeColors.sort((a, b) => pips[b] - pips[a]);
        for (const c of activeColors) {
            if (assigned >= desiredLands) break;
            newLands[c]++; assigned++;
        }
    }

    lands = newLands;
    MANA_COLORS.forEach(c => {
        const el = document.getElementById(`land-${c}`);
        if (el) el.textContent = lands[c];
    });
    document.getElementById('landTotal').textContent = `Total: ${Object.values(lands).reduce((a, b) => a + b, 0)} lands`;
    updateDeckStats();
    showToast(`Suggested ${desiredLands} lands based on color pips`);
}

function updateDeckStats() {
    const mainCards = humanPool.filter((c, i) => !sideboardSet.has(i));
    const sideCards = humanPool.filter((c, i) => sideboardSet.has(i));
    const totalLands = Object.values(lands).reduce((a, b) => a + b, 0);

    document.getElementById('statMain').textContent = mainCards.length + totalLands;
    document.getElementById('statSpells').textContent = mainCards.length;
    document.getElementById('statLands').textContent = totalLands;
    document.getElementById('statSide').textContent = sideCards.length;

    renderDeckFeedback();
}

// ── Sort Builder Toggle ──
function sortBuilderBy(mode) {
    builderSortBy = mode;
    document.querySelectorAll('.builder-sort-buttons .sort-btn').forEach(function(btn) {
        btn.classList.toggle('active', btn.dataset.sort === mode);
    });
    renderDeckColumns();
}

// ── Deck Quality Feedback ──
function renderDeckFeedback() {
    var el = document.getElementById('deckFeedback');
    if (!el) return;
    el.innerHTML = '';

    var mainCards = humanPool.filter(function(c, i) { return !sideboardSet.has(i); });
    var totalLands = Object.values(lands).reduce(function(a, b) { return a + b; }, 0);
    var deckSize = mainCards.length + totalLands;

    var creatures = 0, removal = 0, totalCmc = 0, nonlandCount = 0;
    mainCards.forEach(function(card) {
        var tl = (card.type_line || '').toLowerCase();
        if (tl.includes('creature')) creatures++;
        var oracle = (card.oracle_text || '').toLowerCase();
        if (oracle.includes('destroy target') || oracle.includes('exile target') ||
            oracle.match(/deals?\s+\d+\s+damage\s+to\s+(target|any)/)) removal++;
        if (!tl.includes('land')) { totalCmc += card.cmc || 0; nonlandCount++; }
    });

    var avgCmc = nonlandCount > 0 ? totalCmc / nonlandCount : 0;
    var items = [];

    // Creature count
    if (creatures >= 14 && creatures <= 16) {
        items.push({ text: 'Creature count looks good (' + creatures + ')', good: true });
    } else if (creatures < 14) {
        items.push({ text: 'Low creatures (' + creatures + ', want 14\u201316)', good: false });
    } else {
        items.push({ text: 'High creatures (' + creatures + ', want 14\u201316)', good: false });
    }

    // Removal
    if (removal >= 3 && removal <= 5) {
        items.push({ text: 'Removal looks good (' + removal + ')', good: true });
    } else if (removal < 3) {
        items.push({ text: 'Low removal (' + removal + ', want 3\u20135)', good: false });
    } else {
        items.push({ text: 'Lots of removal (' + removal + ')', good: true });
    }

    // Avg CMC
    if (avgCmc > 0) {
        if (avgCmc <= 3.0) {
            items.push({ text: 'Avg CMC ' + avgCmc.toFixed(1), good: true });
        } else {
            items.push({ text: 'High avg CMC (' + avgCmc.toFixed(1) + ', want \u22643.0)', good: false });
        }
    }

    // Deck size
    if (deckSize === 40) {
        items.push({ text: 'Deck is 40 cards', good: true });
    } else if (deckSize > 0) {
        items.push({ text: 'Deck is ' + deckSize + ' cards (want 40)', good: deckSize >= 39 && deckSize <= 41 });
    }

    // Land count
    if (totalLands >= 16 && totalLands <= 18) {
        items.push({ text: totalLands + ' lands', good: true });
    } else if (totalLands > 0 && totalLands < 16) {
        items.push({ text: 'Low lands (' + totalLands + ', want 16\u201318)', good: false });
    } else if (totalLands > 18) {
        items.push({ text: 'High lands (' + totalLands + ', want 16\u201318)', good: false });
    }

    items.forEach(function(item) {
        var span = document.createElement('span');
        span.className = 'feedback-item ' + (item.good ? 'good' : 'warn');
        span.textContent = item.text;
        el.appendChild(span);
    });
}

// ── Export ──
function exportDeck() {
    let text = '';

    // Mainboard spells sorted by name
    const mainCards = [];
    humanPool.forEach((card, i) => {
        if (!sideboardSet.has(i)) mainCards.push(card);
    });

    // Group and count
    const mainCounts = {};
    mainCards.forEach(card => {
        mainCounts[card.name] = (mainCounts[card.name] || 0) + 1;
    });

    text += 'Deck\n';
    Object.keys(mainCounts).sort().forEach(name => {
        text += `${mainCounts[name]} ${name}\n`;
    });

    // Lands
    MANA_COLORS.forEach(c => {
        if (lands[c] > 0) {
            text += `${lands[c]} ${LAND_NAMES[c]}\n`;
        }
    });

    // Sideboard
    const sideCounts = {};
    humanPool.forEach((card, i) => {
        if (sideboardSet.has(i)) {
            sideCounts[card.name] = (sideCounts[card.name] || 0) + 1;
        }
    });

    if (Object.keys(sideCounts).length > 0) {
        text += '\nSideboard\n';
        Object.keys(sideCounts).sort().forEach(name => {
            text += `${sideCounts[name]} ${name}\n`;
        });
    }

    navigator.clipboard.writeText(text).then(() => {
        showToast('Deck copied to clipboard (Arena format)');
    }).catch(() => {
        // Fallback
        const ta = document.createElement('textarea');
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        showToast('Deck copied to clipboard (Arena format)');
    });
}

// ── Actions ──
function draftAgain() {
    if (setData) {
        humanPool = [];
        humanColorWeights = { W:0, U:0, B:0, R:0, G:0 };
        botPools = [];
        botStates = [];
        undoStack = [];
        sideboardSet = new Set();
        lands = { W:0, U:0, B:0, R:0, G:0 };
        currentPack = 0;
        currentPick = 0;
        draftInProgress = true;
        showPickSuggestions = document.getElementById('showSuggestions').checked;
        humanOpenSignals = { W:0, U:0, B:0, R:0, G:0 };
        builderSortBy = 'cmc';
        deckLightboxOpen = false; deckLightboxList = []; deckLightboxCurrent = -1;

        for (let i = 1; i < NUM_SEATS; i++) {
            botPools.push([]);
            botStates.push(createBotState(i));
        }
        initDraftWorker();

        generateAllPacks();
        preloadPackImages(0);
        showScreen('screenDraft');
        renderCurrentPack();
        renderPool();
    }
}

function changeSet() {
    draftInProgress = false;
    showScreen('screenSelect');
}

// ── Helper: human curve counts for suggestion scoring ──
function getHumanCurveCounts() {
    const counts = [0, 0, 0, 0, 0, 0, 0, 0];
    humanPool.forEach(card => {
        const cmc = Math.min(Math.ceil(card.cmc || 0), 7);
        counts[cmc]++;
    });
    return counts;
}

// ── Auto-Build Deck ──
function autoBuildDeck() {
    if (humanPool.length === 0) return;

    // Score each color
    const colorScores = { W:0, U:0, B:0, R:0, G:0 };
    humanPool.forEach(card => {
        if ((card.type_line || '').toLowerCase().includes('land')) return;
        const score = card.rating || 2.0;
        (card.colors || []).forEach(c => { if (colorScores[c] !== undefined) colorScores[c] += score; });
    });

    // Pick top 2 colors
    const sortedColors = MANA_COLORS.slice().sort((a, b) => colorScores[b] - colorScores[a]);
    const primaryColors = new Set([sortedColors[0], sortedColors[1]]);

    // Select on-color cards, sorted by power
    const candidates = [];
    humanPool.forEach((card, idx) => {
        if ((card.type_line || '').toLowerCase().includes('land')) return;
        const colors = card.colors || [];
        const isOnColor = colors.length === 0 || colors.some(c => primaryColors.has(c));
        if (isOnColor) candidates.push({ idx, card, score: card.rating || 2.0 });
    });
    candidates.sort((a, b) => b.score - a.score);

    // Take best 23 spells, sideboard the rest
    sideboardSet = new Set();
    const selected = new Set(candidates.slice(0, 23).map(c => c.idx));
    humanPool.forEach((_, idx) => {
        if (!selected.has(idx)) sideboardSet.add(idx);
    });

    // Auto-suggest lands for the selected cards
    const pips = { W:0, U:0, B:0, R:0, G:0 };
    candidates.slice(0, 23).forEach(({ card }) => {
        const cost = card.mana_cost || '';
        (cost.match(/\{W\}/g) || []).forEach(() => pips.W++);
        (cost.match(/\{U\}/g) || []).forEach(() => pips.U++);
        (cost.match(/\{B\}/g) || []).forEach(() => pips.B++);
        (cost.match(/\{R\}/g) || []).forEach(() => pips.R++);
        (cost.match(/\{G\}/g) || []).forEach(() => pips.G++);
    });

    const totalPips = Object.values(pips).reduce((a, b) => a + b, 0) || 1;
    lands = { W:0, U:0, B:0, R:0, G:0 };
    let assigned = 0;
    MANA_COLORS.forEach(c => {
        if (pips[c] > 0) {
            lands[c] = Math.round((pips[c] / totalPips) * 17);
            assigned += lands[c];
        }
    });
    const activeColors = MANA_COLORS.filter(c => pips[c] > 0).sort((a, b) => pips[b] - pips[a]);
    while (assigned < 17 && activeColors.length > 0) { lands[activeColors[0]]++; assigned++; }
    while (assigned > 17) {
        const smallest = activeColors.filter(c => lands[c] > 0).sort((a, b) => lands[a] - lands[b])[0];
        if (smallest) { lands[smallest]--; assigned--; } else break;
    }

    MANA_COLORS.forEach(c => {
        const el = document.getElementById(`land-${c}`);
        if (el) el.textContent = lands[c];
    });
    document.getElementById('landTotal').textContent = `Total: ${Object.values(lands).reduce((a, b) => a + b, 0)} lands`;

    currentBoard = 'main';
    document.querySelectorAll('.board-tab').forEach(t => t.classList.toggle('active', t.dataset.board === 'main'));
    renderDeckColumns();
    renderHistogram();
    updateDeckStats();
    showToast(`Auto-built ${23} spells + 17 lands in ${sortedColors[0]}/${sortedColors[1]}`);
}

// ══════════════════════════════════════════
// WASM Draft Worker
// ══════════════════════════════════════════
var wasmDraftWorker = null;
var wasmDraftReady = false;
var wasmSuggestionCallback = null;

function initDraftWorker() {
    if (wasmDraftWorker) return; // already initialized
    try {
        wasmDraftWorker = new Worker('/draft/draft-worker.js', { type: 'module' });
        wasmDraftWorker.onmessage = function(e) {
            var data = e.data;
            if (data.type === 'ready') {
                wasmDraftReady = true;
                console.log('[Draft] WASM worker ready');
            } else if (data.type === 'bot_results') {
                // Apply WASM bot picks — arrives before 350ms render timeout
                applyWasmBotPicks(data.picks);
            } else if (data.type === 'scores') {
                // Pick suggestion scores arrived
                if (wasmSuggestionCallback) {
                    wasmSuggestionCallback(data.scores);
                    wasmSuggestionCallback = null;
                }
            } else if (data.type === 'bot_deck_result') {
                if (botDeckCallback) {
                    botDeckCallback(data.seat, data.deck);
                }
            } else if (data.type === 'error') {
                console.warn('[Draft WASM]', data.message);
            }
        };
        wasmDraftWorker.onerror = function(err) {
            console.warn('[Draft] WASM worker failed:', err.message);
            wasmDraftWorker = null;
            wasmDraftReady = false;
        };
    } catch (err) {
        console.warn('[Draft] Cannot create WASM worker:', err.message);
    }
}

// ── WASM pick suggestions ──
function requestWasmSuggestion(pack, callback) {
    if (!wasmDraftWorker || !wasmDraftReady) return;
    var humanState = {
        seat: 0,
        colorWeights: humanColorWeights,
        curveCounts: Array.from(getHumanCurveCounts()),
        creatureCount: humanPool.filter(function(c) { return (c.type_line || '').toLowerCase().includes('creature'); }).length,
        spellCount: humanPool.length,
        removalCount: 0,
        picks: humanPool.slice(),
        signalStrength: [0.5, 0.5, 0.5, 0.5, 0.5],
        keywordsSeen: [],
        primaryColors: [],
        creatureRatio: 0
    };
    wasmSuggestionCallback = callback;
    wasmDraftWorker.postMessage({ type: 'score_pack', state: humanState, pack: pack, reqId: 'suggest' });
}

// ── Bot Deck Viewer ──
var botDeckCallback = null;
var botDeckResults = {};

function viewBotDecks() {
    if (!wasmDraftWorker || !wasmDraftReady) {
        showToast('WASM not available — cannot build bot decks');
        return;
    }
    botDeckResults = {};
    var draftState = {
        bots: [],
        current_pack: currentPack,
        current_pick: currentPick
    };
    // Build DraftState with all 8 seats (seat 0 = human, seats 1-7 = bots)
    // Human seat
    draftState.bots.push({
        seat: 0,
        picks: humanPool.slice(),
        color_weights: [humanColorWeights.W, humanColorWeights.U, humanColorWeights.B, humanColorWeights.R, humanColorWeights.G],
        primary_colors: [],
        curve_counts: Array.from(getHumanCurveCounts()),
        creature_count: humanPool.filter(function(c) { return (c.type_line || '').toLowerCase().includes('creature'); }).length,
        removal_count: 0,
        creature_ratio: 0,
        signal_strength: [0.5, 0.5, 0.5, 0.5, 0.5],
        keywords_seen: []
    });
    // Bot seats
    for (var b = 0; b < botStates.length; b++) {
        var bs = botStates[b];
        draftState.bots.push({
            seat: b + 1,
            picks: bs.picks.slice(),
            color_weights: [bs.colorWeights.W, bs.colorWeights.U, bs.colorWeights.B, bs.colorWeights.R, bs.colorWeights.G],
            primary_colors: [],
            curve_counts: Array.from(bs.curveCounts),
            creature_count: bs.creatureCount,
            removal_count: bs.removalCount,
            creature_ratio: bs.creatureCount / Math.max(1, bs.spellCount),
            signal_strength: Array.from(bs.signalStrength),
            keywords_seen: bs.keywordsSeen.slice()
        });
    }
    var remaining = NUM_SEATS - 1;
    botDeckCallback = function(seat, deck) {
        botDeckResults[seat] = deck;
        remaining--;
        if (remaining <= 0) {
            botDeckCallback = null;
            renderBotDecks();
        }
    };
    for (var s = 1; s < NUM_SEATS; s++) {
        wasmDraftWorker.postMessage({ type: 'bot_deck', draft: draftState, seat: s });
    }
    showToast('Building bot decks...');
}

function renderBotDecks() {
    var overlay = document.getElementById('botDeckOverlay');
    if (!overlay) {
        overlay = document.createElement('div');
        overlay.id = 'botDeckOverlay';
        overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.85);z-index:2000;overflow-y:auto;padding:2rem;';
        overlay.innerHTML = '<div style="max-width:1200px;margin:0 auto;"><div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:1.5rem;"><h2 style="font-family:Space Grotesk,sans-serif;font-size:1.5rem;background:var(--gradient-purple);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;">Bot Decks (WASM AI)</h2><button onclick="document.getElementById(\'botDeckOverlay\').style.display=\'none\'" style="background:none;border:1px solid rgba(255,255,255,0.2);color:white;padding:0.5rem 1rem;border-radius:6px;cursor:pointer;font-family:inherit;">Close</button></div><div id="botDeckGrid" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:1.5rem;"></div></div>';
        document.body.appendChild(overlay);
    }
    overlay.style.display = 'block';
    var grid = document.getElementById('botDeckGrid');
    grid.innerHTML = '';

    // Build image lookup from botPools (WASM strips image fields from DraftCard)
    var imgLookup = {};
    for (var bp = 0; bp < botPools.length; bp++) {
        for (var bc = 0; bc < botPools[bp].length; bc++) {
            var poolCard = botPools[bp][bc];
            if (poolCard.image_small && !imgLookup[poolCard.name]) {
                imgLookup[poolCard.name] = { small: poolCard.image_small, normal: poolCard.image_normal };
            }
        }
    }
    // Also check humanPool in case cards overlap
    for (var hc = 0; hc < humanPool.length; hc++) {
        var hCard = humanPool[hc];
        if (hCard.image_small && !imgLookup[hCard.name]) {
            imgLookup[hCard.name] = { small: hCard.image_small, normal: hCard.image_normal };
        }
    }

    var colorNames = { W: 'White', U: 'Blue', B: 'Black', R: 'Red', G: 'Green' };
    for (var seat = 1; seat < NUM_SEATS; seat++) {
        var deck = botDeckResults[seat];
        if (!deck) continue;
        var panel = document.createElement('div');
        panel.style.cssText = 'background:var(--card-bg);border:1px solid var(--card-border);border-radius:10px;padding:1.25rem;';

        var colorStr = '';
        if (deck.lands) {
            var landNames = [];
            if (deck.lands.plains > 0) landNames.push(deck.lands.plains + ' Plains');
            if (deck.lands.island > 0) landNames.push(deck.lands.island + ' Island');
            if (deck.lands.swamp > 0) landNames.push(deck.lands.swamp + ' Swamp');
            if (deck.lands.mountain > 0) landNames.push(deck.lands.mountain + ' Mountain');
            if (deck.lands.forest > 0) landNames.push(deck.lands.forest + ' Forest');
            colorStr = landNames.join(', ');
        }

        var mainCount = deck.maindeck ? deck.maindeck.length : 0;
        var landTotal = deck.lands ? (deck.lands.plains + deck.lands.island + deck.lands.swamp + deck.lands.mountain + deck.lands.forest) : 0;

        panel.innerHTML = '<h3 style="font-size:1rem;margin-bottom:0.5rem;font-family:Space Grotesk,sans-serif;">Bot ' + seat + '</h3>' +
            '<div style="font-size:0.8rem;color:var(--text-secondary);margin-bottom:0.75rem;">' + mainCount + ' spells + ' + landTotal + ' lands = ' + (mainCount + landTotal) + ' cards</div>' +
            '<div style="font-size:0.75rem;color:var(--text-muted);margin-bottom:0.75rem;">' + colorStr + '</div>' +
            '<div class="bot-deck-cards" style="display:flex;flex-wrap:wrap;gap:3px;"></div>';

        if (deck.maindeck) {
            var cardsDiv = panel.querySelector('.bot-deck-cards');
            deck.maindeck.forEach(function(card) {
                var imgs = imgLookup[card.name];
                var imgUrl = (card.image_small) || (imgs && imgs.small) || '';
                var img = document.createElement('div');
                img.style.cssText = 'width:40px;height:56px;border-radius:2px;overflow:hidden;';
                img.title = card.name + ' (' + (card.mana_cost || 'land') + ')';
                img.innerHTML = '<img src="' + imgUrl + '" alt="' + card.name + '" style="width:100%;height:100%;object-fit:cover;" loading="lazy">';
                cardsDiv.appendChild(img);
            });
        }

        grid.appendChild(panel);
    }
}

// ── Settings toggle listener ──
document.getElementById('showSuggestions').addEventListener('change', function() {
    showPickSuggestions = this.checked;
    if (draftInProgress) renderCurrentPack();
});

// ── URL param support: ?set=xxx ──
function getSetParam() {
    const params = new URLSearchParams(window.location.search);
    return params.get('set');
}

// ══════════════════════════════════════════
// Init
// ══════════════════════════════════════════
loadSets().then(() => {
    const setParam = getSetParam();
    if (setParam) {
        // Auto-start draft for the specified set
        const matchingSet = setsIndex.find(s => s.set_code === setParam.toLowerCase());
        if (matchingSet) {
            startDraft(matchingSet.set_code, document.querySelector('.btn-start') || document.createElement('button'));
        }
    }
});
</script>
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebApplication","name":"MTG Draft Simulator","url":"https://scrollvault.net/draft/","applicationCategory":"GameApplication","operatingSystem":"Any","offers":{"@type":"Offer","price":"0","priceCurrency":"USD"},"description":"Free MTG draft simulator with smart AI opponents. Practice drafting from 14+ real sets including Aetherdrift and Foundations. 3 packs, 14 cards, 7 AI drafters. Build your deck and export to Arena.","isPartOf":{"@type":"WebSite","name":"ScrollVault","url":"https://scrollvault.net"},"publisher":{"@type":"Organization","name":"ScrollVault","url":"https://scrollvault.net","logo":{"@type":"ImageObject","url":"https://scrollvault.net/og-default.png"}}}
</script>
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"FAQPage","mainEntity":[{"@type":"Question","name":"How does the MTG draft simulator work?","acceptedAnswer":{"@type":"Answer","text":"Our draft simulator replicates a real 8-player booster draft. You sit at a virtual table with 7 AI opponents. Each player opens a pack of 14 cards, picks one, and passes the rest. Packs alternate passing direction each round (left, right, left). After 3 packs and 42 total picks, you build a 40-card deck from your picks plus basic lands."}},{"@type":"Question","name":"How many cards do you pick in an MTG draft?","acceptedAnswer":{"@type":"Answer","text":"In a standard booster draft, you make 42 picks total: 14 cards from each of 3 packs (14 × 3 = 42). You then build a minimum 40-card deck from those picks, adding basic lands as needed. Most players end up playing 22-24 spells and 16-18 lands."}},{"@type":"Question","name":"How many packs in a Magic draft?","acceptedAnswer":{"@type":"Answer","text":"A standard MTG booster draft uses 3 packs per player. With 8 players, that's 24 packs total. Pack 1 passes left, Pack 2 passes right, and Pack 3 passes left again. Each pack starts with 14 draftable cards."}},{"@type":"Question","name":"Can I practice MTG draft for free?","acceptedAnswer":{"@type":"Answer","text":"Yes! This draft simulator is completely free with no account required. Practice as many drafts as you like from 14+ real Magic sets. The AI bots use intelligent pick logic based on card ratings, color signals, and curve considerations."}},{"@type":"Question","name":"What sets are available to draft?","acceptedAnswer":{"@type":"Answer","text":"We currently support 14 sets with pre-loaded card data and ratings, including recent sets like Lorwyn Eclipsed, Aetherdrift, Foundations, Duskmourn, Bloomburrow, Modern Horizons 3, and more. New sets are added regularly."}},{"@type":"Question","name":"How do the AI draft bots pick cards?","acceptedAnswer":{"@type":"Answer","text":"Each AI bot uses a scoring system that considers the card's base rating, color fit, mana curve needs, creature density targets, and open-color signals. Early picks focus on raw power, while later picks prioritize staying on-color and filling curve gaps."}},{"@type":"Question","name":"How to export draft deck to MTG Arena?","acceptedAnswer":{"@type":"Answer","text":"After building your deck, click the Export to Arena button. This copies your decklist in MTGA-compatible format to your clipboard. Open MTG Arena, go to Decks, click Import, and paste."}},{"@type":"Question","name":"What is the best draft strategy for beginners?","acceptedAnswer":{"@type":"Answer","text":"Start with the BREAD method: Bombs (powerful rares/mythics), Removal (cards that destroy creatures), Evasion (flying, menace, trample), Aggro (efficient creatures), Duds (everything else). Stick to 2 colors, aim for 15-17 creatures, and prioritize 2-3 mana cost cards."}}]}
</script>
</body>
</html>
