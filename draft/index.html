<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MTG Draft Simulator — Practice Draft Against AI Bots Free | ScrollVault</title>
    <meta name="description" content="Free MTG draft simulator with smart AI opponents. Practice drafting from 14+ real sets including Aetherdrift and Foundations. 3 packs, 14 cards, 7 AI drafters. Build your deck and export to Arena.">
    <meta name="robots" content="index, follow">
    <meta property="og:title" content="MTG Draft Simulator — Practice Draft Against AI Bots Free">
    <meta property="og:description" content="Free MTG draft simulator with smart AI opponents. Practice drafting from 14+ real sets. Build your deck and export to Arena.">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="ScrollVault">
    <meta property="og:url" content="https://scrollvault.net/draft/">
    <meta property="og:image" content="https://scrollvault.net/og-default.png">
    <meta property="og:image:alt" content="MTG Draft Simulator — Practice Draft Against AI Bots">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@scrollvault">
    <meta name="twitter:title" content="MTG Draft Simulator — Practice Draft Against AI Bots Free">
    <meta name="twitter:description" content="Free MTG draft simulator with smart AI opponents. 14+ real sets, 7 AI drafters, Arena export.">
    <meta name="twitter:image" content="https://scrollvault.net/og-default.png">
    <link rel="canonical" href="https://scrollvault.net/draft/">
    <link rel="preload" href="/css/fonts/inter-latin.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="/css/fonts/space-grotesk-latin.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="icon" href="/favicon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-1CV3DS33WK"></script>
    <script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','G-1CV3DS33WK');</script>
<style>
@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 400 700;
  font-display: swap;
  src: url('/css/fonts/inter-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
@font-face {
  font-family: 'Space Grotesk';
  font-style: normal;
  font-weight: 400 700;
  font-display: swap;
  src: url('/css/fonts/space-grotesk-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
/* ── Theme Variables ── */
:root {
    --bg-dark: #0f0f0f; --card-bg: #1a1a1a; --card-border: rgba(255,255,255,0.08);
    --card-hover-glow: rgba(139,92,246,0.25); --text-primary: #ffffff;
    --text-secondary: #a1a1aa; --text-muted: #71717a;
    --nav-bg: rgba(15,15,15,0.95); --nav-border: rgba(255,255,255,0.06);
    --gradient-purple: linear-gradient(135deg, #a855f7 0%, #6366f1 100%);
    --shadow-sm: 0 1px 2px rgba(0,0,0,0.3); --shadow-md: 0 4px 6px rgba(0,0,0,0.4);
    --shadow-lg: 0 10px 15px rgba(0,0,0,0.5);
    --color-W: #F9FAF4; --color-U: #0E68AB; --color-B: #150B00; --color-R: #D3202A; --color-G: #00733E;
    --color-M: #C5A F46; --color-C: #9E9E9E;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
html { scroll-behavior: smooth; }
body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; background: var(--bg-dark); color: var(--text-primary); line-height: 1.6; min-height: 100vh; }
h1,h2,h3,h4,h5,h6 { font-family: 'Space Grotesk', -apple-system, sans-serif; font-weight: 600; line-height: 1.3; }
a { color: inherit; text-decoration: none; transition: color 0.2s ease; }
a:hover { color: #a78bfa; }
.container { max-width: 1280px; margin: 0 auto; padding: 0 1rem; }
.transition-all { transition: all 0.2s ease; }

/* ── Nav ── */
.nav { position: fixed; top: 0; left: 0; right: 0; background: var(--nav-bg); border-bottom: 1px solid var(--nav-border); z-index: 1000; height: 64px; display: flex; align-items: center; }
.nav-content { display: flex; justify-content: space-between; align-items: center; width: 100%; }
.nav-logo { font-family: 'Space Grotesk', sans-serif; font-size: 1.5rem; font-weight: 700; background: var(--gradient-purple); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
.nav-links { display: flex; gap: 2rem; list-style: none; }
.nav-links a { font-size: 0.9rem; font-weight: 500; color: var(--text-secondary); }
.nav-links a:hover, .nav-links a.active { color: var(--text-primary); }
.mobile-menu-btn { display: none; background: none; border: none; color: var(--text-primary); font-size: 1.5rem; cursor: pointer; }
@media (max-width: 768px) {
    .nav-links { display: none; position: absolute; top: 64px; left: 0; right: 0; background: var(--nav-bg); border-bottom: 1px solid var(--nav-border); flex-direction: column; padding: 1rem; gap: 0; }
    .nav-links.active { display: flex; }
    .nav-links a { padding: 0.75rem 1rem; display: block; border-bottom: 1px solid var(--card-border); }
    .nav-links a:last-child { border-bottom: none; }
    .mobile-menu-btn { display: block; }
}

/* ── Footer ── */
footer { border-top: 1px solid var(--card-border); padding: 2rem 0; }
.footer-content { display: flex; flex-direction: column; align-items: center; gap: 1rem; text-align: center; }
.footer-logo { font-family: 'Space Grotesk', sans-serif; font-size: 1.25rem; font-weight: 700; background: var(--gradient-purple); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
.footer-text { color: var(--text-muted); font-size: 0.875rem; }
.footer-links { display: flex; gap: 1.5rem; list-style: none; }
.footer-links a { color: var(--text-secondary); font-size: 0.875rem; }
.footer-links a:hover { color: var(--text-primary); }
.wubrg-dots { display: flex; gap: 0.5rem; justify-content: center; margin-top: 0.25rem; }
.mana-dot { width: 10px; height: 10px; border-radius: 50%; }

/* ── Main ── */
main { margin-top: 64px; min-height: calc(100vh - 64px); }

/* ── Screen 1: Set Selection ── */
.screen { display: none; }
.screen.active { display: block; }

.hero-section { padding: 4rem 0 2rem; text-align: center; }
.hero-section h1 { font-size: 3rem; margin-bottom: 0.5rem; background: var(--gradient-purple); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
.hero-section .subtitle { color: var(--text-secondary); font-size: 1.1rem; margin-bottom: 0.5rem; }
.hero-section .rules-text { color: var(--text-muted); font-size: 0.9rem; }

.set-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); gap: 1.5rem; padding: 2rem 0 4rem; max-width: 720px; margin: 0 auto; }
.set-card { background: var(--card-bg); border: 1px solid var(--card-border); border-radius: 12px; padding: 2rem; transition: transform 0.2s ease, box-shadow 0.2s ease; cursor: default; }
.set-card:hover { transform: translateY(-4px); box-shadow: var(--shadow-lg), 0 0 30px var(--card-hover-glow); }
.set-card-header { display: flex; align-items: center; gap: 1rem; margin-bottom: 1.5rem; }
.set-icon { width: 48px; height: 48px; filter: brightness(0) invert(1); }
.set-card-header h3 { font-size: 1.25rem; }
.set-meta { display: flex; gap: 1.5rem; color: var(--text-secondary); font-size: 0.875rem; margin-bottom: 1.5rem; }
.set-meta span { display: flex; align-items: center; gap: 0.35rem; }

.btn-start { display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.75rem 2rem; background: var(--gradient-purple); border: none; border-radius: 8px; font-weight: 600; font-size: 1rem; color: white; cursor: pointer; font-family: inherit; transition: transform 0.2s ease, box-shadow 0.2s ease; }
.btn-start:hover { transform: translateY(-2px); box-shadow: 0 4px 20px rgba(139,92,246,0.4); }
.btn-start:disabled { opacity: 0.6; cursor: wait; transform: none; box-shadow: none; }
.btn-start .spinner { display: none; width: 16px; height: 16px; border: 2px solid rgba(255,255,255,0.3); border-top-color: white; border-radius: 50%; animation: spin 0.6s linear infinite; }
.btn-start.loading .spinner { display: inline-block; }
.btn-start.loading .btn-text { display: none; }
@keyframes spin { to { transform: rotate(360deg); } }

/* ── Screen 2: Draft Phase ── */
.draft-layout { display: flex; gap: 1.5rem; padding: 1.5rem 0 4rem; min-height: calc(100vh - 64px - 120px); }
.pack-area { flex: 7; min-width: 0; }
.pool-area { flex: 3; min-width: 240px; }

/* Pack header */
.pack-header { margin-bottom: 1rem; }
.pack-info { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; }
.pack-label { font-family: 'Space Grotesk', sans-serif; font-size: 1.1rem; font-weight: 600; }
.pass-direction { color: var(--text-muted); font-size: 0.85rem; display: flex; align-items: center; gap: 0.35rem; }
.progress-bar { height: 3px; background: rgba(255,255,255,0.08); border-radius: 2px; overflow: hidden; }
.progress-fill { height: 100%; background: var(--gradient-purple); border-radius: 2px; transition: width 0.3s ease; }
.keyboard-hint { color: var(--text-muted); font-size: 0.75rem; margin-top: 0.5rem; }

/* Pack grid */
.pack-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; contain: layout style; }
.pack-card { position: relative; border-radius: 4px; overflow: hidden; cursor: pointer; will-change: transform; transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.3s ease; aspect-ratio: 488 / 680; }
.pack-card img { width: 100%; height: 100%; object-fit: cover; display: block; border-radius: 4px; pointer-events: none; }
.pack-card:hover { transform: scale(1.08); box-shadow: 0 0 20px rgba(168,85,247,0.4); z-index: 10; }
.pack-card.picked { animation: pickFlash 0.4s ease; box-shadow: 0 0 25px rgba(255,215,0,0.6); }
.pack-card.fading { opacity: 0; transform: scale(0.95); pointer-events: none; }
.pack-card .card-number { position: absolute; top: 4px; left: 4px; background: rgba(0,0,0,0.75); color: white; font-size: 0.65rem; font-weight: 600; padding: 1px 5px; border-radius: 3px; pointer-events: none; }
@keyframes pickFlash {
    0% { box-shadow: 0 0 0 rgba(255,215,0,0); }
    50% { box-shadow: 0 0 35px rgba(255,215,0,0.8); transform: scale(1.05); }
    100% { box-shadow: 0 0 25px rgba(255,215,0,0.3); transform: scale(1); }
}

/* Tooltip */
.card-tooltip { position: fixed; z-index: 2000; background: #222; border: 1px solid rgba(255,255,255,0.15); border-radius: 8px; padding: 0.75rem; max-width: 280px; pointer-events: none; opacity: 0; transition: opacity 0.15s ease; font-size: 0.8rem; box-shadow: 0 8px 32px rgba(0,0,0,0.6); }
.card-tooltip.visible { opacity: 1; }
.card-tooltip .tt-name { font-family: 'Space Grotesk', sans-serif; font-weight: 600; font-size: 0.9rem; margin-bottom: 0.25rem; }
.card-tooltip .tt-cost { color: var(--text-secondary); font-size: 0.8rem; margin-bottom: 0.25rem; }
.card-tooltip .tt-type { color: var(--text-muted); font-size: 0.75rem; margin-bottom: 0.5rem; border-bottom: 1px solid var(--card-border); padding-bottom: 0.4rem; }
.card-tooltip .tt-oracle { color: var(--text-secondary); font-size: 0.75rem; line-height: 1.5; }
.card-tooltip .tt-pt { color: var(--text-primary); font-weight: 600; font-size: 0.8rem; margin-top: 0.4rem; text-align: right; }
.card-tooltip .tt-rating { color: #a855f7; font-size: 0.7rem; margin-top: 0.25rem; }

/* Pool sidebar */
.pool-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 1px solid var(--card-border); }
.pool-header h3 { font-size: 1rem; }
.pool-count { color: var(--text-muted); font-size: 0.85rem; }

.pool-colors { display: flex; flex-direction: column; gap: 0.75rem; }
.pool-color-group { background: rgba(255,255,255,0.02); border-radius: 6px; padding: 0.5rem; }
.pool-color-label { display: flex; align-items: center; gap: 0.4rem; margin-bottom: 0.35rem; font-size: 0.75rem; font-weight: 600; color: var(--text-secondary); }
.pool-color-dot { width: 8px; height: 8px; border-radius: 50%; }
.pool-color-cards { display: flex; flex-wrap: wrap; gap: 2px; }
.pool-mini-card { width: 36px; height: 50px; border-radius: 2px; overflow: hidden; transition: transform 0.15s ease; cursor: pointer; }
.pool-mini-card img { width: 100%; height: 100%; object-fit: cover; display: block; }
.pool-mini-card:hover { transform: scale(1.3); z-index: 5; position: relative; }

/* Mana curve mini */
.mini-curve { margin-top: 1rem; padding-top: 0.75rem; border-top: 1px solid var(--card-border); }
.mini-curve h4 { font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem; }
.curve-bars { display: flex; align-items: flex-end; gap: 3px; height: 40px; }
.curve-bar { flex: 1; background: rgba(168,85,247,0.4); border-radius: 2px 2px 0 0; min-height: 2px; transition: height 0.2s ease; position: relative; }
.curve-bar-label { position: absolute; bottom: -14px; left: 50%; transform: translateX(-50%); font-size: 0.6rem; color: var(--text-muted); }
.curve-bar-count { position: absolute; top: -14px; left: 50%; transform: translateX(-50%); font-size: 0.6rem; color: var(--text-secondary); }

/* ── Screen 3: Deck Builder ── */
.builder-layout { padding: 1.5rem 0 4rem; }
.builder-header { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; margin-bottom: 1.5rem; }
.builder-header h2 { font-size: 1.5rem; background: var(--gradient-purple); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
.builder-actions { display: flex; gap: 0.75rem; flex-wrap: wrap; }

.btn { display: inline-flex; align-items: center; gap: 0.4rem; padding: 0.5rem 1.25rem; border: 1px solid var(--card-border); border-radius: 6px; font-size: 0.85rem; font-weight: 500; color: var(--text-secondary); background: var(--card-bg); cursor: pointer; font-family: inherit; transition: all 0.2s ease; }
.btn:hover { border-color: rgba(139,92,246,0.5); color: var(--text-primary); }
.btn-primary { background: var(--gradient-purple); border-color: transparent; color: white; }
.btn-primary:hover { box-shadow: 0 4px 20px rgba(139,92,246,0.4); color: white; }

/* Deck stats bar */
.deck-stats { display: flex; gap: 1.5rem; flex-wrap: wrap; align-items: center; margin-bottom: 1.5rem; padding: 1rem; background: var(--card-bg); border: 1px solid var(--card-border); border-radius: 8px; }
.stat { font-size: 0.9rem; color: var(--text-secondary); }
.stat strong { color: var(--text-primary); }

/* Mainboard / Sideboard toggle info */
.board-tabs { display: flex; gap: 0; margin-bottom: 1rem; }
.board-tab { padding: 0.5rem 1.25rem; background: var(--card-bg); border: 1px solid var(--card-border); font-size: 0.85rem; font-weight: 500; color: var(--text-muted); cursor: pointer; font-family: inherit; transition: all 0.2s ease; }
.board-tab:first-child { border-radius: 6px 0 0 6px; }
.board-tab:last-child { border-radius: 0 6px 6px 0; border-left: none; }
.board-tab.active { background: rgba(168,85,247,0.15); border-color: rgba(168,85,247,0.4); color: var(--text-primary); }

/* Deck columns */
.deck-columns { display: flex; gap: 1rem; flex-wrap: wrap; margin-bottom: 2rem; }
.deck-column { flex: 1; min-width: 140px; max-width: 200px; }
.deck-col-header { display: flex; align-items: center; gap: 0.35rem; margin-bottom: 0.5rem; font-size: 0.8rem; font-weight: 600; color: var(--text-secondary); padding-bottom: 0.35rem; border-bottom: 2px solid; }
.deck-col-header .col-dot { width: 8px; height: 8px; border-radius: 50%; }
.deck-card-entry { display: flex; align-items: center; gap: 0.4rem; padding: 0.25rem 0.35rem; border-radius: 4px; cursor: pointer; transition: background 0.15s ease; font-size: 0.8rem; }
.deck-card-entry:hover { background: rgba(255,255,255,0.06); }
.deck-card-entry .entry-img { width: 28px; height: 40px; border-radius: 2px; overflow: hidden; flex-shrink: 0; }
.deck-card-entry .entry-img img { width: 100%; height: 100%; object-fit: cover; display: block; }
.deck-card-entry .entry-name { color: var(--text-secondary); flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.deck-card-entry .entry-cmc { color: var(--text-muted); font-size: 0.7rem; flex-shrink: 0; }
.deck-card-entry.sideboarded { opacity: 0.4; }

/* Mana curve histogram */
.curve-section { margin-bottom: 2rem; }
.curve-section h3 { font-size: 1rem; margin-bottom: 1rem; }
.histogram { display: flex; align-items: flex-end; gap: 6px; height: 100px; padding: 0 1rem; }
.histo-col { flex: 1; display: flex; flex-direction: column; align-items: center; gap: 4px; max-width: 60px; }
.histo-bar { width: 100%; border-radius: 3px 3px 0 0; min-height: 0; transition: height 0.3s ease; }
.histo-label { font-size: 0.7rem; color: var(--text-muted); }
.histo-count { font-size: 0.7rem; color: var(--text-secondary); }

/* Lands section */
.lands-section { margin-bottom: 2rem; padding: 1.25rem; background: var(--card-bg); border: 1px solid var(--card-border); border-radius: 8px; }
.lands-section h3 { font-size: 1rem; margin-bottom: 1rem; }
.land-controls { display: flex; flex-wrap: wrap; gap: 1rem; align-items: center; margin-bottom: 1rem; }
.land-control { display: flex; align-items: center; gap: 0.5rem; }
.land-control .land-symbol { width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.7rem; font-weight: 700; }
.land-control button { width: 24px; height: 24px; border-radius: 4px; border: 1px solid var(--card-border); background: var(--card-bg); color: var(--text-secondary); cursor: pointer; font-size: 0.9rem; font-family: inherit; display: flex; align-items: center; justify-content: center; transition: all 0.15s ease; }
.land-control button:hover { border-color: rgba(168,85,247,0.5); color: var(--text-primary); }
.land-control .land-count { font-size: 0.9rem; font-weight: 600; width: 20px; text-align: center; }

/* Toast */
.toast { position: fixed; bottom: 2rem; left: 50%; transform: translateX(-50%) translateY(100px); background: #333; color: white; padding: 0.75rem 1.5rem; border-radius: 8px; font-size: 0.9rem; z-index: 3000; transition: transform 0.3s ease, opacity 0.3s ease; opacity: 0; pointer-events: none; }
.toast.visible { transform: translateX(-50%) translateY(0); opacity: 1; }

/* ── Mobile Card Preview Panel ── */
.mobile-preview-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 1500; opacity: 0; pointer-events: none; transition: opacity 0.2s ease; }
.mobile-preview-overlay.visible { opacity: 1; pointer-events: auto; }
.mobile-preview { position: fixed; bottom: 0; left: 0; right: 0; z-index: 1600; background: #1e1e1e; border-top: 1px solid rgba(255,255,255,0.12); border-radius: 16px 16px 0 0; padding: 0 1rem 1.5rem; transform: translateY(100%); transition: transform 0.25s ease; max-height: 70vh; overflow-y: auto; pointer-events: none; }
.mobile-preview.visible { transform: translateY(0); pointer-events: auto; }
.mobile-preview-handle { width: 36px; height: 4px; background: rgba(255,255,255,0.25); border-radius: 2px; margin: 10px auto 12px; }
.mobile-preview-body { display: flex; gap: 1rem; align-items: flex-start; }
.mobile-preview-img { flex-shrink: 0; width: 120px; border-radius: 4px; overflow: hidden; }
.mobile-preview-img img { width: 100%; display: block; border-radius: 4px; }
.mobile-preview-info { flex: 1; min-width: 0; }
.mobile-preview-info .mp-name { font-family: 'Space Grotesk', sans-serif; font-weight: 600; font-size: 1.05rem; margin-bottom: 0.25rem; }
.mobile-preview-info .mp-cost { color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 0.2rem; }
.mobile-preview-info .mp-type { color: var(--text-muted); font-size: 0.8rem; margin-bottom: 0.5rem; padding-bottom: 0.4rem; border-bottom: 1px solid var(--card-border); }
.mobile-preview-info .mp-oracle { color: var(--text-secondary); font-size: 0.82rem; line-height: 1.55; margin-bottom: 0.5rem; }
.mobile-preview-info .mp-pt { font-weight: 600; font-size: 0.85rem; }
.mobile-preview-info .mp-rating { color: #a855f7; font-size: 0.75rem; margin-top: 0.2rem; }
.mobile-preview-actions { display: flex; gap: 0.75rem; margin-top: 1rem; }
.mobile-preview-actions .btn-pick { flex: 1; padding: 0.85rem; background: var(--gradient-purple); border: none; border-radius: 10px; font-weight: 700; font-size: 1rem; color: white; cursor: pointer; font-family: inherit; }
.mobile-preview-actions .btn-cancel { padding: 0.85rem 1.25rem; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.12); border-radius: 10px; font-weight: 500; font-size: 1rem; color: var(--text-secondary); cursor: pointer; font-family: inherit; }

/* Selected card glow on mobile */
.pack-card.selected { outline: 3px solid #a855f7; outline-offset: 2px; transform: scale(1.04); box-shadow: 0 0 20px rgba(168,85,247,0.5); z-index: 10; }

/* ── Responsive ── */
@media (max-width: 900px) {
    .draft-layout { flex-direction: column; }
    .pool-area { order: 2; }
    .pack-grid { grid-template-columns: repeat(3, 1fr); }
    .deck-column { min-width: 120px; }
}
@media (max-width: 600px) {
    .hero-section h1 { font-size: 2rem; }
    .hero-section { padding: 2.5rem 0 1rem; }
    .pack-grid { grid-template-columns: repeat(3, 1fr); gap: 6px; }
    .deck-columns { gap: 0.5rem; }
    .deck-column { min-width: 100px; }
    .keyboard-hint { display: none; }
    .builder-actions { width: 100%; }
    .builder-actions .btn { flex: 1; justify-content: center; font-size: 0.8rem; padding: 0.5rem 0.75rem; }
    .deck-stats { gap: 0.75rem; flex-wrap: wrap; }
    .set-grid { grid-template-columns: 1fr; }
}

/* ── FAQ Section ── */
.faq-section { padding: 3rem 0 2rem; }
.faq-section h2 { font-size: 1.75rem; margin-bottom: 1.5rem; background: var(--gradient-purple); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
.faq-list { display: flex; flex-direction: column; gap: 0.75rem; max-width: 800px; }
.faq-item { background: var(--card-bg); border: 1px solid var(--card-border); border-radius: 10px; overflow: hidden; }
.faq-item summary { padding: 1rem 1.25rem; font-weight: 600; font-size: 0.95rem; cursor: pointer; list-style: none; display: flex; justify-content: space-between; align-items: center; }
.faq-item summary::-webkit-details-marker { display: none; }
.faq-item summary::after { content: '+'; font-size: 1.25rem; color: var(--text-muted); flex-shrink: 0; margin-left: 1rem; transition: transform 0.2s; }
.faq-item[open] summary::after { content: '\2212'; }
.faq-answer { padding: 0 1.25rem 1rem; color: var(--text-secondary); font-size: 0.9rem; line-height: 1.7; }
.faq-answer p { margin-bottom: 0.5rem; }
.faq-answer ul { margin: 0.5rem 0 0.5rem 1.5rem; }
.faq-answer a { color: #a78bfa; text-decoration: underline; }

/* ── Pick Suggestion Glow ── */
.pack-card.suggested { outline: 2px solid rgba(255,215,0,0.5); outline-offset: 1px; }
.suggestion-badge { position: absolute; bottom: 4px; right: 4px; background: rgba(255,215,0,0.9); color: #000; font-size: 0.6rem; font-weight: 700; padding: 1px 5px; border-radius: 3px; pointer-events: none; }

/* ── Settings Toggle ── */
.settings-bar { display: flex; gap: 1.5rem; align-items: center; justify-content: center; margin-top: 0.75rem; }
.toggle-label { display: flex; align-items: center; gap: 0.5rem; font-size: 0.8rem; color: var(--text-muted); cursor: pointer; }
.toggle-label input[type="checkbox"] { accent-color: #a855f7; width: 14px; height: 14px; }

/* ── Pool Analysis Stats ── */
.pool-stats { display: flex; gap: 1rem; flex-wrap: wrap; margin-bottom: 1rem; padding: 0.75rem; background: var(--card-bg); border: 1px solid var(--card-border); border-radius: 8px; font-size: 0.8rem; color: var(--text-secondary); }
.pool-stats .stat-group { display: flex; align-items: center; gap: 0.35rem; }
.pool-stats .color-bar { height: 10px; border-radius: 2px; min-width: 4px; }

/* Touch devices: hide hover tooltip */
@media (hover: none) and (pointer: coarse) {
    .card-tooltip { display: none !important; }
    .pack-card:hover { transform: none; box-shadow: none; z-index: auto; }
    .pack-card.selected { transform: scale(1.04); box-shadow: 0 0 20px rgba(168,85,247,0.5); z-index: 10; }
    .pool-mini-card:hover { transform: none; z-index: auto; }
}
    </style>
</head>
<body>
    <nav class="nav">
        <div class="container nav-content">
            <a href="/" class="nav-logo">ScrollVault</a>
            <button class="mobile-menu-btn" onclick="document.getElementById('navLinks').classList.toggle('active')">&#9776;</button>
            <ul class="nav-links" id="navLinks">
                <li><a href="/">Home</a></li>
                <li><a href="/news/">News</a></li>
                <li><a href="/guides/">Guides</a></li>
                <li><a href="/decks/">Top Decks</a></li>
                <li><a href="/draft/" class="active">Draft</a></li>
                <li><a href="/tools/">Tools</a></li>
                <li><a href="/about.html">About</a></li>
                <li><a href="/contact.html">Contact</a></li>
            </ul>
        </div>
    </nav>

    <main>
        <!-- ══════ Screen 1: Set Selection ══════ -->
        <div id="screenSelect" class="screen active">
            <div class="hero-section">
                <div class="container">
                    <h1>MTG Draft Simulator</h1>
                    <p class="subtitle">Practice drafting against 7 AI opponents with real set cards</p>
                    <p class="rules-text">3 packs, 14 cards each. Pick 1, pass the rest.</p>
                    <div class="settings-bar">
                        <label class="toggle-label"><input type="checkbox" id="showSuggestions"> Show pick suggestions</label>
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="set-grid" id="setGrid">
                    <!-- Populated by JS -->
                </div>
            </div>
        </div>

        <!-- ══════ Screen 2: Draft Phase ══════ -->
        <div id="screenDraft" class="screen">
            <div class="container">
                <div class="pack-header">
                    <div class="pack-info">
                        <span class="pack-label" id="packLabel">Pack 1 — Pick 1 of 14</span>
                        <span class="pass-direction" id="passDirection">Passing left &#8594;</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                    </div>
                    <div class="keyboard-hint">Keys 1-9 to quick-pick &middot; Z to undo last pick</div>
                </div>
                <div class="draft-layout">
                    <div class="pack-area">
                        <div class="pack-grid" id="packGrid">
                            <!-- Populated by JS -->
                        </div>
                    </div>
                    <div class="pool-area">
                        <div class="pool-header">
                            <h3>Your Picks</h3>
                            <span class="pool-count" id="poolCount">0 cards</span>
                        </div>
                        <div class="pool-colors" id="poolColors">
                            <!-- Populated by JS -->
                        </div>
                        <div class="mini-curve">
                            <h4>Mana Curve</h4>
                            <div class="curve-bars" id="miniCurveBars">
                                <div class="curve-bar"><span class="curve-bar-label">1</span><span class="curve-bar-count"></span></div>
                                <div class="curve-bar"><span class="curve-bar-label">2</span><span class="curve-bar-count"></span></div>
                                <div class="curve-bar"><span class="curve-bar-label">3</span><span class="curve-bar-count"></span></div>
                                <div class="curve-bar"><span class="curve-bar-label">4</span><span class="curve-bar-count"></span></div>
                                <div class="curve-bar"><span class="curve-bar-label">5+</span><span class="curve-bar-count"></span></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ══════ Screen 3: Deck Builder ══════ -->
        <div id="screenBuild" class="screen">
            <div class="container builder-layout">
                <div class="builder-header">
                    <h2>Build Your Deck</h2>
                    <div class="builder-actions">
                        <button class="btn" onclick="autoBuildDeck()">Auto-Build Deck</button>
                        <button class="btn" onclick="autoSuggestLands()">Auto-Suggest Lands</button>
                        <button class="btn btn-primary" onclick="exportDeck()">Export to Arena</button>
                        <button class="btn" onclick="draftAgain()">Draft Again</button>
                        <button class="btn" onclick="changeSet()">Change Set</button>
                    </div>
                </div>

                <div class="deck-stats" id="deckStats">
                    <span class="stat"><strong id="statMain">0</strong> mainboard</span>
                    <span class="stat"><strong id="statSpells">0</strong> spells</span>
                    <span class="stat"><strong id="statLands">0</strong> lands</span>
                    <span class="stat"><strong id="statSide">0</strong> sideboard</span>
                    <span class="stat" style="color: var(--text-muted); font-size:0.8rem;">Click a card to move it to sideboard</span>
                </div>

                <!-- Lands -->
                <div class="lands-section">
                    <h3>Lands</h3>
                    <div class="land-controls" id="landControls">
                        <!-- Populated by JS -->
                    </div>
                </div>

                <!-- Mana Curve -->
                <div class="curve-section">
                    <h3>Mana Curve</h3>
                    <div class="histogram" id="histogram">
                        <!-- Populated by JS -->
                    </div>
                </div>

                <!-- Board tabs -->
                <div class="board-tabs">
                    <button class="board-tab active" data-board="main" onclick="switchBoard('main')">Mainboard</button>
                    <button class="board-tab" data-board="side" onclick="switchBoard('side')">Sideboard</button>
                </div>

                <!-- Deck columns -->
                <div class="deck-columns" id="deckColumns">
                    <!-- Populated by JS -->
                </div>
            </div>
        </div>
    </main>

        <!-- ══════ FAQ Section ══════ -->
        <div class="faq-section">
            <div class="container">
                <h2>MTG Draft Simulator FAQ</h2>
                <div class="faq-list">
                    <details class="faq-item">
                        <summary>How does the MTG draft simulator work?</summary>
                        <div class="faq-answer">
                            <p>Our draft simulator replicates a real 8-player booster draft. You sit at a virtual table with 7 AI opponents. Each player opens a pack of 14 cards, picks one, and passes the rest. Packs alternate passing direction each round (left, right, left). After 3 packs and 42 total picks, you build a 40-card deck from your picks plus basic lands.</p>
                        </div>
                    </details>
                    <details class="faq-item">
                        <summary>How many cards do you pick in an MTG draft?</summary>
                        <div class="faq-answer">
                            <p>In a standard booster draft, you make 42 picks total: 14 cards from each of 3 packs (14 &times; 3 = 42). You then build a minimum 40-card deck from those picks, adding basic lands as needed. Most players end up playing 22-24 spells and 16-18 lands.</p>
                        </div>
                    </details>
                    <details class="faq-item">
                        <summary>How many packs in a Magic draft?</summary>
                        <div class="faq-answer">
                            <p>A standard MTG booster draft uses 3 packs per player. With 8 players, that's 24 packs total. Pack 1 passes left, Pack 2 passes right, and Pack 3 passes left again. Each pack starts with 14 draftable cards.</p>
                        </div>
                    </details>
                    <details class="faq-item">
                        <summary>Can I practice MTG draft for free?</summary>
                        <div class="faq-answer">
                            <p>Yes! This draft simulator is completely free with no account required. Practice as many drafts as you like from 14+ real Magic sets. The AI bots use intelligent pick logic based on card ratings, color signals, and curve considerations, giving you realistic practice for paper or Arena drafts.</p>
                        </div>
                    </details>
                    <details class="faq-item">
                        <summary>What sets are available to draft?</summary>
                        <div class="faq-answer">
                            <p>We currently support 14 sets with pre-loaded card data and ratings, including recent sets like Lorwyn Eclipsed, Aetherdrift, Foundations, Duskmourn, Bloomburrow, Modern Horizons 3, and more. New sets are added regularly as they release. Each set uses real card data from Scryfall with expert-calibrated draft ratings.</p>
                        </div>
                    </details>
                    <details class="faq-item">
                        <summary>How do the AI draft bots pick cards?</summary>
                        <div class="faq-answer">
                            <p>Each AI bot uses a scoring system that considers the card's base rating, color fit (bots develop color preferences as they draft), mana curve needs, creature density targets, and open-color signals. Early picks focus on raw power, while later picks prioritize staying on-color and filling curve gaps. A small random factor prevents bots from being too predictable.</p>
                        </div>
                    </details>
                    <details class="faq-item">
                        <summary>How to export draft deck to MTG Arena?</summary>
                        <div class="faq-answer">
                            <p>After building your deck, click the "Export to Arena" button. This copies your decklist (mainboard, lands, and sideboard) in MTGA-compatible format to your clipboard. Open MTG Arena, go to Decks, click Import, and paste. Note that only cards legal in your Arena collection will be available for actual play.</p>
                        </div>
                    </details>
                    <details class="faq-item">
                        <summary>What is the best draft strategy for beginners?</summary>
                        <div class="faq-answer">
                            <p>Start with the BREAD method: <strong>B</strong>ombs (powerful rares/mythics), <strong>R</strong>emoval (cards that destroy creatures), <strong>E</strong>vasion (flying, menace, trample), <strong>A</strong>ggro (efficient creatures), <strong>D</strong>uds (everything else). Stick to 2 colors, aim for 15-17 creatures, and prioritize 2-3 mana cost cards for a smooth curve. Use our <a href="/tools/manabase/">Mana Base Calculator</a> to optimize your land count.</p>
                        </div>
                    </details>
                </div>
            </div>
        </div>

    <!-- Mobile Card Preview (bottom sheet) -->
    <div class="mobile-preview-overlay" id="mobileOverlay" onclick="closeMobilePreview()"></div>
    <div class="mobile-preview" id="mobilePreview">
        <div class="mobile-preview-handle"></div>
        <div class="mobile-preview-body">
            <div class="mobile-preview-img"><img id="mpImg" src="" alt=""></div>
            <div class="mobile-preview-info">
                <div class="mp-name" id="mpName"></div>
                <div class="mp-cost" id="mpCost"></div>
                <div class="mp-type" id="mpType"></div>
                <div class="mp-oracle" id="mpOracle"></div>
                <div class="mp-pt" id="mpPt"></div>
                <div class="mp-rating" id="mpRating"></div>
            </div>
        </div>
        <div class="mobile-preview-actions">
            <button class="btn-cancel" onclick="closeMobilePreview()">Cancel</button>
            <button class="btn-pick" id="mpPickBtn" onclick="confirmMobilePick()">Pick This Card</button>
        </div>
    </div>

    <!-- Tooltip (desktop only) -->
    <div class="card-tooltip" id="cardTooltip">
        <div class="tt-name"></div>
        <div class="tt-cost"></div>
        <div class="tt-type"></div>
        <div class="tt-oracle"></div>
        <div class="tt-pt"></div>
        <div class="tt-rating"></div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-logo">ScrollVault</div>
                <div class="wubrg-dots">
                    <span class="mana-dot" style="background: #F9FAF4"></span>
                    <span class="mana-dot" style="background: #0E68AB"></span>
                    <span class="mana-dot" style="background: #150B00; border: 1px solid rgba(255,255,255,0.2)"></span>
                    <span class="mana-dot" style="background: #D3202A"></span>
                    <span class="mana-dot" style="background: #00733E"></span>
                </div>
                <p class="footer-text">&copy; 2026 scrollvault.net. Magic: The Gathering is a trademark of Wizards of the Coast. Card images &copy; Wizards of the Coast via Scryfall.</p>
                <ul class="footer-links">
                    <li><a href="/privacy.html">Privacy Policy</a></li>
                    <li><a href="/terms.html">Terms of Service</a></li>
                    <li><a href="/contact.html">Contact</a></li>
                    <li><a href="/about/authors.html">Authors</a></li>
                    <li><a href="/about/editorial-policy.html">Editorial Policy</a></li>
                </ul>
            </div>
        </div>
    </footer>

<script>
/* ═══════════════════════════════════════════
   MTG Draft Simulator
   ═══════════════════════════════════════════ */

// ── Touch Detection ──
const isTouchDevice = window.matchMedia('(hover: none) and (pointer: coarse)').matches;
let mobileSelectedIndex = -1;

// ── Constants ──
const COLOR_ORDER = ['W','U','B','R','G','Multi','Colorless'];
const COLOR_NAMES = { W:'White', U:'Blue', B:'Black', R:'Red', G:'Green', Multi:'Multicolor', Colorless:'Colorless' };
const COLOR_HEX = { W:'#F9FAF4', U:'#0E68AB', B:'#3d3020', R:'#D3202A', G:'#00733E', Multi:'#C5AF46', Colorless:'#9E9E9E' };
const LAND_NAMES = { W:'Plains', U:'Island', B:'Swamp', R:'Mountain', G:'Forest' };
const MANA_COLORS = ['W','U','B','R','G'];
const NUM_SEATS = 8;
const PACKS_PER_DRAFT = 3;
const CARDS_PER_PACK = 14;

// ── State ──
let setData = null;
let setsIndex = [];
let allPacks = []; // [seat][pack] = array of cards
let currentPack = 0;
let currentPick = 0;
let humanPool = [];
let humanColorWeights = { W:0, U:0, B:0, R:0, G:0 };
let botPools = []; // botPools[0..6] for bots 1-7
let botStates = []; // Enhanced bot state
let undoStack = [];
let currentBoard = 'main'; // 'main' or 'side'
let sideboardSet = new Set(); // indices into humanPool that are sideboarded
let lands = { W:0, U:0, B:0, R:0, G:0 };
let draftInProgress = false;
let showPickSuggestions = false;

// ── Screens ──
function showScreen(id) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(id).classList.add('active');
    window.scrollTo(0, 0);
}

// ── Toast ──
function showToast(msg) {
    const t = document.getElementById('toast');
    t.textContent = msg;
    t.classList.add('visible');
    setTimeout(() => t.classList.remove('visible'), 2500);
}

// ══════════════════════════════════════════
// Screen 1: Set Selection
// ══════════════════════════════════════════
function loadSets() {
    return fetch('/draft/data/sets.json')
        .then(resp => resp.json())
        .then(data => { setsIndex = data; renderSetGrid(); })
        .catch(e => console.error('Failed to load sets:', e));
}

function renderSetGrid() {
    const grid = document.getElementById('setGrid');
    grid.innerHTML = '';
    setsIndex.forEach(set => {
        const card = document.createElement('div');
        card.className = 'set-card';
        card.innerHTML = `
            <div class="set-card-header">
                <img src="${set.icon_uri}" alt="${set.set_name}" class="set-icon" onerror="this.style.display='none'">
                <div>
                    <h3>${set.set_name}</h3>
                    <span style="color:var(--text-muted);font-size:0.8rem;text-transform:uppercase;letter-spacing:0.5px">${set.set_code}</span>
                </div>
            </div>
            <div class="set-meta">
                <span>&#x1F0CF; ${set.card_count} cards</span>
                <span>&#128197; ${formatDate(set.released_at)}</span>
                <span>&#127183; ${set.pack_size} per pack</span>
            </div>
            <button class="btn-start" onclick="startDraft('${set.set_code}', this)">
                <span class="btn-text">Start Draft</span>
                <span class="spinner"></span>
            </button>
        `;
        grid.appendChild(card);
    });
}

function formatDate(dateStr) {
    const d = new Date(dateStr + 'T00:00:00');
    return d.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
}

// ══════════════════════════════════════════
// Draft Engine
// ══════════════════════════════════════════
async function startDraft(setCode, btn) {
    if (draftInProgress) return;
    btn.classList.add('loading');
    btn.disabled = true;

    try {
        const resp = await fetch(`/draft/data/${setCode}.json`);
        setData = await resp.json();
    } catch (e) {
        console.error('Failed to load set data:', e);
        btn.classList.remove('loading');
        btn.disabled = false;
        showToast('Failed to load set data');
        return;
    }

    // Reset state
    humanPool = [];
    humanColorWeights = { W:0, U:0, B:0, R:0, G:0 };
    botPools = [];
    botStates = [];
    undoStack = [];
    sideboardSet = new Set();
    lands = { W:0, U:0, B:0, R:0, G:0 };
    currentPack = 0;
    currentPick = 0;
    draftInProgress = true;
    showPickSuggestions = document.getElementById('showSuggestions').checked;

    // Init bots
    for (let i = 1; i < NUM_SEATS; i++) {
        botPools.push([]);
        botStates.push(createBotState());
    }

    // Generate all packs
    generateAllPacks();

    // Preload pack 1 images
    preloadPackImages(0);

    btn.classList.remove('loading');
    btn.disabled = false;

    showScreen('screenDraft');
    renderCurrentPack();
}

function generateAllPacks() {
    allPacks = [];
    const usedRares = new Set();

    for (let seat = 0; seat < NUM_SEATS; seat++) {
        allPacks[seat] = [];
        for (let pack = 0; pack < PACKS_PER_DRAFT; pack++) {
            allPacks[seat][pack] = generatePack(usedRares);
        }
    }
}

function generatePack(usedRares) {
    const cards = setData.cards;
    const pack = [];

    // 1 rare or mythic (87.5% rare, 12.5% mythic)
    let rm = null;
    let attempts = 0;
    while (!rm && attempts < 100) {
        const isMythic = Math.random() < 0.125;
        const pool = isMythic ? cards.mythic : cards.rare;
        const candidate = pool[Math.floor(Math.random() * pool.length)];
        if (!usedRares.has(candidate.collector_number)) {
            rm = candidate;
            usedRares.add(candidate.collector_number);
        }
        attempts++;
    }
    if (!rm) {
        // Fallback: pick any rare/mythic
        const allRM = [...cards.rare, ...cards.mythic];
        rm = allRM[Math.floor(Math.random() * allRM.length)];
    }
    pack.push(rm);

    // 3 uncommons (no duplicates within pack)
    const usedInPack = new Set([rm.collector_number]);
    const uncommons = pickRandom(cards.uncommon, 3, usedInPack);
    pack.push(...uncommons);

    // 10 commons (no duplicates within pack)
    const commons = pickRandom(cards.common, 10, usedInPack);
    pack.push(...commons);

    // Shuffle
    shuffle(pack);
    return pack;
}

function pickRandom(pool, count, usedSet) {
    const result = [];
    const poolCopy = [...pool];
    shuffle(poolCopy);
    for (const card of poolCopy) {
        if (result.length >= count) break;
        if (!usedSet.has(card.collector_number)) {
            result.push(card);
            usedSet.add(card.collector_number);
        }
    }
    // If not enough unique cards, allow dupes
    while (result.length < count) {
        result.push(pool[Math.floor(Math.random() * pool.length)]);
    }
    return result;
}

function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
}

// ── Pack Passing ──
function getHumanPack() {
    // Human is seat 0. After picks, packs rotate.
    // Pack 0 (1st): passes left (seat+1)
    // Pack 1 (2nd): passes right (seat-1)
    // Pack 2 (3rd): passes left (seat+1)
    // After N picks, the pack that started at seat S is now at seat (S + N*direction) mod 8
    // We need: which pack is currently in front of seat 0?
    // Pack started at seat S, after currentPick passes it's at seat (S + currentPick * dir) mod 8
    // We want (S + currentPick * dir) mod 8 == 0
    // So S = (0 - currentPick * dir) mod 8 = (-currentPick * dir) mod 8
    const dir = (currentPack % 2 === 0) ? 1 : -1; // left = +1, right = -1
    const originSeat = ((0 - currentPick * dir) % NUM_SEATS + NUM_SEATS) % NUM_SEATS;
    return allPacks[originSeat][currentPack];
}

function getBotPack(botSeat) {
    const dir = (currentPack % 2 === 0) ? 1 : -1;
    const originSeat = ((botSeat - currentPick * dir) % NUM_SEATS + NUM_SEATS) % NUM_SEATS;
    return allPacks[originSeat][currentPack];
}

// ── Bot State Factory ──
function createBotState() {
    return {
        colorWeights: { W:0, U:0, B:0, R:0, G:0 },
        curveCounts: [0, 0, 0, 0, 0, 0, 0, 0], // CMC 0-7+
        creatureCount: 0,
        spellCount: 0,
        openColors: [] // Colors seen late in packs (signals)
    };
}

// ── Enhanced Scoring ──
function scoreCard(card, state, pickNumber) {
    let base = card.rating;

    // Color commitment (stronger as draft progresses)
    let colorFit = 0;
    if (card.colors.length === 0) {
        colorFit = 0.3; // Colorless cards always decent
    } else {
        const totalWeight = Object.values(state.colorWeights).reduce((a, b) => a + b, 0) || 1;
        colorFit = card.colors.reduce((sum, c) => sum + (state.colorWeights[c] || 0), 0) / totalWeight;
    }
    const exploitFactor = Math.min(1, Math.max(0, (pickNumber - 4) / 14));
    const colorBonus = 1.0 + (colorFit * exploitFactor * 1.8);

    // Curve needs: prefer 2-3 drops if lacking
    let curveBonus = 0;
    const cmc = Math.min(Math.ceil(card.cmc || 0), 7);
    const totalPicks = state.creatureCount + state.spellCount;
    if (totalPicks > 5) {
        if ((cmc === 2 || cmc === 3) && state.curveCounts[cmc] < 4) curveBonus = 0.4;
        else if (cmc === 1 && state.curveCounts[1] < 2) curveBonus = 0.2;
        else if (cmc >= 6 && state.curveCounts[6] + state.curveCounts[7] >= 3) curveBonus = -0.3;
    }

    // Creature density: want 14-16 creatures in final deck
    let creatureBonus = 0;
    const tl = (card.type_line || '').toLowerCase();
    const isCreature = tl.includes('creature');
    if (totalPicks > 10) {
        const creatureRatio = state.creatureCount / Math.max(1, totalPicks);
        if (isCreature && creatureRatio < 0.55) creatureBonus = 0.3;
        else if (!isCreature && creatureRatio > 0.65) creatureBonus = 0.2;
    }

    // Removal bonus
    let removalBonus = 0;
    const oracle = (card.oracle_text || '').toLowerCase();
    if (oracle.includes('destroy target') || oracle.includes('exile target') ||
        oracle.match(/deals?\s+\d+\s+damage\s+to\s+(target|any)/)) {
        removalBonus = 0.3;
    }

    // Signal reading: open colors get a small boost
    let signalBonus = 0;
    if (card.colors.length > 0 && state.openColors.length > 0) {
        const onSignal = card.colors.some(c => state.openColors.includes(c));
        if (onSignal) signalBonus = 0.2;
    }

    // Early pick rarity bonus (don't pass bombs)
    const rarityBonus = (pickNumber < 6 && (card.rarity === 'rare' || card.rarity === 'mythic')) ? 0.4 : 0;

    const jitter = Math.random() * 0.3;
    return base * colorBonus + curveBonus + creatureBonus + removalBonus + signalBonus + rarityBonus + jitter;
}

function updateBotState(botState, card) {
    card.colors.forEach(c => {
        if (botState.colorWeights[c] !== undefined) {
            botState.colorWeights[c] += card.rating;
        }
    });
    const cmc = Math.min(Math.ceil(card.cmc || 0), 7);
    botState.curveCounts[cmc]++;
    const tl = (card.type_line || '').toLowerCase();
    if (tl.includes('creature')) botState.creatureCount++;
    botState.spellCount++;
}

// ── Human color weight tracking ──
function updateHumanWeights(card) {
    card.colors.forEach(c => {
        if (humanColorWeights[c] !== undefined) {
            humanColorWeights[c] += card.rating;
        }
    });
}

// ── Human Pick ──
function humanPick(cardIndex) {
    const pack = getHumanPack();
    if (cardIndex < 0 || cardIndex >= pack.length) return;

    const card = pack[cardIndex];

    // Save undo state
    undoStack.push({
        pack: currentPack,
        pick: currentPick,
        cardIndex: cardIndex,
        card: card,
        poolLength: humanPool.length
    });

    // Remove from pack
    pack.splice(cardIndex, 1);
    humanPool.push(card);
    updateHumanWeights(card);

    // Animate pick
    const packGrid = document.getElementById('packGrid');
    const cardEls = packGrid.querySelectorAll('.pack-card');
    if (cardEls[cardIndex]) {
        cardEls[cardIndex].classList.add('picked');
    }

    // Bot picks
    doBotPicks();

    // Advance
    currentPick++;

    if (currentPick >= CARDS_PER_PACK) {
        // Next pack
        currentPack++;
        currentPick = 0;

        if (currentPack >= PACKS_PER_DRAFT) {
            // Draft complete
            draftInProgress = false;
            setTimeout(() => {
                showScreen('screenBuild');
                renderDeckBuilder();
            }, 400);
            return;
        }

        // Preload next pack images
        preloadPackImages(currentPack);
    } else {
        // Preload next pack's images in background
        if (currentPick === 0) {
            preloadPackImages(currentPack);
        }
    }

    // Re-render with delay for animation
    setTimeout(() => {
        renderCurrentPack();
        renderPool();
    }, 350);
}

function doBotPicks() {
    const globalPick = currentPack * CARDS_PER_PACK + currentPick;

    for (let b = 0; b < NUM_SEATS - 1; b++) {
        const botSeat = b + 1;
        const pack = getBotPack(botSeat);
        if (pack.length === 0) continue;

        let bestIdx = 0;
        let bestScore = -Infinity;
        for (let i = 0; i < pack.length; i++) {
            const s = scoreCard(pack[i], botStates[b], globalPick);
            if (s > bestScore) {
                bestScore = s;
                bestIdx = i;
            }
        }

        const picked = pack.splice(bestIdx, 1)[0];
        botPools[b].push(picked);
        updateBotState(botStates[b], picked);

        // Signal reading: if a good card (rating > 3) wheels late, its colors are open
        if (currentPick >= 6) {
            pack.forEach(card => {
                if (card.rating >= 3.0) {
                    card.colors.forEach(c => {
                        if (!botStates[b].openColors.includes(c)) {
                            botStates[b].openColors.push(c);
                        }
                    });
                }
            });
        }
    }
}

// ── Undo ──
function undoPick() {
    if (undoStack.length === 0) return;
    const last = undoStack.pop();

    // Undo bot picks: we can't perfectly undo bot picks, but we can restore the human pick
    // For simplicity, we only undo the human pick (bots already picked)
    // This means undo is approximate, but that's acceptable for a draft simulator
    // Actually, let's do a proper undo by regenerating. But that's complex.
    // Simple approach: just put the card back

    // Restore state
    currentPack = last.pack;
    currentPick = last.pick;
    humanPool.splice(last.poolLength);

    // Put card back in pack at original position
    const pack = getHumanPack();
    // Note: bots already picked from their packs, we can't undo that.
    // But we can put the human's card back.
    pack.splice(last.cardIndex, 0, last.card);

    renderCurrentPack();
    renderPool();
    showToast('Undo: pick returned');
}

// ── Image Preloading ──
function preloadPackImages(packNum) {
    if (packNum >= PACKS_PER_DRAFT) return;
    // Preload human's pack images
    const dir = (packNum % 2 === 0) ? 1 : -1;
    // At pick 0, the pack at seat 0 is the one that started at seat 0
    const pack = allPacks[0][packNum];
    if (!pack) return;
    pack.forEach(card => {
        const img = new Image();
        img.src = card.image_small;
    });
}

// ══════════════════════════════════════════
// Screen 2: Rendering
// ══════════════════════════════════════════
function renderCurrentPack() {
    const pack = getHumanPack();
    const grid = document.getElementById('packGrid');
    grid.innerHTML = '';

    // Calculate suggestion if enabled
    let suggestedIdx = -1;
    if (showPickSuggestions && pack.length > 0) {
        const globalPick = currentPack * CARDS_PER_PACK + currentPick;
        const humanState = {
            colorWeights: humanColorWeights,
            curveCounts: getHumanCurveCounts(),
            creatureCount: humanPool.filter(c => (c.type_line || '').toLowerCase().includes('creature')).length,
            spellCount: humanPool.length,
            openColors: []
        };
        let bestScore = -Infinity;
        pack.forEach((card, i) => {
            const s = scoreCard(card, humanState, globalPick);
            if (s > bestScore) { bestScore = s; suggestedIdx = i; }
        });
    }

    pack.forEach((card, i) => {
        const div = document.createElement('div');
        div.className = 'pack-card';
        if (i === suggestedIdx) div.classList.add('suggested');
        let badge = '';
        if (i === suggestedIdx) badge = '<span class="suggestion-badge">TOP</span>';
        div.innerHTML = `
            <img src="${card.image_small}" alt="${card.name}" loading="lazy">
            <span class="card-number">${i + 1}</span>
            ${badge}
        `;
        if (isTouchDevice) {
            div.addEventListener('click', (e) => {
                e.preventDefault();
                openMobilePreview(card, i);
            });
        } else {
            div.addEventListener('click', () => humanPick(i));
            div.addEventListener('mouseenter', (e) => showTooltip(card, e));
            div.addEventListener('mousemove', (e) => moveTooltip(e));
            div.addEventListener('mouseleave', hideTooltip);
        }
        grid.appendChild(div);
    });

    // Preload next pack in background
    if (currentPick < CARDS_PER_PACK - 1) {
        // Preload remaining images already loaded
    } else if (currentPack + 1 < PACKS_PER_DRAFT) {
        preloadPackImages(currentPack + 1);
    }

    // Update header
    const packNum = currentPack + 1;
    const pickNum = currentPick + 1;
    document.getElementById('packLabel').textContent = `Pack ${packNum} \u2014 Pick ${pickNum} of ${CARDS_PER_PACK}`;

    const dir = (currentPack % 2 === 0) ? 'left' : 'right';
    const arrow = dir === 'left' ? '\u2192' : '\u2190';
    document.getElementById('passDirection').innerHTML = `Passing ${dir} ${arrow}`;

    const totalPicks = PACKS_PER_DRAFT * CARDS_PER_PACK;
    const donePicks = currentPack * CARDS_PER_PACK + currentPick;
    document.getElementById('progressFill').style.width = `${(donePicks / totalPicks) * 100}%`;
}

// ── Tooltip ──
function showTooltip(card, e) {
    const tip = document.getElementById('cardTooltip');
    tip.querySelector('.tt-name').textContent = card.name;
    tip.querySelector('.tt-cost').textContent = card.mana_cost || '';
    tip.querySelector('.tt-type').textContent = card.type_line;
    tip.querySelector('.tt-oracle').textContent = card.oracle_text || '';

    let ptText = '';
    if (card.power !== null && card.toughness !== null) {
        ptText = `${card.power}/${card.toughness}`;
    } else if (card.loyalty !== null) {
        ptText = `Loyalty: ${card.loyalty}`;
    }
    tip.querySelector('.tt-pt').textContent = ptText;
    let ratingText = `Rating: ${card.rating.toFixed(1)} \u2022 ${card.rarity}`;
    if (card.gih_wr) ratingText += ` \u2022 ${card.gih_wr}% GIH WR`;
    tip.querySelector('.tt-rating').textContent = ratingText;

    tip.classList.add('visible');
    moveTooltip(e);
}

function moveTooltip(e) {
    const tip = document.getElementById('cardTooltip');
    const pad = 15;
    let x = e.clientX + pad;
    let y = e.clientY + pad;

    // Keep on screen
    const rect = tip.getBoundingClientRect();
    if (x + 280 > window.innerWidth) x = e.clientX - 280 - pad;
    if (y + rect.height > window.innerHeight) y = e.clientY - rect.height - pad;

    tip.style.left = x + 'px';
    tip.style.top = y + 'px';
}

function hideTooltip() {
    document.getElementById('cardTooltip').classList.remove('visible');
}

// ── Pool Rendering ──
function getCardColorGroup(card) {
    if (card.colors.length > 1) return 'Multi';
    if (card.colors.length === 0) return 'Colorless';
    return card.colors[0];
}

function renderPool() {
    const container = document.getElementById('poolColors');
    container.innerHTML = '';

    // Group by color
    const groups = {};
    COLOR_ORDER.forEach(c => groups[c] = []);
    humanPool.forEach(card => {
        const group = getCardColorGroup(card);
        groups[group].push(card);
    });

    // Sort within groups by CMC
    Object.values(groups).forEach(arr => arr.sort((a, b) => a.cmc - b.cmc));

    COLOR_ORDER.forEach(color => {
        if (groups[color].length === 0) return;
        const div = document.createElement('div');
        div.className = 'pool-color-group';
        const borderStyle = color === 'B' ? '1px solid rgba(255,255,255,0.2)' : 'none';
        div.innerHTML = `
            <div class="pool-color-label">
                <span class="pool-color-dot" style="background:${COLOR_HEX[color]};border:${borderStyle}"></span>
                ${COLOR_NAMES[color]} (${groups[color].length})
            </div>
            <div class="pool-color-cards">
                ${groups[color].map(card => {
                    const idx = humanPool.indexOf(card);
                    if (isTouchDevice) {
                        return `<div class="pool-mini-card" onclick="showPoolCardPreview(${idx})">
                            <img src="${card.image_small}" alt="${card.name}" loading="lazy">
                        </div>`;
                    } else {
                        return `<div class="pool-mini-card" onmouseenter="showTooltip(humanPool[${idx}], event)" onmousemove="moveTooltip(event)" onmouseleave="hideTooltip()">
                            <img src="${card.image_small}" alt="${card.name}" loading="lazy">
                        </div>`;
                    }
                }).join('')}
            </div>
        `;
        container.appendChild(div);
    });

    // Update pool count
    document.getElementById('poolCount').textContent = `${humanPool.length} cards`;

    // Update mini mana curve
    updateMiniCurve();
}

function updateMiniCurve() {
    const counts = [0, 0, 0, 0, 0]; // CMC 1, 2, 3, 4, 5+
    humanPool.forEach(card => {
        const cmc = Math.min(Math.max(Math.ceil(card.cmc), 1), 5);
        if (card.cmc === 0) return; // lands
        if (cmc >= 5) counts[4]++;
        else counts[cmc - 1]++;
    });

    const max = Math.max(...counts, 1);
    const bars = document.querySelectorAll('#miniCurveBars .curve-bar');
    bars.forEach((bar, i) => {
        const h = (counts[i] / max) * 36;
        bar.style.height = Math.max(2, h) + 'px';
        bar.querySelector('.curve-bar-count').textContent = counts[i] || '';
    });
}

// ── Mobile Preview ──
function openMobilePreview(card, index) {
    mobileSelectedIndex = index;

    // Highlight selected card in grid
    document.querySelectorAll('.pack-card').forEach((el, i) => {
        el.classList.toggle('selected', i === index);
    });

    // Fill preview panel
    document.getElementById('mpImg').src = card.image_normal || card.image_small;
    document.getElementById('mpName').textContent = card.name;
    document.getElementById('mpCost').textContent = card.mana_cost || '';
    document.getElementById('mpType').textContent = card.type_line;
    document.getElementById('mpOracle').textContent = card.oracle_text || '';

    let ptText = '';
    if (card.power !== null && card.toughness !== null) ptText = `${card.power}/${card.toughness}`;
    else if (card.loyalty !== null) ptText = `Loyalty: ${card.loyalty}`;
    document.getElementById('mpPt').textContent = ptText;
    document.getElementById('mpRating').textContent = `Rating: ${card.rating.toFixed(1)} \u2022 ${card.rarity}` + (card.gih_wr ? ` \u2022 ${card.gih_wr}% GIH WR` : '');

    // Show pick button and panel
    document.getElementById('mpPickBtn').style.display = '';
    document.getElementById('mobileOverlay').classList.add('visible');
    document.getElementById('mobilePreview').classList.add('visible');
}

function closeMobilePreview() {
    mobileSelectedIndex = -1;
    document.querySelectorAll('.pack-card').forEach(el => el.classList.remove('selected'));
    document.getElementById('mobileOverlay').classList.remove('visible');
    document.getElementById('mobilePreview').classList.remove('visible');
}

function confirmMobilePick() {
    if (mobileSelectedIndex < 0) return;
    const idx = mobileSelectedIndex;
    closeMobilePreview();
    humanPick(idx);
}

function showPoolCardPreview(poolIndex) {
    const card = humanPool[poolIndex];
    if (!card) return;
    document.getElementById('mpImg').src = card.image_normal || card.image_small;
    document.getElementById('mpName').textContent = card.name;
    document.getElementById('mpCost').textContent = card.mana_cost || '';
    document.getElementById('mpType').textContent = card.type_line;
    document.getElementById('mpOracle').textContent = card.oracle_text || '';
    let ptText = '';
    if (card.power !== null && card.toughness !== null) ptText = `${card.power}/${card.toughness}`;
    else if (card.loyalty !== null) ptText = `Loyalty: ${card.loyalty}`;
    document.getElementById('mpPt').textContent = ptText;
    document.getElementById('mpRating').textContent = `Rating: ${card.rating.toFixed(1)} \u2022 ${card.rarity}` + (card.gih_wr ? ` \u2022 ${card.gih_wr}% GIH WR` : '');
    // Hide pick button for pool view
    document.getElementById('mpPickBtn').style.display = 'none';
    mobileSelectedIndex = -1;
    document.getElementById('mobileOverlay').classList.add('visible');
    document.getElementById('mobilePreview').classList.add('visible');
}

// ── Keyboard ──
document.addEventListener('keydown', (e) => {
    if (!draftInProgress) return;
    const screen = document.getElementById('screenDraft');
    if (!screen.classList.contains('active')) return;

    if (e.key === 'z' || e.key === 'Z') {
        e.preventDefault();
        undoPick();
        return;
    }

    const num = parseInt(e.key);
    if (num >= 1 && num <= 9) {
        e.preventDefault();
        humanPick(num - 1);
    }
});

// ══════════════════════════════════════════
// Screen 3: Deck Builder
// ══════════════════════════════════════════
function renderDeckBuilder() {
    sideboardSet = new Set();
    lands = { W:0, U:0, B:0, R:0, G:0 };
    currentBoard = 'main';

    renderLandControls();
    renderDeckColumns();
    renderHistogram();
    updateDeckStats();

    // Set board tab active
    document.querySelectorAll('.board-tab').forEach(t => t.classList.toggle('active', t.dataset.board === 'main'));
}

function switchBoard(board) {
    currentBoard = board;
    document.querySelectorAll('.board-tab').forEach(t => t.classList.toggle('active', t.dataset.board === board));
    renderDeckColumns();
}

function toggleSideboard(poolIndex) {
    if (sideboardSet.has(poolIndex)) {
        sideboardSet.delete(poolIndex);
    } else {
        sideboardSet.add(poolIndex);
    }
    renderDeckColumns();
    renderHistogram();
    updateDeckStats();
}

function renderDeckColumns() {
    const container = document.getElementById('deckColumns');
    container.innerHTML = '';

    // Filter cards for current board view
    const mainCards = [];
    const sideCards = [];
    humanPool.forEach((card, i) => {
        if (sideboardSet.has(i)) {
            sideCards.push({ card, index: i });
        } else {
            mainCards.push({ card, index: i });
        }
    });

    const displayCards = currentBoard === 'main' ? mainCards : sideCards;

    // Group by color
    const groups = {};
    COLOR_ORDER.forEach(c => groups[c] = []);
    displayCards.forEach(({ card, index }) => {
        const group = getCardColorGroup(card);
        groups[group].push({ card, index });
    });

    // Sort by CMC within group
    Object.values(groups).forEach(arr => arr.sort((a, b) => a.card.cmc - b.card.cmc || a.card.name.localeCompare(b.card.name)));

    COLOR_ORDER.forEach(color => {
        if (groups[color].length === 0) return;

        const col = document.createElement('div');
        col.className = 'deck-column';
        const borderStyle = color === 'B' ? '1px solid rgba(255,255,255,0.2)' : 'none';
        col.innerHTML = `
            <div class="deck-col-header" style="border-color:${COLOR_HEX[color]}">
                <span class="col-dot" style="background:${COLOR_HEX[color]};border:${borderStyle}"></span>
                ${COLOR_NAMES[color]} (${groups[color].length})
            </div>
        `;

        groups[color].forEach(({ card, index }) => {
            const entry = document.createElement('div');
            entry.className = 'deck-card-entry';
            if (sideboardSet.has(index)) entry.classList.add('sideboarded');
            entry.innerHTML = `
                <div class="entry-img"><img src="${card.image_small}" alt="${card.name}" loading="lazy"></div>
                <span class="entry-name">${card.name}</span>
                <span class="entry-cmc">${card.cmc > 0 ? card.mana_cost : ''}</span>
            `;
            entry.addEventListener('click', () => toggleSideboard(index));
            if (!isTouchDevice) {
                entry.addEventListener('mouseenter', (e) => showTooltip(card, e));
                entry.addEventListener('mousemove', (e) => moveTooltip(e));
                entry.addEventListener('mouseleave', hideTooltip);
            }
            col.appendChild(entry);
        });

        container.appendChild(col);
    });
}

function renderHistogram() {
    const container = document.getElementById('histogram');
    container.innerHTML = '';

    // Count CMC for mainboard cards only
    const counts = [0, 0, 0, 0, 0, 0, 0]; // 0, 1, 2, 3, 4, 5, 6+
    humanPool.forEach((card, i) => {
        if (sideboardSet.has(i)) return;
        const cmc = Math.min(Math.ceil(card.cmc), 6);
        if (card.type_line && card.type_line.toLowerCase().includes('land')) return;
        counts[Math.max(0, cmc)]++;
    });

    // Color distribution for bars
    const colorCounts = {};
    MANA_COLORS.forEach(c => colorCounts[c] = [0,0,0,0,0,0,0]);
    humanPool.forEach((card, i) => {
        if (sideboardSet.has(i)) return;
        if (card.type_line && card.type_line.toLowerCase().includes('land')) return;
        const cmc = Math.min(Math.ceil(card.cmc), 6);
        const bucket = Math.max(0, cmc);
        const group = getCardColorGroup(card);
        if (MANA_COLORS.includes(group)) {
            colorCounts[group][bucket]++;
        }
    });

    const max = Math.max(...counts, 1);
    const labels = ['0', '1', '2', '3', '4', '5', '6+'];

    labels.forEach((label, i) => {
        const col = document.createElement('div');
        col.className = 'histo-col';
        const h = (counts[i] / max) * 80;
        col.innerHTML = `
            <span class="histo-count">${counts[i] || ''}</span>
            <div class="histo-bar" style="height:${Math.max(0, h)}px; background: var(--gradient-purple);"></div>
            <span class="histo-label">${label}</span>
        `;
        container.appendChild(col);
    });
}

function renderLandControls() {
    const container = document.getElementById('landControls');
    container.innerHTML = '';

    const colorInfo = [
        { c: 'W', name: 'Plains', bg: '#F9FAF4', fg: '#333' },
        { c: 'U', name: 'Island', bg: '#0E68AB', fg: '#fff' },
        { c: 'B', name: 'Swamp', bg: '#3d3020', fg: '#fff' },
        { c: 'R', name: 'Mountain', bg: '#D3202A', fg: '#fff' },
        { c: 'G', name: 'Forest', bg: '#00733E', fg: '#fff' }
    ];

    colorInfo.forEach(info => {
        const ctrl = document.createElement('div');
        ctrl.className = 'land-control';
        ctrl.innerHTML = `
            <div class="land-symbol" style="background:${info.bg};color:${info.fg}">${info.c}</div>
            <button onclick="changeLand('${info.c}', -1)">&minus;</button>
            <span class="land-count" id="land-${info.c}">${lands[info.c]}</span>
            <button onclick="changeLand('${info.c}', 1)">+</button>
        `;
        container.appendChild(ctrl);
    });

    // Total lands display
    const total = document.createElement('div');
    total.style.cssText = 'margin-left:0.5rem;font-size:0.85rem;color:var(--text-secondary)';
    total.id = 'landTotal';
    total.textContent = `Total: ${Object.values(lands).reduce((a, b) => a + b, 0)} lands`;
    container.appendChild(total);

    // Auto suggest button is in builder-actions
}

function changeLand(color, delta) {
    lands[color] = Math.max(0, lands[color] + delta);
    document.getElementById(`land-${color}`).textContent = lands[color];
    document.getElementById('landTotal').textContent = `Total: ${Object.values(lands).reduce((a, b) => a + b, 0)} lands`;
    updateDeckStats();
}

function autoSuggestLands() {
    // Count color pips in mainboard cards
    const pips = { W:0, U:0, B:0, R:0, G:0 };

    humanPool.forEach((card, i) => {
        if (sideboardSet.has(i)) return;
        if (!card.mana_cost) return;
        const cost = card.mana_cost;
        (cost.match(/\{W\}/g) || []).forEach(() => pips.W++);
        (cost.match(/\{U\}/g) || []).forEach(() => pips.U++);
        (cost.match(/\{B\}/g) || []).forEach(() => pips.B++);
        (cost.match(/\{R\}/g) || []).forEach(() => pips.R++);
        (cost.match(/\{G\}/g) || []).forEach(() => pips.G++);
    });

    const totalPips = Object.values(pips).reduce((a, b) => a + b, 0) || 1;
    const mainSpells = humanPool.filter((c, i) => !sideboardSet.has(i)).length;
    const targetLands = Math.max(0, 40 - mainSpells); // Usually aim for 40-card deck with ~17 lands
    const desiredLands = Math.min(Math.max(targetLands, 15), 18);

    // Distribute lands proportional to pips
    const newLands = { W:0, U:0, B:0, R:0, G:0 };
    let assigned = 0;

    // First pass: proportional
    MANA_COLORS.forEach(c => {
        if (pips[c] > 0) {
            newLands[c] = Math.round((pips[c] / totalPips) * desiredLands);
            assigned += newLands[c];
        }
    });

    // Adjust to hit target
    const activeColors = MANA_COLORS.filter(c => pips[c] > 0);
    while (assigned > desiredLands && activeColors.length > 0) {
        // Remove from smallest
        activeColors.sort((a, b) => newLands[a] - newLands[b]);
        for (const c of activeColors) {
            if (assigned <= desiredLands) break;
            if (newLands[c] > 0) { newLands[c]--; assigned--; }
        }
    }
    while (assigned < desiredLands && activeColors.length > 0) {
        // Add to largest pip color
        activeColors.sort((a, b) => pips[b] - pips[a]);
        for (const c of activeColors) {
            if (assigned >= desiredLands) break;
            newLands[c]++; assigned++;
        }
    }

    lands = newLands;
    MANA_COLORS.forEach(c => {
        const el = document.getElementById(`land-${c}`);
        if (el) el.textContent = lands[c];
    });
    document.getElementById('landTotal').textContent = `Total: ${Object.values(lands).reduce((a, b) => a + b, 0)} lands`;
    updateDeckStats();
    showToast(`Suggested ${desiredLands} lands based on color pips`);
}

function updateDeckStats() {
    const mainCards = humanPool.filter((c, i) => !sideboardSet.has(i));
    const sideCards = humanPool.filter((c, i) => sideboardSet.has(i));
    const totalLands = Object.values(lands).reduce((a, b) => a + b, 0);

    document.getElementById('statMain').textContent = mainCards.length + totalLands;
    document.getElementById('statSpells').textContent = mainCards.length;
    document.getElementById('statLands').textContent = totalLands;
    document.getElementById('statSide').textContent = sideCards.length;
}

// ── Export ──
function exportDeck() {
    let text = '';

    // Mainboard spells sorted by name
    const mainCards = [];
    humanPool.forEach((card, i) => {
        if (!sideboardSet.has(i)) mainCards.push(card);
    });

    // Group and count
    const mainCounts = {};
    mainCards.forEach(card => {
        mainCounts[card.name] = (mainCounts[card.name] || 0) + 1;
    });

    text += 'Deck\n';
    Object.keys(mainCounts).sort().forEach(name => {
        text += `${mainCounts[name]} ${name}\n`;
    });

    // Lands
    MANA_COLORS.forEach(c => {
        if (lands[c] > 0) {
            text += `${lands[c]} ${LAND_NAMES[c]}\n`;
        }
    });

    // Sideboard
    const sideCounts = {};
    humanPool.forEach((card, i) => {
        if (sideboardSet.has(i)) {
            sideCounts[card.name] = (sideCounts[card.name] || 0) + 1;
        }
    });

    if (Object.keys(sideCounts).length > 0) {
        text += '\nSideboard\n';
        Object.keys(sideCounts).sort().forEach(name => {
            text += `${sideCounts[name]} ${name}\n`;
        });
    }

    navigator.clipboard.writeText(text).then(() => {
        showToast('Deck copied to clipboard (Arena format)');
    }).catch(() => {
        // Fallback
        const ta = document.createElement('textarea');
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        showToast('Deck copied to clipboard (Arena format)');
    });
}

// ── Actions ──
function draftAgain() {
    if (setData) {
        humanPool = [];
        humanColorWeights = { W:0, U:0, B:0, R:0, G:0 };
        botPools = [];
        botStates = [];
        undoStack = [];
        sideboardSet = new Set();
        lands = { W:0, U:0, B:0, R:0, G:0 };
        currentPack = 0;
        currentPick = 0;
        draftInProgress = true;
        showPickSuggestions = document.getElementById('showSuggestions').checked;

        for (let i = 1; i < NUM_SEATS; i++) {
            botPools.push([]);
            botStates.push(createBotState());
        }

        generateAllPacks();
        preloadPackImages(0);
        showScreen('screenDraft');
        renderCurrentPack();
        renderPool();
    }
}

function changeSet() {
    draftInProgress = false;
    showScreen('screenSelect');
}

// ── Helper: human curve counts for suggestion scoring ──
function getHumanCurveCounts() {
    const counts = [0, 0, 0, 0, 0, 0, 0, 0];
    humanPool.forEach(card => {
        const cmc = Math.min(Math.ceil(card.cmc || 0), 7);
        counts[cmc]++;
    });
    return counts;
}

// ── Auto-Build Deck ──
function autoBuildDeck() {
    if (humanPool.length === 0) return;

    // Score each color
    const colorScores = { W:0, U:0, B:0, R:0, G:0 };
    humanPool.forEach(card => {
        if ((card.type_line || '').toLowerCase().includes('land')) return;
        const score = card.rating || 2.0;
        (card.colors || []).forEach(c => { if (colorScores[c] !== undefined) colorScores[c] += score; });
    });

    // Pick top 2 colors
    const sortedColors = MANA_COLORS.slice().sort((a, b) => colorScores[b] - colorScores[a]);
    const primaryColors = new Set([sortedColors[0], sortedColors[1]]);

    // Select on-color cards, sorted by power
    const candidates = [];
    humanPool.forEach((card, idx) => {
        if ((card.type_line || '').toLowerCase().includes('land')) return;
        const colors = card.colors || [];
        const isOnColor = colors.length === 0 || colors.some(c => primaryColors.has(c));
        if (isOnColor) candidates.push({ idx, card, score: card.rating || 2.0 });
    });
    candidates.sort((a, b) => b.score - a.score);

    // Take best 23 spells, sideboard the rest
    sideboardSet = new Set();
    const selected = new Set(candidates.slice(0, 23).map(c => c.idx));
    humanPool.forEach((_, idx) => {
        if (!selected.has(idx)) sideboardSet.add(idx);
    });

    // Auto-suggest lands for the selected cards
    const pips = { W:0, U:0, B:0, R:0, G:0 };
    candidates.slice(0, 23).forEach(({ card }) => {
        const cost = card.mana_cost || '';
        (cost.match(/\{W\}/g) || []).forEach(() => pips.W++);
        (cost.match(/\{U\}/g) || []).forEach(() => pips.U++);
        (cost.match(/\{B\}/g) || []).forEach(() => pips.B++);
        (cost.match(/\{R\}/g) || []).forEach(() => pips.R++);
        (cost.match(/\{G\}/g) || []).forEach(() => pips.G++);
    });

    const totalPips = Object.values(pips).reduce((a, b) => a + b, 0) || 1;
    lands = { W:0, U:0, B:0, R:0, G:0 };
    let assigned = 0;
    MANA_COLORS.forEach(c => {
        if (pips[c] > 0) {
            lands[c] = Math.round((pips[c] / totalPips) * 17);
            assigned += lands[c];
        }
    });
    const activeColors = MANA_COLORS.filter(c => pips[c] > 0).sort((a, b) => pips[b] - pips[a]);
    while (assigned < 17 && activeColors.length > 0) { lands[activeColors[0]]++; assigned++; }
    while (assigned > 17) {
        const smallest = activeColors.filter(c => lands[c] > 0).sort((a, b) => lands[a] - lands[b])[0];
        if (smallest) { lands[smallest]--; assigned--; } else break;
    }

    MANA_COLORS.forEach(c => {
        const el = document.getElementById(`land-${c}`);
        if (el) el.textContent = lands[c];
    });
    document.getElementById('landTotal').textContent = `Total: ${Object.values(lands).reduce((a, b) => a + b, 0)} lands`;

    currentBoard = 'main';
    document.querySelectorAll('.board-tab').forEach(t => t.classList.toggle('active', t.dataset.board === 'main'));
    renderDeckColumns();
    renderHistogram();
    updateDeckStats();
    showToast(`Auto-built ${23} spells + 17 lands in ${sortedColors[0]}/${sortedColors[1]}`);
}

// ── Settings toggle listener ──
document.getElementById('showSuggestions').addEventListener('change', function() {
    showPickSuggestions = this.checked;
    if (draftInProgress) renderCurrentPack();
});

// ── URL param support: ?set=xxx ──
function getSetParam() {
    const params = new URLSearchParams(window.location.search);
    return params.get('set');
}

// ══════════════════════════════════════════
// Init
// ══════════════════════════════════════════
loadSets().then(() => {
    const setParam = getSetParam();
    if (setParam) {
        // Auto-start draft for the specified set
        const matchingSet = setsIndex.find(s => s.set_code === setParam.toLowerCase());
        if (matchingSet) {
            startDraft(matchingSet.set_code, document.querySelector('.btn-start') || document.createElement('button'));
        }
    }
});
</script>
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebApplication","name":"MTG Draft Simulator","url":"https://scrollvault.net/draft/","applicationCategory":"GameApplication","operatingSystem":"Any","offers":{"@type":"Offer","price":"0","priceCurrency":"USD"},"description":"Free MTG draft simulator with smart AI opponents. Practice drafting from 14+ real sets including Aetherdrift and Foundations. 3 packs, 14 cards, 7 AI drafters. Build your deck and export to Arena.","isPartOf":{"@type":"WebSite","name":"ScrollVault","url":"https://scrollvault.net"},"publisher":{"@type":"Organization","name":"ScrollVault","url":"https://scrollvault.net","logo":{"@type":"ImageObject","url":"https://scrollvault.net/og-default.png"}}}
</script>
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"FAQPage","mainEntity":[{"@type":"Question","name":"How does the MTG draft simulator work?","acceptedAnswer":{"@type":"Answer","text":"Our draft simulator replicates a real 8-player booster draft. You sit at a virtual table with 7 AI opponents. Each player opens a pack of 14 cards, picks one, and passes the rest. Packs alternate passing direction each round (left, right, left). After 3 packs and 42 total picks, you build a 40-card deck from your picks plus basic lands."}},{"@type":"Question","name":"How many cards do you pick in an MTG draft?","acceptedAnswer":{"@type":"Answer","text":"In a standard booster draft, you make 42 picks total: 14 cards from each of 3 packs (14 × 3 = 42). You then build a minimum 40-card deck from those picks, adding basic lands as needed. Most players end up playing 22-24 spells and 16-18 lands."}},{"@type":"Question","name":"How many packs in a Magic draft?","acceptedAnswer":{"@type":"Answer","text":"A standard MTG booster draft uses 3 packs per player. With 8 players, that's 24 packs total. Pack 1 passes left, Pack 2 passes right, and Pack 3 passes left again. Each pack starts with 14 draftable cards."}},{"@type":"Question","name":"Can I practice MTG draft for free?","acceptedAnswer":{"@type":"Answer","text":"Yes! This draft simulator is completely free with no account required. Practice as many drafts as you like from 14+ real Magic sets. The AI bots use intelligent pick logic based on card ratings, color signals, and curve considerations."}},{"@type":"Question","name":"What sets are available to draft?","acceptedAnswer":{"@type":"Answer","text":"We currently support 14 sets with pre-loaded card data and ratings, including recent sets like Lorwyn Eclipsed, Aetherdrift, Foundations, Duskmourn, Bloomburrow, Modern Horizons 3, and more. New sets are added regularly."}},{"@type":"Question","name":"How do the AI draft bots pick cards?","acceptedAnswer":{"@type":"Answer","text":"Each AI bot uses a scoring system that considers the card's base rating, color fit, mana curve needs, creature density targets, and open-color signals. Early picks focus on raw power, while later picks prioritize staying on-color and filling curve gaps."}},{"@type":"Question","name":"How to export draft deck to MTG Arena?","acceptedAnswer":{"@type":"Answer","text":"After building your deck, click the Export to Arena button. This copies your decklist in MTGA-compatible format to your clipboard. Open MTG Arena, go to Decks, click Import, and paste."}},{"@type":"Question","name":"What is the best draft strategy for beginners?","acceptedAnswer":{"@type":"Answer","text":"Start with the BREAD method: Bombs (powerful rares/mythics), Removal (cards that destroy creatures), Evasion (flying, menace, trample), Aggro (efficient creatures), Duds (everything else). Stick to 2 colors, aim for 15-17 creatures, and prioritize 2-3 mana cost cards."}}]}
</script>
</body>
</html>
